 

 

À The Motor Industry Software Reliability Association

 

MISRA C++:2008

Guidelines
for the use

of the

C++ language
in critical
systems

d to: Insigma Raïl Transport. Engineering Co

June 2008

  
 

First published June 2008

MIRA Limited

Watling Street

Nuneaton

Warwickshire CV10 OTU
UK

WWW.MiISrAa-Cpp.coMm
© MIRA Limited, 2008.

“MISRA”, “MISRA C” and the triangle logo are registered trademarks of MIRA Limited, held on
behalf of the MISRA Consortium.

AI rights reserved. No part of this publication may be reproduced, stored in a retrieval system or

transmitted in any form or by any means, electronic, mechanical or photocopying, recording or
otherwise without the prior written permission of the Publisher.

ISBN 978-1-906400-03-3 paperback
ISBN 978-1-906400-04-0 PDF

Printed by Hobbs the Printers Ltd

British Library Cataloguing in Publication Data.
A catalogue record for this book is available from the British Library

 

This copy of MISRA C++:2008 - Guidelines for the use of the C++ language in critical
systems 1s issued to He Yulin of Insigma Rail Transport. Engineering Co. at No.9 Hangda
Road, Hangzhou, Zhejiang, 310007.

The file must not be altered in any way. No permission is given for distribution of this file.
This includes but 1s not exclusively limited to making the copy available to others by email,
placing it on a server for access by intra- or inter-net, or by printing and distributing
hardcopies. Any such use constitutes an infringement of copyright.

MISRA gives no guarantees about the accuracy of the information contained in this PDF
version of the Guidelines. The published paper document should be taken as authoritative.

Information is available from the MISRA web site on how to purchase printed copies of the

document.

Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 

 

 

 
 

À The Motor Industry Software Reliability Association

MISRA C++:2008

Guidelines
for the use

of the

C++ language
in critical
systems

June 2008
 

MISRA Mission Statement: To provide assistance to the automotive industry in the application
and creation within vehicle systems of safe and reliable software.

MISRA, The Motor Industry Software Reliability Association, is a collaboration between vehicle
manufacturers, component suppliers and engineering consultancies which seeks to promote best
practice in developing safety-related electronic systems in road vehicles and other embedded
systems. To this end MISRA publishes documents that provide accessible information for engineers
and management, and holds events to permit the exchange of experiences between practitioners.

wWwWw.misra.org.uk

Disclaimer

Adherence to the requirements of this document does not in itself ensure error-free robust
software or guarantee portability and re-use.

Compliance with the requirements of this document, or any other standard, does not of itself
confer immunity from legal obligations.

 

ii Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Foreword

 

“C' makes it easy to shoot yourself in the foot; C++ makes it harder. but when you do it blows your
whole leg off.” — Bjarne Stroustrup

Few could have predicted the effect that MISRA C would have within embedded systems
engineering. Since its launch in 1998, it has become the dominant coding standard used for the
development of critical systems with the C programming language.

Given this success, the fact that C++ is now being used within critical systems (e.g. the Joint Strike
Fighter, jet-engine controllers and medical systems), and that there is currently no universally
accepted set of guidelines for its use in these systems, MISRA committed itself to the development
of a similar set of guidelines for C++. To that end, the MISRA C++ Working Group was established
towards the end of September 2005. Its objectives were to:

*_ Produce, using techniques similar to those within MISRA C, a C++ subset suitable for use
in critical systems;

*_ Gather existing C++ guidelines from many diverse sources into a single repository;

*_ Add new guidance so as to significantly enhance the state-of-the-art;

*_ Establish a single, generic set of guidelines for the use of C++ in critical systems;

*_ Produce guidelines that are understandable to the majority of programmers.

The work to produce the guidelines made a rapid start, and was greatly assisted by the many in-
house coding standards that were made available to the group — thanks are due to all those who
contributed. These, and the guidelines available from other sources, formed a solid foundation on
which to base many rules.

Focus then moved on to the production of guidelines for Templates, Inheritance and Exception
Handling, with these areas being specifically targeted as the existing state-of-the-art did not
provide adequate coverage. The issues associated with Unnecessary Constructs were also selected
for investigation.

This document contains the results of these activities. The group hopes that MISRA C++ will go
on to become as successful and widely-adopted as MISRA C.

Finally, I would like to give my personal thanks to all of those who sat on the Working Group.
I have, as always, learnt a lot from them during the development process. I just hope I have
managed to put enough back into the project to repay part of the debt I owe them all.

Chris Tapp, BSc (Hons), MIEE
MISRA C++ Chairman

15 April 2008

 

jil Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Acknowledgements

 

The MISRA consortium would like to thank the following individuals for their significant
contribution to the writing of this document:

Richard Corden Programming Research Ltd
Mike Hennell LDRA Ltd

Derek Jones Knowledge Software Ltd
Keith Longmore Lotus Cars Ltd

Clive Pygott QinetiQ Ltd

Chris Tapp Keylevel Consultants Ltd

The MISRA consortium also wishes to acknowledge contributions from the following individuals
during the development and review process:

 

Dave Banham AI Grant Frank Martinez John Ridgway
Martin Beeby Christopher Hall Jason Masters Iris Rôdder
Fergus Bolger Frank Haug Jürgen Mottok Walter Schilling
Martin Bonner Stefan Heinzmann Chris Mycock Ben Smith
Michael R. Bossert Robert Hooper Tadanori Nakagawa Andreas Stangl
Antonio Cavallo Elmar Hufschmid Hans Odeberg Toshihiro Tajima
Ian Chalinder Paul Jeary Charles Osborn David Ward
Kwok Chan Josef Kollar Rob Pearce Andrew Warren
Valéry Creux Albert Kreitmevyr PremAnand M Rao Andrew Watson
David Crocker Fred Long Derek Reinhardt Ashley Wise
Thomas M. Galla Andreas Ludwig David Reversat

iv Licensed to: Insigma Rail Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
Contents

 

 

1. Background... iii 1
1.1 The use of C++in critical systems 1
1.2 Language insecurities and the C++ language... 1

1.2.1 The developer makes mistakes.…..…..................... 1
1.2.2 The developer misunderstands the language... 2
1.2.3 The compiler does not do what the developer expects…................................ 2
1.2.4 The compiler contains errors... 2
1.2.5  Run-time errors iii 2
1.3 The use of C++ for safety-related systems 2
1.4 C++ standardization.…....................... iii 3

2. The vision... iii 4
2.1  Rationale for the production of MISRA C++... us 4
2.2  Objectives of MISRA C++... iii À

3. Scope... iii 5
3.1 Base language issues... 5
3.2 Issues not addressed.…............................. 5
3.3  Applicability iii 5
3.4  Prerequisite knowledge... 5
3.5 Library issues... us 5
3.6  Auto-generated code issues 6

4... Using MISRA C++... iii 7
4.1 The software engineering context... 7
4.2 The programming language and coding context 7

42.1 Training... ice 7
4.2.2 Style guide... iii. 8
4.2.3 Tool selection and validation... 8
4.2.4 Source complexity metrics us 9
4.2.5 Test coverage... ie 9
4.3  Adopting the subset 10
4.3.1 Compliance matrix... iii 10
4.3.2  Deviation procedure... is 10
43.3  Formalization within quality system... 12
4.3.4  Introducing the subset 12
44  Claiming compliance iii 12
45  Continuous improvement... issue 12
V Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
Co nte nts (continued)

 

 

5. Introduction to the rules... ses 13
5.1 Rule classification... seen 13
5.1.1 Required rules un 13
5.1.2 Advisory rules... 13
5.1.3 Document rules ii iueaseeerrer 13
5.2 Organization of rules 13
5.3 Exceptions to the rules... 13
5.4  Redundancy in the rules... 14
5.5 Presentation of rules iii 14
5.6  Understanding the issue references 15
5.7 Scope of rules nu 16
6 Rules... iii ererrrrreeerernereeeeseeineneseeeeeeesneneeenne 17
6.0 Language independent issues 17
6.0.1  Unnecessary constructs us 17
6.0.2 Storage... issue 25
6.0.3 Runtime failures sise 26
6.0.4  Arithmetic................. iii 29
6.1 General ii iieeeerrrrrneeerrerrreneeeerreereeeeenee 30
6.10 Language... iii 30
6.2  Lexical conventions sieurs 31
6.2.2 Character sets ii 31
6.2.3  Trigraph sequences...’ 31
6.2.5 Alternative tokens ui 32
6.2.7 Comments... iii 32
6.2.10 Identifiers.…........................... user 34
6.2.13 Literals..…....…........................... iii 37
6.3 Basic concepts iii 40
6.3.1  Declarations and definitions 40
6.3.2 One Definition Rule ii snnnen 41
6.3.3  Declarative regions and scope... 44
6.3.4 Name lookup nu 45
6.3.9 Types... iii 46
64 Standard conversions... issues 48
64.5 Integral promotions 48
64.10 Pointer conversions iii 50
vi Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
Co nte nts (continued)

 

 

6.5 Expressions... iii 51
6.5.0 General... isa 51
6.5.2  Postfix expressions... 76
6.5.3  Unary expressions 83
6.5.8 Shift operators... 86
6.5.14  Logical AND operator... nu 86
6.5.17  Assignment operators... 87
6.5.18 Comma operator... issue 87
6.5.19 Constant expressions... 88

6.6  Statements..….................................. issus 89
6.6.2 Expression statement... 89
6.6.3  Compound statement... 90
6.6.4 Selection statements 91
6.6.5  Iteration statements ui 97
6.6.6 Jump statements ii 100

6.7  Declarations iii 104
6.7.1  Specifiers ii iisiisssnicrenesecreenernrnes 104
6.7.2  Enumeration declarations 106
6.7.3  Namespaces 106
6.7.4 The asm declaration iii 111
6.7.5  Linkage specifications…............................................ 112

6.8  Declarators ice 114
6.8.0 General... iii 114
6.8.3  Meaning of declarators.…........................... 115
6.8.4 Function definitions..…............................................... 116
6.85  Initializers..…..................................... ii 118

6.9 Classes ii rrnerrrirnereeerreesneneeeeseeeeeeennn 120
6.9.3 Member functions ire 120
6.9.5 Unions... ii inreeeerrreeereereeereenen 123
6.9.6  Bit-fields.…..................... iii 123

6.10 Derived classes... ire 125
6.10.1 Multiple base classes... 125
6.10.2 Member name lo0kup............................... 126
6.10.3 Virtual functions... is 127

6.11 Member access control... iii 131
6.11.0 General... issues 131

vii Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
Co nte nts (continued)

 

 

6.12 Special member functions...’ 131
6.12.1 Constructors ue 131
6.12.8 Copying class objects... us 134

6.14 Templates... iii 136
6.145 Template declarations 136
6.14.6 Name resolution iii 139
6.147 Template instantiation and specialization..….............................. 141
6.148 Function template specialization 143

6.15 Exception handling 144
6.15.0 General... suis 144
6.15.1 Throwing an exception... 147
6.15.3 Handling an exception... 150
6.15.4 Exception specifications 157
6.15.5 Special functions 157

6.16 Preprocessing directives us 159
6.16.0 General... iii 159
6.16.1 Conditional inclusion 163
6.16.2 Source file inclusion... 164
6.16.3 Macro replacement... 166
6.16.6  Pragma directive... ii 167

6.17 Library introduction... ii 167
6.17.0 General... iii 167

6.18 Language support library... 169
6.18.0 General... iii 169
6.18.2 Implementation properties... 171
6.18.4 Dynamic memory management ..…....................................... 171
6.18.7 Other runtime support ue 172

6.19 Diagnostics library... is 172
6.19.3 Error numbers... iii 172

6.27 Input/output library... iii 173
6.270 General... iii 173

7... References iii 174
Appendix A: Summary of rules... 176
Appendix B: C++ vulnerabilities 190
Appendix C: Glossary... iii 205
viii Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
1. Background

 

1. Background

1.1 The use of C++ in critical systems

The C++ programming language [1] is growing in importance and use for critical systems. This is
due largely to the inherent language flexibility, the extent of support and its potential for portability
across a wide range of hardware. Specific reasons for its use include:

°_ C++ gives good support for the high-speed, low-level, input/output operations, which are
essential to many embedded systems.

*_ The increased complexity of applications makes the use of a high-level language more
appropriate than assembly language.

° C++ compilers can generate code with similar size and RAM requirements to those of C.
+ _ C++ enables object-oriented design methods to be used.

*_ A growth in portability requirements caused by competitive pressures to reduce hardware
costs by porting software to new, and/or lower cost, processors at any stage in a project
lifecycle.

*_ A growth in the use of automatically-generated C++ code from modelling packages.

*_ Increasing interest in open systems and hosted environments for which C++ is a possible
language selection.

12 Language insecurities and the C++ language

No programming language can guarantee that the final executable code will behave exactly as the
programmer intended. There are a number of problems that can arise with any language, and these
are broadly categorized below. Examples are given to illustrate insecurities in the C++ language.

1.2.4 The developer makes mistakes

Developers make errors, which can be as simple as mis-typing a variable name, or might involve
something more complicated such as misunderstanding an algorithm. The programming language
has a bearing on this type of error. Firstly, the style and expressiveness of the language can assist or
hinder the programmer in thinking clearly about the algorithm. Secondly, the language can make
it easy or hard for typing mistakes to turn one valid construct into another valid (but unintended)
construct. Thirdly, the compiler may or may not detect errors when they are made.

Firstly, in terms of style and expressiveness C++ can be used to write well laid out, structured
and expressive code. It can also be used to write perverse and extremely hard-to-understand code.
Clearly the latter is not acceptable in a safety-related system.

Secondly, the syntax of C++ is such that it is relatively easy to make typing mistakes that lead
to perfectly valid code. For example, it is all too easy to type “=” (assignment) instead of “-
(logical comparison) and the result is nearly always valid (but wrong), while an extra semi-colon
on the end of an if statement can completely change the logic of the code.

+

Thirdly, the philosophy of C++ is to assume that the developers know what they are doing, which
can mean that if errors are made they are allowed to pass unnoticed by the compiler. An area in
which C++ is particularly weak (though better than ©) in this respect is that of “type checking”.
C++ will not object, for example, if the programmer tries to store a floating-point number in an

 

1 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
1. Background (continuec)

 

object of type bool. Most such mismatches are simply forced to become compatible. If C++ is
presented with a square peg and a round hole it does not complain, but makes them fit!

1.2.2 The developper misunderstands the language

Developers can misunderstand the effect of constructs in a language. Some languages are more
open to such misunderstandings than others.

There are a number of areas of the C++ language that are prone to developer-introduced errors.
For example, the rules for operator precedence are well defined but complex, and it is easy for a
developer to make incorrect assumptions in an expression.

1.2.3 The compiler does not do what the developer expects

If a language has features that are not completely defined, or are ambiguous, then a developer
can assume one thing about the meaning of a construct, while the compiler may interpret it quite
differently.

There are many areas of the C++ language that are not completely defined, and so behaviour
may vary from one compiler to another. In some cases the behaviour can vary even within a
single compiler, depending on the context. ISO/IEC 14882:2003 [1] contains numerous issues
that may vary in this way. However, it does not list them in the way that the C standard does in its
“Portability issues” annex. To aïd in ensuring coverage of the issues and to allow traceability, they
have been extracted and are shown in Appendix B.

1.2.4 The compiler contains errors

À language compiler (and associated linker etc.) is itself a software tool. Compilers may not
always compile code correctly. They may, for example, not comply with the language standard in
certain situations, or they may simply contain “bugs”.

Because there are aspects of the C++ language that are hard to understand, compiler writers have
been known to misinterpret the standard and implement it incorrectly. Some areas of the language
are more prone to this than others. In addition, compiler writers sometimes consciously choose to
vary from the standard.

1.2.5 Runtime errors

A somewhat different language issue arises with code that has compiled correctly, but due to the
particular data supplied to it, causes errors during the execution of the code. Languages can build
run-time checks into the executable code to detect many such errors and take appropriate action.

C++ is generally poor in providing run-time checking. This is one of the reasons why the code
generated by C++ tends to be small and efficient, but there is a penalty to pay in terms of detecting
errors during execution. C++ compilers generally do not provide run-time checking for such
common problems as arithmetic exceptions (e.s. divide by zero), overflow, validity of addresses
for pointers, or array bound errors.

13 The use of C++ for safety-related systems

It should be clear from Section 1.2 that great care needs to be exercised when using C++ within
safety-related systems. Because of the kinds of issues identified above, various concerns have

 

2 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
1. Background (continuec)

 

been expressed about the use of C++ in safety-related systems. Certainlv, it is clear that the full
C++ language should not be used for programming safety-related systems.

However, in its favour, C++ is mature and consequently well-analysed and tried in practice.
Therefore some of its deficiencies are known and understood. Additionally, there is a large amount
of tool support available commercially which can be used to statically check the C++ source code
and warn the developer of the presence of many of the problematic aspects of the language.

If, for practical reasons, it is necessary to use C++ on a safety-related system, then the use of
the language must be constrained to avoid, as far as is practicable, those aspects of the language
which do give rise to concerns. This document provides one such set of constraints (often referred
to as a “language subset”).

Note that assembly language is no more suitable for safety-related systems than C++ and, in some
respects, is worse. Use of assembly language in safety-related systems is not recommended, and
generally if it is to be used then it needs to be subject to stringent constraints.

1.4 C++ standardization

The standard used for this document is the C++ programming language as defined by ISO/
IEC 14882:2003 [1].

 

3 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
2. The Vision

2. The vision

 

2.1 Rationale for the production of MISRA C++

The MISRA consortium published its Development Guidelines for Vehicle Based Software [2]
in 1994, which describes the full set of measures that should be used in safety-related embedded
software development for vehicle systems. In particular, the choices of language, compiler and
language features to be used, in relationship with safety integrity level (SIL), are recognized to
be of major importance. Section 3.2.4.3 (b) and Table 3 of the MISRA Guidelines [2] address
this. One of the measures recommended is the use of a subset of a standardized language, which
is already established practice in the automotive, aerospace, nuclear and defence industries.
Similarly, other safety-related systems standards require subsets of programming languages in
general (e.g. [12] Part 3 Table A3) even if they do not explicitly require a subset of C++. This
document therefore addresses the definition of a suitable subset of C++.

2.2  Objectives of MISRA C++

In publishing this document regarding the use of the C++ programming language, the MISRA
consortium is not intending to promote the use of C++. Rather, it recognizes the already widespread
use of C++, and this document seeks only to promote the safest possible use of the language.

It is the hope of the MISRA consortium that this document will gain industry acceptance and that
the adoption of a safer subset will become established as best practice by vehicle manufacturers,
component suppliers and other industrial sectors. It should also encourage training and enhance
competence in general C++ programming and in this specific subset, at both an individual level
and a company level.

Great emphasis is placed on the use of static checking tools to enforce compliance with the subset
and it is hoped that this too will become common practice by the developers of critical systems.

Although much has been written about the advantages and disadvantages of various programming
languages, this information is not well-known among developers. This document makes such
information readily available, which should lead to an increase in the awareness of language-
choice issues among engineers and managers.

 

4 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
3. Scope

 

3. Scope

3.1 Base language issues

The MISRA Guidelines [2] (Table 3) and IEC 61508 [12] require that “a restricted subset of a
standardized structured language” be used for critical systems. This means that the language must
only be used as defined in ISO/TIEC 14882:2003 [1], precluding the use of language extensions.

3.2 Issues not addressed

Issues of style and code metrics are somewhat subjective. It would be hard for any group of people to
agree on what was appropriate, and it would be inappropriate for MISRA to give definitive advice. It
is, however, important that suitable style guidelines and appropriate metrics and limits are selected.

The MISRA consortium is not in a position to recommend particular vendors or tools to enforce the
restrictions adopted. The user of this document is free to choose tools, and vendors are encouraged
to provide tools to enforce the rules. The onus is on the user of this document to demonstrate that
their chosen tool set(s) enforces the rules adequately.

3.3  Applicability
This document is designed to be applied to production code in critical systems.

In terms of the implementation defined by ISO/IEC 14882:2003 [1] $1.4(7), this document is
aimed at à freestanding implementation, although it also addresses library issues since standard
libraries will often be supplied with an embedded compiler. The requirements of this document
will not necessarily be applicable in their entirety to a hosted implementation, although many of
the requirements will help create higher quality software in that context.

3.4  Prerequisite knowledge

This document is not intended to be an introduction or training aid to the subjects it embraces. It is
assumed that readers of this document are familiar with the ISO C++ programming language standard
and associated tools, and also have access to the primary reference documents. It also assumes that
developers have received appropriate training and are competent C++ language programmers.

3.5 Library issues
In general, it is preferable that library code should fully satisfy the full set of MISRA C++ Rules.

However, it is recognized that there are situations when this ideal cannot be achieved. In these
cases it may be possible to demonstrate that there is only a small safety risk incurred if deviations
are raised against these rules (e.g. Rule 0-15, Rule 0-1-10, Rule 14-7-1 and Rule 14-72).
In these cases, the deviation raised shall justify that alternative strategies are in place (e.g. by
identifying which library functions are intended to be used and then showing that these, and only
these, have been used).

 

5 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
3. Scope (continued)

 

3.6  Auto-generated code issues

It is recognized that any C++ code produced by an automatic code generation tool introduces
another level of complexity into the software development process. In general, any C++ code
that is produced by such a tool (either automatically by the tool or that is included by the tool but
which is provided by a developer) should fully satisfy the full set of MISRA C++ rules.

However, an automatic code generation tool could potentially detect MISRA C++ violations (e.g.
a missing default clause in a switch statement) and supply code to ensure that the violation is
eliminated. This is considered to be undesirable as the responsibility for ensuring compliance
against MISRA C++ should lie with the developer (for example, could a tool always provide an
appropriate default action?).

MISRA AC INT [3] contains an introduction to the MISRA guidelines for the use of model-based
development and automatic code generation. Note that, at the time of publication of this document,
MISRA AC does not include specific guidance on the use of C++ as a target language.

Additionally, if a code-generating tool is to be used, then it will be necessary to select an appropriate
tool and undertake validation. Apart from suggesting that adherence to the requirements of this
document may provide one criterion for assessing a tool, no further guidance is given on this
matter and the reader is referred to the HSE recommendations for COTS [41].

Automatically-generated code must be treated in the same manner as manually produced code for
the purpose of validation (See MISRA Guidelines [2] $3.1.3, Planning for V&V).

 

6 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
4. Using MISRA C++
4. Using MISRA C++

 

4.1 The software engineering context

Using a programming language to produce source code is only one activity in the software
development process. Adhering to best practice in this one activity is of very limited value if the
other commonly accepted development issues are not addressed. This is especially true for the
production of safety-related systems. These issues are all addressed in the MISRA Guidelines [2]
and, for example, include:

*_ _Documented development process;

°_ Quality system capable of meeting the requirements of ISO 9001/1S0 90003/TickIT [5],
[6], [71;

*_ Project management;

*_ Configuration management;

° Hazard analysis;

+  Requirements;

* Design;

* _ Coding;

* Verification;

° Validation.

It is necessary for the software developers to justify that the whole of their development process is
appropriate for the type of system they are developing. This justification will be incomplete unless
a hazard analysis activity has been performed to determine the SIL allocated to the system.

42 The programming language and coding context

Within the coding phase of the software development process, the language subset is only one
aspect of many and again adhering to best practice in this aspect is of very limited value if the
other issues are not addressed. Key issues, following choice of language, are:

° Training;
+ _ Style guide;
*_ Compiler selection and validation;
*_ Checking tool validation;
+ Metrics;
+ _ Test coverage.
All decisions made on theseissues, including the reasons for those decisions, need to be documented,

and appropriate records should be kept for any activities performed. Such documentation may
then be included in a safety justification, if required.

4.2.1 Training

In order to ensure an appropriate level of skill and competence on the part of those who produce
the C++ source code, formal training should be provided for:

 

7 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
4. Using MISRA C++ (continued)

*_ The use of the C++ programming language for embedded applications;

 

*_ The use of the C++ programming language for high-integrity and safety-related systems;
*_ The use of static checking tools used to enforce adherence to the subset.

4.2.2 Style guide

In addition to adopting the subset, an organization should also have an in-house style guide. This
will contain guidance on issues that do not directly affect the correctness of the code but rather
define a “house style” for the appearance of the source code. These issues are subjective and
typically include:

+ Code layout and use of indenting;

*_ Layout of braces “{ }”° and block structures;

*_ Statement complexity;

*__Naming conventions;

+ _ Use of comments;

*__Inclusion of company name, copyright notice and other standard file header information.

While some of the content of the style guide may only be advisory, some may be mandatory.
However the enforcement of the style guide is outside the scope of this document.

For further information on style guides see [8].

4.2.3 Tool selection and validation

When choosing a compiler (which should be understood to include the linker), an ISO C++
compliant compiler should be used whenever possible. Where the use of the language is reliant on
an implementation-defined feature (as identified in Appendix B) then the developer must benchmark
the compiler to establish that the implementation is as documented by the compiler writer.

When choosing a static checking tool it is clearly desirable that the tool enforces as many of the
rules in this document as possible. To this end it is essential that the tool is capable of performing
checks across the whole program, and not only within a single source file. In addition, where a
checking tool has capabilities to perform checks beyond those required by this document, it is
recommended that the extra checks are used.

The compiler and the static checking tool are generally seen as “trusted” processes. This means
that there is a certain level of reliance on the output of the tools. The developer must therefore
ensure that this trust is not misplaced. Ideally this should be achieved by the tool supplier running
appropriate validation tests. Note that, while it is possible to use a validation suite to test a
compiler for an embedded target, no formal validation scheme exists at the time of publication of
this document. In addition, the tools should have been developed to a quality system capable of
meeting the requirements of ISO 9001/1S0 90003 [5], [6], [71.

It should be possible for the tool supplier to show records of verification and validation activities
together with change records that show a controlled development of the software. The tool supplier
should have à mechanism for:

*_ Recording faults reported by the users;
*_ Notifying existing users of known faults;
*_ Correcting faults in future releases.

 

8 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
4. Using MISRA C++ (continued)

The size of the existing user base together with an inspection of the faults reported over the
previous 6 to 12 months will give an indication of the stability of the tool.

 

It is often not possible to obtain this level of assurance from tool suppliers, and in these cases the
onus is on the developer to ensure that the tools are of adequate quality.

Some possible approaches the developer could adopt to gain confidence in the tools are:
*__ Perform some form of documented validation testing;
*_ Assess the software development process of the tool supplier;
*_ Review the performance of the tool to date.

The validation test could be performed by creating code examples to exercise the tools. For
compilers this could consist of known good code from a previous application. For a static checking
tool, a set of code files should be written, each breaking one rule in the subset and together covering
as many as possible of the rules. For each test file the static checking tool should then find the
non-conformant code. Although such tests would necessarily be limited, they would establish a
basic level of tool performance.

It should be noted that validation testing of the compiler must be performed for the same set of compiler
options, linker options and source library versions used when compiling the product code.

The use of additional static analysis checks, where available, is also recommended.

4.2.4 Source complexity metrics

The use of source code complexity metrics is highly recommended. These can be used to prevent
unwieldy and un-testable code being written by looking for values outside of established norms.
The use of tools to collect the data is also highly recommended. Many of the static checking tools
that may be used to enforce the subset also have the capability for producing metrics data.

For details of possible source code metrics see “Software Metrics: À Rigorous and Practical
Approach” by Fenton and Pfleeger [9] and the MISRA report on Software Metrics [10].

4.2.5 Test coverage

The expected statement coverage of the software should be defined before the software is designed
and written. Code should be designed and written in a manner that supports high statement
coverage during testing. The term “Design For Test” (DFT) has been applied to this concept in
mechanical, electrical and electronic engineering. This issue needs to be considered during the
activity of writing the code, since the ability to achieve high statement coverage is an emergent
property of the source code.

Use of a subset, which reduces the number of implementation-dependent features and increases
the rigour of module interface compatibility, can lead to software that can be integrated and tested
with greater ease.

Balancing the following metrics can facilitate achieving high statement coverage:
+ _ Code size;

*_ Cyclomatic complexity.

With a planned approach, the extra effort expended on software design, language use and design
for test is more than offset by the reduction in the time required to achieve high statement coverage
during test. See [10], [11].

 

9 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
4. Using MISRA C++ (continued)
4.3  Adopting the subset

In order to develop code that adheres to the subset the following steps need to be taken:

 

*_ Produce a compliance matrix which states how each rule is enforced;
*_ Produce a deviation procedure;
*_ Formalize the working practices within the quality management system.

4.31 Compliance matrix

In order to ensure that the source code written does conform to the subset it is necessary to have
measures in place that check that none of the rules have been broken. The most effective means
of achieving this is to use one or more of the static checking tools that are available commercially.
Where a rule cannot be checked by a tool, then a manual review will be required.

In order to ensure that all the rules have been covered then a compliance matrix should be produced
which lists each rule and indicates how it is to be checked. See Table 1 for an example, and see
Appendix À for a summary list of the rules, which could be used to assist in generating a full
compliance matrix.

 

Rule No. Compiler 1 Compiler 2 Checking Tool 1 Checking Tool 2 | Manual Review
Rule 0-1-1 warning 347
Rule 0-1-2 error 25
Rule 0-1-3 message 38
Rule 0-1-4 warning 97
Rule 0-1-5 Proc x.y

 

 

 

 

 

 

 

 

 

 

 

 

 

Table 1: Example compliance matrix

If the developer has additional local restrictions, these too can be added to the compliance matrix.
Where specific restrictions are omitted, full justifications shall be given. These justifications must
be fully supported by a C++ language expert together with manager level concurrence.

4.3.2  Deviation procedure

It is recognized that in some instances it may be necessary to deviate from the rules given in this
document. For example, source code written to interface with the microprocessor hardware will
inevitably require the use of proprietary extensions to the language.

In order for the rules to have authority, it is necessary that a formal procedure be used to authorize
these deviations rather than an individual programmer having discretion to deviate at will. It is
expected that the procedure will be based around obtaining a sign-off for each deviation, or class
of deviation. The use of a deviation must be justified on the basis of both necessity and safety.
While this document does not give, nor intend to implvy, any grading of importance of each of the
rules, it 1s accepted that some provisions are more critical than others. This should be reflected
in the deviation procedure, where for more serious deviations greater technical competence is
required to assess the risk incurred and higher levels of management are required to accept this
increased risk. Where a formal quality management system exists, the deviation procedure should
be a part of this system.

 

10 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
4. Using MISRA C++ (continued)

Deviations may occur for a specific instance, 1.e. a one-off occurrence in a single file, or for a class
of circumstances, 1.e. a systematic use of a particular construct in a particular circumstance, for
example the use of a particular language extension to implement an input/output operation in files
that handle serial communications.

 

Strict adherence to all rules is unlikely and, in practice, deviations associated with individual
situations, are admissible. There are two categories of deviation.

*_ Project Deviation: A Project Deviation is defined as a permitted relaxation of rule
requirements to be applied in specified circumstances. In practice, Project Deviations will
usually be agreed at the start of a project.

*_ Specific Deviation: À Specific Deviation will be defined for a specific instance of a rule
violation in a single file and will typically be raised in response to circumstances that arise
during the development process.

Project deviations should be reviewed regularly and this review should be a part of the formal
deviation process.

Manwv, if not most, of the circumstances where rules need to be broken are concerned with input/
output operations. It is recommended that the software be designed such that input/output concerns
are separated from the other parts of the software. As far as possible Project Deviations should
then be restricted to this input/output section of the code. Code subject to Project Deviations
should be clearly marked as such.

The purpose of this document is to avoid problems by thinking carefully about the issues and
taking all responsible measures to avoid the problems. The deviation procedure should not be
used to undermine this intention. In following the rules in this document the developer is taking
advantage of the effort expended by MISRA in understanding these issues. If the rules are to be
deviated from, then the developer is obliged to understand the issues for themselves. AII deviations,
standing and specific, should be documented.

For example, if it 1s known beforehand that it will be difficult to adhere to a rule, the software
developer should submit a written Project Deviation Request and agreement with the customer
should be obtained prior to programming.

A Project Deviation Request should include the following:
+ Details of the deviation, i.e. the rule that is being violated;
+ _ Circumstances in which the need for the deviation arises;
*__ Potential consequences which may result from the deviation:;
*_ Justification for the deviation;
*_ A demonstration of how safety is assured.
When the need for a deviation arises during or at the end of the development process, the software
developer should submit a written Specific Deviation Request.
A Specific Deviation Request should include the following:
+ Details of the deviation, i.e. the rule that is being violated;
*__ Potential consequences which may result from the deviation:;
*_ Justification for the deviation;
*_ A demonstration of how safety is assured.

Detailed implementation of these procedures is left to the discretion of the user.

 

11 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
4. Using MISRA C++ (continued)

4.3.3 Formalization within quality system

The use of the subset, the static checking tools and deviation procedure should be described by
formal documents within the quality management system. They will then be subject to the internal
and external audits associated with the quality system and this will help ensure their consistent use.

 

4.3.4 Introducing the subset

Where an organization has an established C++ coding environment it is recommended that the
requirements of this document be introduced in a progressive manner. It may take 1 to 2 years to
implement all aspects of this document.

Where a product contains legacy code written prior to the use of the subset, it may be impractical
to rewrite it to bring it into conformance with the subset. In these circumstances the developer
must decide upon a strategy for managing the introduction of the subset (for example: all new
modules will be written to the subset and existing modules will be rewritten to the subset if they
are subject to a change which involves more than 30% of the non-comment source lines).

4.4  Claiming compliance
Compliance can only be claimed for a product and not for an organization.
When claiming MISRA C++ compliance for a product, a developer is stating that evidence exists
to show:
* A compliance matrix has been completed which shows how compliance has been
enforced;

* _ Allof the C++ code in the product is compliant with the rules of this document or subject
to documented deviations;

* A list of all instances of rules not being followed is being maintained, and for each
instance there is an appropriately signed-off deviation;

+ _ The issues mentioned in Section 4.2 have been addressed.

4.5  Continuous improvement

Adherence to the requirements of this document should only be considered as a first step in a
process of continuous improvement. Users should be aware of the other literature on the subject
(see references) and actively seek to improve their development process by the use of metrics.

 

12 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
5. Introduction to the rules

 

5, Introduction to the rules

This section explains the presentation of the language guidelines (the rules) given in this part of
the document. It serves as an introduction to the main content of the document as presented in that
section.

5.1 Rule classification

Every rule is classified as “Required”, “Advisory” or “Document”, as described below. Beyond this
basic classification the document does not give, nor intend to imply, any grading of importance of
each of the rules. AIT “Required” rules should be considered to be of equal importance, as should
all “Advisory”, and all “Document” rules. The omission of an item from this document does not
imply that it is less important. Furthermore for projects following a safety standard that uses SIL
or a similar measure of risk reduction requirements, all rules are intended to be applied regardless
of the SIL claimed for the software being developed.

The meanings of “Required”, “Advisory” and “Document” rules are as follows.

5.14 Required rules

These are mandatory requirements placed on the developer. C++ code that is claimed to conform
to MISRA C++ shall comply with every “Required” rule. Formal deviations must be raised where
this is not the case.

51.2 Advisory rules

These are requirements placed on the developer that should normally be followed. However they
do not have the mandatory status of “Required” rules. Note that the status of “Advisory” does
not mean that these items can be ignored, but that they should be followed as far as is reasonably
practical. Formal deviations are not necessary for “Advisory” rules, but may be raised if it is
considered appropriate.

5.1.3 Document rules

These are mandatory requirements placed on the developer whenever the associated feature is
used within code. Deviations are not permitted against this class of rule.

5.2 Organization of rules

The rules are organized under the section numbers of ISO/IEC 14882:2003 [1]. However there is
inevitably overlap, with one rule possibly being relevant to a number of topics. Where this is the
case, the rule has been placed under the first relevant topic.

5.3  Exceptions to the rules

Some rules contain an “Exception” section that lists one or more exceptional conditions under
which the rule need not be followed. These exceptions effectively modify the headline rule.

 

13 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
5. Introduction to the rules (continued)

 

5.4  Redundancy in the rules

There are a few cases within this document where a rule is given that refers to a language feature,
which is banned or advised against elsewhere in the document. This is intentional. It may be that
the developer chooses to use that feature, either by raising a deviation against a “Required” rule,
or by choosing not to follow an “Advisory” rule. In this case, the second rule, constraining the use
of that feature, becomes relevant.

5.5 Presentation of rules

The individual Rules are presented in the following format:

 

| Rule <number>  (<category>) <headline text> |

 

[<issue reference>]
<normative text>
Where the fields are as follows:

*_ <number> Every rule has a unique number, consisting of three parts, aa-bb—cc.
aa-bb gives the section number within ISO/IEC 14882:2003 [1] to which the rule relates.
Note, because guidance is not given for every section in ISO/IEC 14882:2003 [1], the
numbering of the designators aa-bb and hence of the section headings in this document are
not contiguous.

ec is a sequence number for rules related to the above section.

Note that section 0-bb contains general guidance that does not relate to any specific area
within the standard.

Sections of the form aa-0 give guidance that relates to section aa of the standard, but which
is not directly attributable to any particular language construct within that section.

*_ <category> is one of “Required”, “Advisory” or “Document”, as explained above.

*_ <headline text> is the rule itself.

*  <issue reference> indicates the section and paragraph number within
ISO/TEC 14882:2003 [1] of a specific language issue which is targeted by the rule. An
explanation of these issues is given below.

Normative text is provided for each rule. This text gives, where appropriate, some explanation of
the underlying issues being addressed by the rule, and examples of how to apply the rule.

The normative text is not intended as a tutorial in the relevant language feature, as the reader
is assumed to have a working knowledge of the language. Further information on the language
features can be obtained by consulting the relevant section of the language standard or other C++
language reference books. Where an Issue Reference is given, then the original issue raised in
ISO/IEC 14882:2003 [1] may provide additional help in understanding the rule.

Within the rules and their supporting text the following font styles are used to represent C++
keywords and C++ code:
C++ keywords appear in italic text

C++ code appears in a mono-spaced font, either within other text or as

separate code fragments;

 

14 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
5. Introduction to the rules (continued)

 

Note that where code is quoted, the fragments may be incomplete (for example an if statement
without its body). This is for the sake of brevity.

In code fragments, in order to comply with Rule 3-9-2, the following fypedef d types have been
assumed:

char t // plain 8 bit character
uint8 € // unsigned 8 bit integer
uint16 E // unsigned 16 bit integer
uint32 € // unsigned 32 bit integer
int8 t // signed 8 bit integer
int16 t // signed 16 bit integer
int32 t // signed 32 bit integer

float32 t // 32 bit floating-point
float64 t // 64 bit floating-point

Note that the boo1 andwchar + types do not have fypedefs.
Non-specific variable names are constructed to give an indication of the type. For example:

uint8 € usa;
int32 € s32a;

5.6  Understanding the issue references

Where a rule is aimed at a specific issue within ISO/IEC 14882:2003 [1], then a reference to
the standard is indicated in square brackets after the rule. This serves two purposes. Firstly, a
reader may wish to gain a fuller understanding of the rationale behind the rule (for example
when considering a request for a deviation) by consulting the standard. Secondly, this gives extra
information about the nature of the problem.

Rules that do not have an Issue Reference may have originated from a contributing company’s in-
house standard, or have been suggested by a reviewer, or be widely accepted “good practice”.

A key to the references, and advice on interpreting them, is given below.

Key to the source references

 

 

 

 

 

 

 

Reference Source

Unspecified Unspecified behaviour detailed within the C++ standard

Undefined Undefined behaviour detailed within the C++ standard

Indeterminate Undefined behaviour that arises due to an omission in the C++ standard
of an explicit definition of behaviour

Implementation Implementation-defined behaviour detailed within the C++ standard

NDR Behaviour within the C++ standard for which no diagnostic is required

IEC 61508 IEC 61508:1998-2000 [12]

 

 

 

 

Where numbers follow the reference, they have the following meanings:

*_ For language issues, the section and paragraph number (if appropriate) of the relevant part
of the standard are given, i.e. 1.2(3) would indicate Section 1.2, Paragraph 3.

* In other references, the relevant section number is given (unless stated otherwise).

 

15 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
5. Introduction to the rules (continued)

 

Issue references

Where a rule is based on issues within ISO/IEC 14882:2003 [1], it is helpful for the reader to
understandthedistinctionbetween“Unspecified”, “Undefined” ,“Indeterminate” ,“Implementation-
Defined” and “NDR” issues.

Unspecified

These are language constructs that must compile successfully, but in which the compiler writer
has some freedom as to what the construct does. “Order of evaluation” is an example of this.

It is unwise to place any reliance on the compiler behaving in a particular way. The compiler need
not even behave consistently across all uses of a construct.

Undefined

These are essentially programming errors for which the compiler is not obliged to issue a diagnostic
(error message). Examples are invalid escape sequences or attempting to modify a string literal.

These are particularly important from a safety point of view, as they represent programming errors
that may not necessarily be trapped by the compiler.

Indeterminate

This is similar to “Undefined”, but where ISO/TEC 14882:2003 [1] omits an explicit definition of
behaviour.

Implementation-defined

These are similar to the “Unspecified” issues, the main difference being that the compiler writer
must take a consistent approach and document it. In other words, the functionality can vary from
one compiler to another, making code non-portable, but on any one compiler the behaviour should
be well defined. An example of this 1s the behaviour of the integer division and remainder operators
“7? and “+” when applied to one positive and one negative integer.

These tend to be less critical from a safety point of view, provided the compiler writer has fully
documented their approach and then implemented it consistently. It is advisable to avoid these
issues where possible.

NDR

“No diagnostic required” (NDR) conditions are those that may lead to program errors, but for
which the complier is not required to issue a diagnostic (error message).

5.7 Scope of rules

While the majority of rules can be applied within a single translation unit, all rules shall be applied
with the widest possible interpretation.

In general, the intent is that all the rules shall be applied to templates. However, some rules are
only meaningful for instantiated templates.

Unless otherwise specified, all rules shall apply to implicitly-declared or implicitly-defined special
member functions (e.g. default constructor, copy constructor, copy assignment operator and
destructor).

 

16 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules
6. Rules

Appendix € contains a glossary of terms that are used in the formation of the rules that are
presented within this section.

6.0 Language independent issues
6.0.1 Unnecessary constructs

 

An unnecessary construct by itself is benign and therefore leads to no faults, but it is a defect.
However, it is possible that these defects may be due to errors and hence they may be coupled to,
or indicate faults. The following rules address the need to reduce the number of these defects.

The attempt to remove all such constructs may reveal the underlying fault if one is present. The
absence of such constructs leads to code that is more readable, faster executing and more easily
maintained. In addition, software analysis tools can produce more accurate results. The presence
of infeasible code, for example, may lead to false positive and false negative messages from static
analysis tools. In dynamic analysis, it prevents the achievement of required coverage metrics.
Readability is impaired, as also is maintainability.

 

Rule 0-1-1 (Required) A project shall not contain #nreachable code.

 

Rationale

Code is unreachable if there is no syntactic (control flow) path to it. If such code exists, it is
unclear if this is intentional or simply that an appropriate path has been accidentally omitted.

Compilers may choose not to generate code for these constructs, meaning that, even if the
unreachable code is intentional, it may not be present in the final executable code.

Missing statements, often caused by editing activities, are a common source of unreachable code.

Example

int16 t with unreach ( int16 t para )
{

int16 t local;

local = 0;

switch ( para )

{
local = para; // unreachable - Non-compliant

case 1:

{

break;

}

default:
{

break;

}
}

return para;
para++; // unreachable - Non-compliant

 

17 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules

 

 

| Rule 0-1-2 (Required) A project shall not contain infeasible paths.

 

Rationale

Infeasible paths occur where there is a syntactic path but the semantics ensure that the control
flow path cannot be executed by any input data. One of the major problems here is the explosion
of infeasible paths caused by:

* if. else statement sequences;
*__Sequences of poorly chosen loop constructs

Errors in conditions and poorly designed logic contribute to this problem. It is always possible to
rewrite the code to eliminate these constructs. This process may then reveal faults.

There is the possibility that protective coding techniques generate infeasible code. This code is
usually executable (and hence feasible) in a unit testing environment.

Example

void infeas ( uint8 € para, uint8 € outp )
{

// The condition below will always be true hence the path
// for the false condition is infeasible. Non-compliant.
if ( para >= OÙ )

outp = 1U;

// The following if statement combines with the if

// statement above to qive four paths. One from

// the first condition is already infeasible and

// the condition below combined with assignment above

// makes the false branch infeasible. There is therefore
// only one feasible path through this code.

if ( outp == 1Ù )

outp = OU;

}
enum ec { RED, BLUE, GREEN } col;

1f { col <= GREEN ) // Non-compliant - always true
{
// Will always get here
}
else
{
// Will never get here
}

// The following ifs exhibit similar behaviour.
// Note that ul6a is a 16-bit unsigned integer
// and s8a is an 8-bit signed integer.

 

if { ul6a < OÙ ) // Non-compliant - u16a is always >= 0
1f { ul6a <= Oxf£CLEU ) // Non-compliant - always true
18 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

1f { 5s8a < 130 ) // Non-compliant - always true
11 { { 5s8a < 10 ) && { 58a > 20 ) ) // Non-compliant - always false
1f { { 5s8a < 10 ) || { s8a > 5 } ) // Non-compliant - always true

// Nested conditions can also cause problems
if ( s8a > 10
{
if ( s8a > 5 ) // Non-compliant, unless s8a volatile

{
// Will always get here.

 

Rule 0-1-3 (Required) A project shall not contain #nused variables.

 

Rationale

Variables declared and never used in a project constitute noise and may indicate that the wrong
variable name has been used somewhere. Removing these declarations reduces the possibility that

they may later be used instead of the correct variable.

If padding is used within bit-fields, then the padding member should be unnamed to avoid violation

of this rule.

Example
extern void usefn ( int16 t a, int16 t b );

class C

{

};
C ce: // Non-compliant - unused

void withunusedvar ( void )

{

int16 t unusedvar; // Non-compliant - unused

struct s tag

{

 

signed int a : 3;
signed int pad : 1; // Non-compliant - should be unnamed
signed int b : 2;

} s var;

s var.a = 0;

s var.b = 0;

usefn ( s var.a, s var.b );

}
Rule 0-1-4 (Required) A project shall not contain non-volatile POD variables

 

having only one use.

 

 

Rationale

With the exception of volatile variables, variables declared and used only once do not contribute
to program computations. À use is either an assignment (explicit initialization) or a reference.

 

19 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

These variables are essentially noise but their presence may indicate that the wrong variable has
been used elsewhere. Missing statements contribute to this problem.

Example
const int16 t x = 19; // Compliant
const int16 t y = 21; // Non-compliant
void usedonlyonce ( void )
{
int16 t once 1 = 42; // Non-compliant

int16 t once 2;

once 2 = x ; // Non-compliant

}
Note that x is compliant as there are two uses, firstly when initialized and secondly when assigned

to once 2.

 

Rule 0-1-5 (Required) A project shall not contain #nused type declarations.

 

Rationale

If a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has
been left unused by mistake.

See Section 3.5 for associated library issues.

Example

int16 t unusedtype ()

{
typedef int16 t local Type; // Non-compliant

return 67;

 

Rule 0-1-6 (Required) A project shall not contain instances of non-
volatile variables being given values that are never
subsequently used.

 

 

 

Rationale

Technically known as a DU dataflow anomaly, this is a process whereby à variable is given a value
that is subsequently never used. At best this is inefficient, but may indicate a genuine problem. Often
the presence of these constructs is due to the wrong choice of statement aggregates such as loops.

Exception

Loop control variables (see Section 6.6.5) are exempt from this rule.

Example
int16 t critical ( int16 € i, int16 € j )
{
int16 t result =
inti6 t k = (3*i) + (5 * 3);

|
©
s.

 

20 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

// Should k be checked here?
if (£2 ( ) )
{
// k will only be tested here if f2 returns true
// Initialization of k could be moved here
if {k > 0 )
{
throw ( 42 ):

}

// Non-compliant - value of k not used if f2 ( ) returns false
return ( result );
}
void unusedvalue ( int16 € arr[ 20 ] )
{
int16 € j;
ji = 2;

for ( inti6t i = 1; i < 10; i++ )
{

arr[ i ] = arr[ 3j ];
++; // Non-compliant - the value assigned to j
} // on the final loop is never used.
}
void nounusedvalue ( int16 € arr[ 20 ] )

{
for ( inti6t i = 1; i < 10; i++ )
{

arr[ i ] = arr[ i +2 ];

 

Rule 0-1-7 (Required) The value returned by a function having a non-void
return type that is not an overloaded operator shall
always be used.

 

 

 

Rationale

In C++ it is possible to call a function without sing the return value, which may be an error. The
return value of a function shall always be used.

Overloaded operators are excluded, as they should behave in the same way as built-in operators.

Exception

The return value of a function may be discarded by use of a (void) cast.

Example

uint16 € func ( uint16 t paral )
{

return paral;

 

21 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

void discarded ( uint16 t para2 )
{

 

 

func ( para? }); // value discarded - Non-compliant
(void)func ( para2 ); // Compliant
}
See also
Rule 5-24
Rule 0-1-8 (Required) AII functions with void return type shall have external
side effect(s).
Rationale

A function which does not return a value and which does not have external side effects will only
consume time and will not contribute to the generation of any outputs, which may not meet
developer expectations.

The following are examples of external side effects:
*_ Reading or writing to a file, stream, etc.;
°_ Changing the value of a non local variable;
°_ Changing the value of an argument having reference type;
*_ Using a volatile object;
+ Raising an exception.

Example

void pointless ( void ) // Non-compliant - no external side effects

{
int16 t local;

 

 

local = 0;
}
| Rule 0-1-9 (Required) There shall be no dead code.
Rationale

Any executed statement whose removal would not affect program output constitutes dead code
(also Know as redundant code). It is unclear to a reviewer if this is intentional or has occurred due
to an error.

Example

int16 t has dead code ( int16 € para )

{
int16 t local = 99;

para = para + local;
local = para; // dead code - Non-compliant

 

22 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

1f ( O == local ) // dead code - Non-compliant
{ // dead code - Non-compliant

local++; // dead code - Non-compliant
} // dead code - Non-compliant

return para;

 

Rule 0-1-10 (Required) Every defined function shall be called at least once.

 

Rationale

Functions or procedures that are not called may be symptomatic of a serious problem, such as
missing paths.

Note that an unused prototype is not a violation of this rule.

See Section 3.5 for associated library issues.

Example
void £1 ( )
{
}
void £2 ( ) // Non-compliant
{
}
void £3 ( ): // Compliant prototype

int32 t main ()

{

 

 

 

 

ÊT Co);
return ( © );
}
Rule 0-1-11 (Required) There shall be no #rused parameters (named or
unnamed) in non-virtual functions.
Rationale

Unused function parameters are often due to design changes and can lead to mismatched parameter
lists.

Exception

An unnamed parameter in the definition of a function that is used as a callback does not violate
this rule.

Example
typedef int16 € ( * CallbackFn )( int16 € a, int16 t b );
int16 t Callback 1 ( int16 t a, inti6 t b ) // Compliant

{

return a + b;

}

 

23 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

int16 t Callback 2
{
return a;

}

int16 t Callback 3
{

return b;

}

void Dispatch ( inti6 tn,
inti6 t a,
int16 t D,
inti6 t c,

inti6 t )

CallbackFn pFn;

( int16 t a, inti6 t b)

(inti6 t, intl6 t b )

// Non-compliant

// Compliant by exception

// Non-compliant
// Non-compliant if Dispatch not a callback.

 

 

 

 

 

switch ( n )
{
case O0: pFn = &Callback 1; break;
case 1: pin &Callback 2; break;
default: pFn = &Callback 3; break;
}
( *pEn )( a, b );
}
See also
Rule 0-1-12
Rule 0-1-12 (Required) There shall be no #rused parameters (named or
unnamed) in the set of parameters for a virtual function
and all the functions that override it.
Rationale
Unused function parameters are often due to design changes and can lead to mismatched parameter
lists.
Example
class A
{
public:
virtual void withunusedpara ( uint16 € * paral,
int16 t unusedpara } = 0;
virtual void withoutunusedpara ( uint16 t * paral,
int16 t & para2 ) = 0;
};
24 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

class Bl: public A
{

public:
virtual void withunusedpara ( uint16 Et * paral,
int16 € unusedpara )
{
*paral = 1U;
}
virtual void withoutunusedpara ( uint16 t * paral,

int16 t & para? )

{
*paral = 1U;

};
class B2: public A
{

public:
virtual void withunusedpara ( uint16 Et * paral,
int16 € unusedpara )
{
*paral = 1U;
}
virtual void withoutunusedpara ( uint16 t * paral,

int16 t & para? )

{
para2 = 0;

};
See also
Rule 0-1-11

6.0.2 Storage

 

Rule 0-2-1 (Required) An object shall not be assigned to an overlapping
object.

 

 

 

[Undefined 5.17(8)]

Rationale
Assigning between objects that have an overlap in their physical storage leads to undefined
behaviour.

 

25 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

struct s

{

int16 t mi | 32 ];
};
struct t

{
int32 € m2;
struct s m3;
};
void fn { )

{
union // Breaks Rule 9-5-1

{
struct s ul;
struct € u2;
} a;

a.u2.m3 = a.ul; // Non-compliant

}
See also
Rule 9-5-1

6.0.3 Runtime failures

 

Rule 0-3-1 (Document) Minimization of run-time failures shall be ensured by
the use of at least one of:
(a) static analysis tools/techniques;
(b) dynamic analysis tools/techniques;
(c) explicit coding of checks to handle run-time faults.

 

 

 

Rationale

Run-time checking is an issue (not specific to C++) to which developers need to pay special
attention, especially as the C++ language is weak in its provision of any run-time checking. C++
implementations are not required to perform many of the dynamic checks that are necessary for
robust software. It is therefore an issue that C++ developers need to consider carefully, adding
dynamic checks to code wherever there is the potential for run-time errors to occur.

Where expressions consist only of values within a well-defined range, a run-time check may
not be necessary, provided it can be demonstrated that for all values within the defined range
the exception cannot occur. Such a demonstration, if used, should be documented along with
the assumptions on which it depends. However, if adopting this approach, be very careful about
subsequent modifications of the code that may invalidate the assumptions, or of the assumptions
changing for any other reason.

The following notes give some guidance on areas where consideration needs to be given to the
provision of dynamic checks.

 

26 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Rules (continued)

 

arithmetic errors

This includes errors occurring in the evaluation of expressions, such as overflow, underflow,
division by zero or loss of significant bits through shifting.

In considering integer overflow, note that unsigned integer calculations do not strictly
overflow (producing undefined values), but the values wrap around (producing defined, but
possibly unexpected, values).

pointer arithmetic

Ensure that when an address is calculated dynamically the computed address is reasonable
and points somewhere meaningful. In particular it should be ensured that if a pointer points
within a structure or array, then when the pointer has been incremented or otherwise altered
it still points to the same structure or array. See Rule 50-15, Rule 5-0-16, Rule 50-17
and Rule 5-0-18 for restrictions on pointer arithmetic.

array bound errors

Ensure that array indices are within the bounds of the array size before using them to index
the array.

function arguments
Function arguments should be validated.

pointer dereferencing

Where a function returns a pointer and that pointer is subsequently de-referenced the
program should first check that the pointer is not NULL. Within a function, it is relatively
straightforward to reason about which pointers may or may not hold NUZZ values. Across
function boundaries, especially when calling functions defined in other source files or
hbraries, it is much more difficult.

// Given a pointer to à message, check the message header and return
// a pointer to the body of the message or NULL if the message is
// invalid.
const char t *msg body ( const char t * msg )
{
const char t * body = NULL;

if ( msg != NULL )
{
if ( msg header valid ( msg ) )
{
body = é&msg [ MSG HEADER SIZE ];

}
}
return ( body );

}

char t msg buffer [ MAX MSG SIZE ];
const char t * payload;

payload = msg body ( msg buffer );
if ( payload != NULL )
{

// process the message payload
}

 

27 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

The techniques that will be employed to minimize run-time failures should be planned and
documented, e.g. in design standards, test plans, static analysis configuration files, code review
checklists.

 

Rule 0-3-2 (Required) If a function generates error information, then that
error information shall be tested.

 

 

 

Rationale

A function (whether it is part of the standard library, a third party library or a user defined function)
may provide some means of indicating the occurrence of an error. This may be via a global
error flag, a parametric error flag, a special return value or some other means. Whenever such a
mechanism is provided by a function the calling program shall check for the indication of an error
as soon as the function returns.

Note, however, that the checking of input values to functions is considered a more robust means
of error prevention than trying to detect errors after the function has completed.

Example
extern void fn3 ( int32 t i, bool & flag );

int32 + fnl (int32 ti)
{

int32 t result = 0;
bool success = false};
fn3 ( i, success ) // Non-compliant - success not checked

return result:
}
int32 t fn2 ( int32 t i )
{

int32 t result = 0;
bool success = false};
fn3 ( i, success ):; // Compliant - success checked
1f ( lsuccess )
{
throw 42;

}

return result:

See also
Rule 19-3-1

 

28 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.0.4  Arithmetic

 

Rule 0-4-1 (Document) Use of scaled-integer or fixed-point arithmetic shall be
documented.

 

 

 

Rationale

It is extremely difficult to design and implement arithmetic packages for scaled-integer or fixed-
point arithmetic without overlooking dangerous cases.

If either is used, then this rule requires that documentation be produced to demonstrate that all the
issues have been covered by the implementation.

 

Rule 0-4-2 (Document) Use of floating-point arithmetic shall be documented.

 

Rationale

The safe use of floating-point arithmetic requires a high level of numerical analysis skills and in-
depth knowledge of the compiler and target hardware.

If floating-point is to be used, then the following issues need to be covered as part of the deviation
Process:

*_ A justification explaining why floating-point is the appropriate or only solution.

*_ _Demonstrate that appropriate skills are available.

*_ Demonstrate that an appropriate process is being applied.

*_ Document the floating-point implementation.

The paper “What Every Computer Scientist Should Know about Floating-Point Arithmetic” [13]
explains the issues that need to be considered when using floating-point.

Example

When solving a quadratic equation, the value of h?-4.a.c is calculated. Assume that a—7.22,
b=3.34, c—2.28 and that three significant digits are used during calculation. The exact value of
b?4.a.c is 0.0292. However, b? rounds to 77.2 and 4.a.c rounds to 77.1, giving a final answer
of 0.1. This example demonstrates catastrophic cancellation. The subtraction does not cause an
error, but it does expose errors introduced in the multiplications that are used when generating its
operands.

 

Rule 0-4-3 (Document) Floating-point implementations shall comply with a
defined floating-point standard.

 

 

 

Rationale

Floating-point arithmetic has a range of problems associated with it. Some of these can be
overcome by using an implementation that conforms to a recognized standard. An example of an
appropriate standard is ANST/IEEE Std 754 [14].

The definition of the floating-point types, in accordance with Rule 3-9-2, provides an opportunity
for noting the floating-point standard in use, for example:

 

29 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

/J IEEE 754 Single-precision floating-point
typedef float float32 t;

6.1 General
61.0 Language

 

Rule 1-0-1 (Required) AII code shall conform to ISO/IEC 14882:2003
“The C++ Standard Incorporating Technical
Corrigendum 1”.

 

 

 

[MISRA Guidelines Table 3; IEC 61508 Part 7: Table C.1]
Rationale

The MISRA C++ subset is based on ISO/IEC 14882:2003 [1]. No claim is made as to their
suitability with respect to any other version of the standard. Any reference in this document to
“C++” refers to the ISO/IEC 14882:2003 [1] standard.

It is recognized that it will be necessary to raise deviations (as described in Section 4.3.2) to
permit certain language extensions, for example to support hardware specific features.

Deviations are required if the environmental limits, as specified in Annex B of
ISO/IEC 14882:2003 [1], are exceeded.

 

Rule 1-0-2 (Document) Multiple compilers shall only be used if they have a
common, defined interface.

 

 

 

[Implementation 7.5(1, 2, 9)]
Rationale
“Multiple compilers” includes:
* Mixed languages;
*_ Different compilers;
*_ Different versions of the same compiler;
*_ Different configurations of the same compiler;

where “compiler” includes any tool used to translate source code or link object code.

If a module is to be implemented in a language other than C++, or compiled using a different
C++ compiler, then it is essential to ensure that the module will integrate correctly with other
modules. Some aspects of the behaviour of the C++ language are implementation-defined, and
therefore these must be understood for the compiler being used. Examples of issues that need to
be understood include:

*_ Stack usage;

*_ Parameter passing;

*_ The way in which data values are stored (lengths, alignments, aliasing, overlays etc.).

Note that this includes the use of extern "C".

 

30 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 1—0-3 (Document) The implementation of integer division in the chosen
compiler shall be determined and documented.

 

 

 

[Implementation 5.6(4)]
Rationale

An ISO compliant compiler can do one of two things when dividing two signed integers,
one of which is positive and one negative. Firstly, it may round up with a negative remainder
(e.g. -5/3 = -1 remainder -2) or, secondly, it may round down with a positive remainder
(e.g. -5/3 = -2 remainder +1).

It is important to determine which of these is implemented by the compiler and to document it for
developers.

Note that this rule also covers modulus as it is defined in terms of division.

6.2 Lexical conventions
6.2.2 Character sets

 

Rule 2-2-1 (Document) The character set and the corresponding encoding shall
be documented.

 

 

 

Rationale

The source code is written in one or more character sets. Optionally, the program can execute in a
further or multiple character sets. AIL the character sets that are used shall be documented.

Documenting the character sets that are used increases developer awareness, preventing issues
arising due to the use of incompatible character sets.

For example, ISO 10646-1 [15] defines an international standard for mapping character sets
to numeric values. For portability, character-constants and string-literals should only contain
characters that map to a documented subset.

6.2.3 Trigraph sequences

 

| Rule 2-3-1 (Required) Trigraphs shall not be used.

 

Rationale

Trigraphs are denoted by a sequence of 2 question marks followed by a specified third character
(e.g. ??- represents a “-” (tilde) character and ??) represents a “1””). They can cause accidental
confusion with other uses of two question marks.

CEE
]

Example
The string

"(Date should be in the form ??-?77-92)"

would probably not meet developer expectations, since the compiler would interpret it as
"{Date should be in the form --]"

 

31 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.2.5 Alternative tokens

 

 

Rule2-5-1 (Advisory) Digraphs should not be used.
Rationale
The digraphs are:

<< > <: > 1 %:%:

The use of digraphs may not meet developer expectations.

Example

template < typename T>
class À
{
public:
template < int32 € i >
void £2 { );
};
void £ ( A<int32 t> * a<:10:> ) // Non-compliant
<< a<:0:>->12<20> ( )}; > // Non-compliant
// The above is equivalent to:
void f ( A<int32 £> * a[ 10 ] )
{
al 0 ]->f2<20> ( ): // Compliant
}

6.2.7 Comments

 

Rule 2-7—1 (Required) The character sequence /*+ shall not be used within a
C-style comment.

 

Rationale

C++ does not support the nesting of C-style comments even though some compilers support this
as a non-portable language extension. À comment beginning with / + continues until the first */ is
encountered. Any /* occurring inside a comment is a violation of this rule.

Example
Consider the following code fragment:

/* some comment, end comment marker accidentally omitted

Perform Critical Safety Function(X);
/* this "comment" is Non-compliant */

In reviewing the code containing the call to the function, the assumption is that it is executed code.

Because of the accidental omission of the end comment marker, the callto Perform Critical.
Safety Function will not be executed.

 

32 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 2-7-2 (Required) Sections of code shall not be ‘“‘commented out” using
C-style comments.

 

 

 

Rationale
Using C-style start and end comment markers for this purpose is dangerous because C-style

comments do not support nesting, and any comments already existing in the section of code would
change the effect.

Additionally, comments should only be used to explain aspects of the code that may not be clear
from the source code itself. Code that is commented-out may become out of date, which may lead
to confusion when maintaining the code.

À more appropriate method of recording the history of changes in source code (e.g. a Source
Control System) should be used instead of commenting-out.

Example

void fn ( int32 € i )
{

/*
++i; /* We want to increment Mi" *#/
*/
for ( int32 t 3j = 0 ; j = i ; +45)
{
}
}
See also

Rule 2-7-1, Rule 2-7-3

 

Rule 2-7-3 (Advisory) Sections of code should not be ‘“‘commented out” using
C++ comments.

 

 

 

Rationale

Ideally, comments should only be used to explain aspects of the code that may not be clear from
the source code itself. Code that is commented-out may become out of date, which may lead to
confusion when maintaining the code.

À more appropriate method of recording the history of changes in source code (e.g. a Source
Control System) should be used instead of commenting-out.

Example

void fn ( int32 € i )
{

 

1 ++i; // We want to increment
for ( int32t 3j = 0 ; j l= i ; ++)
{
}
}
33 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

See also
Rule 2—7-2

6.2.10 Identifiers

 

Rule 2-10-1 (Required) Different identifiers shall be typographically unambiguous.

 

Rationale

Depending on the font used to display the character set, it is possible for certain glyphs to appear
the same, even though the characters are different. This may lead to the developer confusing an
identifier with another one.

To help reduce the chance of this, identifiers shall not differ by any combination of:
°_ Only a mixture of case;
*_ The presence or absence of the underscore character;
*_ The interchange of the letter “O”, and the number “0”;
*_ The interchange of the letter “T”, and the number “1”;
*_ The interchange of the letter “T”, and the letter “1” (el);
+ _ The interchange of the letter “T” (el), and the number “1”;
*_ The interchange of the letter “S” and the number “5”;
*_ The interchange of the letter “2” and the number “2”;
*_ The interchange of the letter “n” and the letter “h”;
*_ The interchange of the letter “B” and the number “8”;
*_ The interchange of the letter sequence “rn” (“r” followed by “n””) with the letter “m”.

Example

int32 t id1 a b c;

int32 t id1 abc; // Non-compliant
int32 t id2 abc; // Non-compliant
int32 t id2 ARC; // Non-compliant
int32 t id3 a bc;

int32 t id3 ab c; // Non-compliant
int32 t id4 a bc;

int32 t idd ab c; // Non-compliant
int32 t ids ii;

int32 t id5 11; // Non-compliant
int32 t id6 i0;

int32 t id6 10; // Non-compliant
int32 t id in;

int32 t id7 1h; // Non-compliant
int32 t id8 75;

int32 t id8 25; // Non-compliant
int32 t id9 7S;

int32 t id9 25; // Non-compliant

 

34 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 2-10-2 (Required) Identifiers declared in an inner scope shall not hide an
identifier declared in an outer scope.

 

 

 

Rationale

If an identifier is declared in an inner scope and it uses the same name as an identifier that already
exists in an outer scope, then the innermost declaration will “hide” the outer one. This may lead
to developer confusion.

The terms outer and inner scope are defined as follows:
*_ Identifiers that have file scope can be considered as having the outermost scope.
*_ Identifiers that have block scope have a more inner scope.
*_ Successive, nested blocks, introduce more inner scopes.

Example
int16 € i;
{

int16 t i; // This is à different variable
// This is Non-compliant

 

1 = 3; // IE could be confusing as to which i this refers
}
void fn ( int16 t i ) // Non-compliant
{
}
Rule 2-10-3 (Required) À typedef name (including qualification, if any) shall be

 

 

a unique identifier.

 

Rationale

Reusing a fypedef name either as another fypedef name or for any other purpose may lead to
developer confusion.

The same fypedef shall not be duplicated anywhere in the project, even if the declarations are
identical.

Note that where the type definition is made in à header file, and that header file is included in
multiple source files, this rule 1s not violated.

Example

// fl.cc
namespace NS1
{
typedef int16 t WIDTEH;
}

// f2.cc
namespace NS2
{
float32 t WIDTH; // Compliant -
// NS2::WIDTH is not the same as NS1::WIDTH

 

35 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

void £1 ( )

{
typedef int32 t TYPE;

}

void £2 € )

{
float32 + TYPE; // Non-compliant

}

 

Rule 2-10-4 (Required) À class, union or enum name (including qualification, if
any) shall be à unique identifier.

 

 

 

Rationale

Reusing a class, union or enum name, either as another type or for any other purpose, may lead to
developer confusion.

The class, union or enum name shall not be duplicated anywhere in the project, even if the
declarations are identical.

This rule is not violated when the definition is made in à header file, and that header file is
included in multiple source files.

Example

void £1 ( )

{
class TYPE { }};

}

void £2 € )
{
float32 t TYPE; // Non-compliant

}

 

Rule 2-10-5 (Advisory) The identifier name of a non-member object or function
with static storage duration should not be reused.

 

 

 

Rationale

Regardless of scope, no identifier with static storage duration should be re-used across any source
files in the project. This includes objects or functions with external linkage and any objects or
functions with the static storage class specifier.

While the compiler can understand this and is in no way confused, the possibility exists for the
developer to incorrectly associate unrelated variables with the same name.

Example

namespace NS1

{
static int32 € global = 0;
}

 

36 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

namespace NS2

{

 

 

 

 

void fn ()
int32 € global; // Non-compliant
}
Rule 2-10—6 (Required) If an identifier refers to a type, it shall not also refer to
an object or a function in the same scope.
Rationale

For C compatibilitv, it is possible in C++ for a name to refer to both a type and object or a type
and function. This can lead to confusion.

Example

typedef struct vector { uint16 € x ; uint16 € y; uint16 t z; } vector;
// Non-compliant °° Non-compliant °°

struct vector { uint16 t x ; uint16 t y; uint16 t z; } vector;
// Non-compliant °° Non-compliant °°

6.2.3 Literals

 

Rule 2-13-1 (Required) Only those escape sequences that are defined in
ISO/IEC 14882:2003 shall be used.

 

 

 

[Undefined 2.13.2(3)|
Rationale
The use of an undefined escape sequence leads to undefined behaviour.
The defined escape sequences (ISO/IEC 14882:2003 [1] $2.13.2) are:

 

Va, , , lb, Vr, \f la, N, 7, VV \<Octal Number”, \x<Hexadecimal Number>
Example
void fn { )
{
const char t a[ 2 ] = "\k"; // Non-compliant
const char t b[ 2 ] = "\b"; // Compliant
}
See also
Rule 2-13-2
37 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 2-13-2 (Required) Octal constants (other than zero) and octal escape
sequences (other than ‘“\o”) shall not be used.

 

 

 

[Implementation 2.13.2(1, 2)]
Rationale

Any integer constant beginning with a “0” (zero) is treated as octal. Because of this, it is possible
for a Zero-prefixed constant that is intended to be a decimal number to be incorrectly entered as an
octal number, contrary to developer expectations.

Octal escape sequences can also be problematic because the inadvertent introduction of a decimal
digit (1e. “8” or “9”) ends the octal escape and introduces another character.

The integer constant zero (written as a single numeric digit), is strictly speaking an octal constant,
but is a permitted exception to this rule. Additionally, “\0” is the only permitted octal escape
sequence.

Example

The following array initialization for 3-digit decimal bus messages would not behave as
expected:

code[ 1 ] = 109; // Compliant — decimal 109
code[ 2 ] = 100; // Compliant — decimal 100
code[ 3 ] = 052; // Non-compliant - equivalent to decimal 42
code[ 4 ] = 071; // Non-compliant - equivalent to decimal 57

The value of the first expression in the following example 1s implementation-defined because
the character constant consists of two characters, “\10” and “2”. The second character constant
expression contains the single character “\100”.

 

codef[ 5 ] = '"\108'; // Non-compliant - implementation-defined,
// two character constant
code[ 6 ] = "\100'; // Non-compliant - set to 64.
Rule 2-13-3 (Required) À “U? suffix shall be applied to all octal or hexadecimal

 

 

integer literals of unsigned type.

 

Rationale
The type of an integer is dependent on a complex combination of factors including:

*_ The magnitude of the constant;

*_ The implemented sizes of the integer types;

*_ The presence of any suffixes;

*_ The number base in which the value is expressed (1.e. decimal, octal or hexadecimal).
For example, the value Ox8000 is of type unsigned int in a 16-bit environment, but of type (signed)
int in a 32-bit environment. If an overload set includes candidates for an unsigned int and an inf,

then the overload that would be matched by Ox8000 is therefore dependent on the implemented
integer size. Adding a “U” suffix to the value specifies that it 1s unsigned.

Note that the usage context may also require the use of suffixes, as shown in Section 6.5.0.

 

38 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

template <typename T>

void £ ( T );

template <>

void f < uint16 t > ( uint16 € );

template <>
void f < int16 t > ( int16 € );

 

 

void b ( )
{
uint16 Et ui6a = OU; // Compliant
£f { 0x8000 ): // Non-compliant on a 16-bit platform.
u16a = u16a + 0x8000; // Non-compliant as context is unsigned.
}
| Rule 2-13-4 (Required) Literal suffixes shall be upper case.
Rationale

Using upper case literal suffixes removes the potential ambiguity between “1” (digit 1) and “1”
(letter el) for declaring literals.

Example
const uint32 t a = OU;
const uint32 t b = Ou; // Non-compliant
const int64 € c = OL;
const int6d t d = Ol: // Non-compliant
const uint64 t e = OUL;
const uint64 t £ = OUl; // Non-compliant
const uint32 t g = 0x12bU;
const uint32 t h = 0x12bu; // Non-compliant
const float32 t m = 1.2F;
const float32 t n = 2.4f; // Non-compliant

2
const float128 € p = 1.21;
const float128 t n = 2.41; // Non-compliant

See also
ISO/IEC 14882:2003 [1] 82.13

 

 

Rule 2-13-5 (Required) Narrow and wide string literals shall not be concatenated.

 

[Undefined 2.13.4(3)|
Rationale

Concatenation of wide and narrow string literals leads to undefined behaviour.

 

Example
char t on array[] = "Hello" "World"; // Compliant
wchar t w array[] = L'Hello" L'World'"; // Compliant
wchar t mixed{] = "Hello" L'World"; // Non-compliant
39 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.3 Basic concepts
6.31 Declarations and definitions

 

 

 

 

Rule 3-1-1 (Required) It shall be possible to include any header file in multiple
translation units without violating the One Definition
Rule.
Rationale

Header files should be used to declare objects, functions, inline functions, function templates,
typedefs, macros, classes, and class templates and shall not contain or produce definitions of
objects or functions (or fragment of functions or objects) that occupy storage.

À header file is considered to be any file that is included via the #include directive, regardless of
name or suffix.

Example
// a.h
void £1 € ): // Compliant
void £2 ({ ) {7} // Non-compliant
inline void £3 ( )} { } // Compliant
template <typename T>
void £4 {TT ) {3} // Compliant
int32 t a; // Non-compliant
// a.cpp

#include "a.n"

 

Rule 3-1-2 (Required) Functions shall not be declared at block scope.

 

Rationale

A function declared at block scope will refer to a member of the enclosing namespace, and 50 the
declaration should be explicitly placed at the namespace level.

Additionally, where à declaration statement could either declare a function or an object, the
compiler will choose to declare the function. To avoid potential developer confusion over the
meaning of a declaration, functions should not be declared at block scope.

Example

class À

{

};

void b1 ( )

{
void f1 (); // Non-compliant - declaring a function in block scope
A a (); // Non-compliant - appears to declare an object with no

// arguments to constructor, but it too declares a
// function ‘a
// parameters.

" returning type 'A' and taking no

 

40 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 3-1-3 (Required) When an array is declared, its size shall either be stated
explicitly or defined implicitly by initialization.

 

 

 

[Undefined 5.7(5, 6)]
Rationale

Although it is possible to declare an array of incomplete type and access its elements, it is safer to
do so when the size of the array can be explicitly determined.

Example
int32 t arrayi{ 10 ]; // Compliant
extern int32 t array2{ |]; // Non-compliant
int32 t array3l ] = { 0, 10, 15 }; // Compliant
extern int32 t arrayd{[ 42 ]; // Compliant

6.3.2 One Definition Rule
The One Definition Rule is defined in Section 3.2 of ISO/IEC 14882:2003 [1].

In essence, the requirement for One Definition Rule arises because C++ compilers treat each source
file (with included headers) as separate “translation units” where each translation unit is compiled
in isolation. The set of compiled translation units are then linked to form the executable program.

The linker is allowed to assume that objects, templates, types, etc. that share the same name in
different translation units refer to the same definition. The linker is not required to check that these
definitions are the same.

In the following example the same struct S appears to be defined in both translation units, but
as the definitions are not the same, the result is not what the developer expects.

// source file filel.cpp
struct $S

{
int32 € x;
int32 € y;
};
int32 t XminusY (S & s )
{

return ( S.x - s.y );

}

// source file file2.cpp

struct $S {
int32 t y; // note order of x and y exchanged
int32 € x;

};

void setX ( S & s, int32 € v ) { s.x = v; }

void setY ( S & s, int32 € v ) { s.y = v; }

The user may be surprised that the result of XminusY is y - xnotx - y.

As stated above, the linker is not required to check the compatibility of the two definitions; the
One Definition Rule puts the onus on the developer to ensure that the definitions are compatible.
The following rules (Rule 3-2-1 to Rule 3-24) reinforce the need to follow the One Definition
Rule, and provide specific instructions for the developer.

 

41 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 3-2-1 (Required) AII declarations of an object or function shall have
compatible types.

 

 

 

[NDR 3.263). Undefined 3.2(5)]
Rationale

It is undefined behaviour if the declarations of an object or function in two different translation
units do not have compatible types.

The easiest way of ensuring object or function types are compatible is to make the declarations
identical.

Example

// File a.cpp
extern int32 t a;
extern int32 t b [|];
extern char t c;

int32 + f1 ();
int32 t £2 ( int32 t );

// File b.cpp

 

 

extern int64 t a; // Non-compliant - not compatible
extern int32 t b [ 5 ]; // Compliant
inti6 t c; // Non-compliant
char t f1 ( ); // Non-compliant
char t £2 ( char € ); // Compliant - not the same function as
// int32 t f2 ( int32t)
See also
Rule 3-9-1
Rule 3-2-2 (Required) The One Definition Rule shall not be violated.
Rationale

Violation of the One Definition Rule ([1] $3.2) leads to undefined behaviour. In general, this means
that the program shall contain exactly one definition of every non-inline function or object.

Additionally:
° The definitions of a type shall consist of the same sequence of tokens, and;
*_ The definitions of a template shall consist of the same sequence of tokens, and;
*_ The definitions of an inline function shall consist of the same sequence of tokens.

Note that for the purposes of this rule, fypedefs shall be treated as types.

Example
// File a.cpp
struct ST
{
int32 € i;

};

 

42 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

struct 52
{
int32 € i;
};
// File b.cpp

struct ST
{
int64 € i;
3 // Non-compliant - token sequence different
struct 52
{
int32 € i;
int32 € j;
3 // Non-compliant - token sequence different

 

Rule 3-2-3 (Required) A type, object or function that is used in multiple
translation units shall be declared in one and only one file.

 

 

 

Rationale

Having a single declaration of a type, object or function allows the compiler to detect incompatible
types for the same entity.

Normally, this will mean declaring an external identifier in a header file that will be included in
any file where the identifier is defined or used.

Example

// header.hpp
extern int16 t a;

// filel.cpp
#include "header.hpp"

extern int16 € b;

// file2.cpp
#include "header.hpp"

 

extern int32 € b; // Non-compliant - compiler may not detect the error
int32 t a; // Compliant - compiler will detect the error
Rule 3-2-4 (Required) An identifier with external linkage shall have exactly

one definition.

 

 

 

[NDR 3.263). Undefined 3.2(5)]
Rationale

It is undefined behaviour if an identifier is used for which multiple definitions exist (in different
translation units) or no definition exists at all. With the exception of templates and inline functions,
multiple definitions in different translation units are not permitted, even if the definitions are the
same.

 

43 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

// filel.cpp
int32 t i = 0;

// file2.cpp
int32 t i = 1; // Non-compliant

6.3.3 Declarative regions and scope

 

Rule 3-3-1 (Required) Objects or functions with external linkage shall be
declared in a header file.

 

 

 

Rationale

Placing the declarations of objects and functions with external linkage in a header file documents
that they are intended to be accessible from other translation units.

If external linkage is not required, then the object or function shall either be declared in an unnamed
namespace or declared sfafic.

This will reduce the visibility of objects and functions, which is considered to be good practice.

Exception

This rule does not apply to maïn, or to members of unnamed namespaces.

Example

// header.hpp
extern int32 t al;
extern void £3 ( );

// filel.cpp
#include "header.hpp"

int32 t al = 0; // Compliant
int32 t a2 = 0; // Non-compliant
static int32 € a3 = 0; // Compliant
namespace
{
int32 t ad = 0; // Compliant
void £1 () // Compliant
{
}
}
static void £2 ( ) // Compliant
{
}
void £3 ( ) // Compliant
{
al = 1;
a2 = 1;
a3 = 1;
a4 = 1;

 

44 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

void £4 € ) // Non-compliant
{
al =
a2 =
a3 =
ad =
}

void main ( ) // Compliant by exception
{
£T
£2
£3
f4

 

Rule 3-3-2 (Required) If a function has internal linkage then all re-
declarations shall include the sfatic storage class
specifier.

 

 

 

Rationale
If the declaration of a function includes the sfatic storage class specifier, then it has internal
linkage.

A re-declaration of such a function is not required to have the sfafic keyword, but it will still have
internal linkage. However, this is implicit and may not be obvious to a developer. It is therefore
good practice to apply the sfatic keyword consistently so that the linkage is explicitly stated.

Example

static void f1
static void f2

Se

 

void f1 {7} // Non-compliant
static void £2 {7} // Compliant
6.3.4 Name lookup
Rule 3-4-1 (Required) An identifier declared to be an object or type shall be

 

 

defined in a block that minimizes its visibility.

 

Rationale

Defining variables in the minimum block scope possible reduces the visibility of those variables
and therefore reduces the possibility that these identifiers will be used accidentally. À corollary
of this is that global objects (including singleton function objects) shall be used in more than one
function.

 

45 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

void f ( int32 € Kk )
{

int32t j = Kk * k; // Non-compliant
{
int32 t i = j; // Compliant
std:i:cout << i << j << std::endl;

}

In the above example, the definition of ; could be moved into the same block as i, reducing the
possibility that ; will be incorrectly used later in £.

 

 

 

 

6.3.9 Types
Rule 3-9-1 (Required) The types used for an object, a function return type, or
a function parameter shall be token-for-token identical
in all declarations and re-declarations.
Rationale

If a re-declaration has compatible types but not types which are token-for-token identical, it may
not be clear to which declaration that re-declaration refers.

 

Example
typedef int32 € INT;
INT i;
extern int32 t ji; // Non-compliant
INT j;
extern INT j; // Compliant
// The following lines break Rule 3-9-2
extern void f ( signed int );
void £ { int ); // Non-compliant
extern void g ( const int );
void q { int ); // Non-compliant
See also
Rule 3-2-1, Rule 3-9-2
Rule 3-9-2 (Advisory) typedefs that indicate size and signedness should be

 

 

used in place of the basic numerical types.

 

[Implementation 3.9.1(1, 5)]

Rationale

The basic numerical types of char, int, short, long, float, double and long double should not be
used, but specific-length fypedefs should be used. This rule helps to clarify the size of the storage,
but does not guarantee portability because of the asymmetric behaviour of integral promotion. See

 

46 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

the discussion of integral promotion in Section 6.5.0. It is still important to understand the integer
size of the implementation.

Developers should be aware of the actual implementation of the fypedefs under these definitions.

Exception
The wchar_t does not need a typedef as it always maps to a type that supports wide characters.

The char _t typedef does not indicate size and signedness and is simply included to allow char
objects to be declared without the use of the basic char type, allowing any use of (plain) char to
be detected and reported by analysis tools.

Example

The ISO (POSIX) fypedefs as shown below are recommended and are used for all basic numerical
and character types in this document. For a 32-bit integer machine, these are as follows:

typedef char char t;
typedef signed char int8 t;
typedef signed short int16 t;
typedef signed int int32 t;
typedef signed long int64 t;
typedef unsigned char uint8 t;
typedef unsigned short uint16 *t;
typedef unsigned int uint32 t;
typedef unsigned long uint64 €;
typedef float float32 t;
typedef double float64 t;
typedef long double float128 t;

typedeÿs are not considered necessary in the specification of bit-field types.

 

Rule 3-9-3 (Required) The underlying bit representations of floating-point
values shall not be used.

 

 

 

[Implementation 3.9.1(8)]
Rationale

The storage layout used for floating-point values may vary from one compiler to another, and
therefore no floating-point manipulations shall be made which rely directly on the way the values
are stored. The in-built operators and functions, which hide the storage details from the developer,
should be used.

Example

float32 t My fabs ( float32 t £ )
{
uint8 € * pB = reinterpret cast< uint8 € * >( &f );
*( pB +3 ) &= Ox7f; // Non-compliant - generate the absolute value

// of an IEEE-754 float value.
return ( £ );

 

A7 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.4 Standard conversions
6.4.5 Integral promotions

 

Rule 4-5-1 (Required) Expressions with type boo! shall not be used as
operands to built-in operators other than the
assignment operator =, the logical operators &&, | |, !,
the equality operators == and !=, the unary & operator,
and the conditional operator.

 

 

 

Rationale

The use of bool operands with other operators is unlikely to be meaningful (or intended). This rule
allows the detection of such uses, which often occur because the logical operators (44, | | and !)
can be easily confused with the bitwise operators (&, | and -).

Example
bool b1 = true;
bool b2 = false:
int8 € s8a;
1f { b1 & b2 ) // Non-compliant
1f { b1 < E2 ) // Non-compliant
1f { <b1 ) // Non-compliant
if { b1 ° E2 ) // Non-compliant
if ( b1 == false ) // Compliant
if ( b1l == b2 ) // Compliant
if ( b1 != b2 ) // Compliant
if ( b1 && b2 ) // Compliant
if ( !b1 ) // Compliant

s8a = b1 7? 3 : 7; // Compliant

 

Rule 4-5-2 (Required) Expressions with type ezum shall not be used as
operands to built-in operators other than the subscript
operator [ ], the assignment operator =, the equality
operators == and !=, the unary & operator, and the
relational operators <, <=, >, >=.

 

 

 

Rationale

Enumerations have implementation-defined representation and so should not be used in arithmetic
contexts.

Example
enum { COLOUR 0, COLOUR 1, COLOUR 2, COLOUR COUNT } colour;
if ( COLOUR 0 == colour ) // Compliant
if ( ( COLOUR 0 + COLOUR 1 ) == colour ) // Non-compliant
if ( colour < COLOUR COUNT ) // Compliant

 

48 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 4-5-3 (Required) Expressions with type (plain) char and wchar_t shall not
be used as operandés to built-in operators other than the
assignment operator =, the equality operators — and
=, and the unary & operator.

 

 

 

Rationale

Manipulation of character data may generate results that are contrary to developer expectations.
For example, ISO/IEC 14882:2003 [1] $2.2(3) only requires that the digits “0” to “9” have
consecutive numerical values.

Exception

Exceptionally, the following operators may be used if the associated restriction is observed:
*_ The binary + operator may be used to add an integral value in the range 0 to 9 to ‘0;
*_ The binary - operator may be used to subtract character ‘0”;

*_ The relational operators <, <=, >, >= may be used to determine if a character (or wide
character) represents a digit.

 

Example
char t ch = 't'; // Compliant
uint8 E v;
if { { ch >= ‘at } && ( ch <= 'z' ) ) // Non-compliant
{
}
if ( { ch >= "O0" } && ( ch <= "91 } ) // Compliant by exception
{
v = ch - '0'; // Compliant by exception
v = ch - '1'; // Non-compliant
}
else
{
//
}
ch = ‘O0! + v; // Compliant by exception
ch = ‘AT + v; // Non-compliant
49 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.410 Pointer conversions

 

| Rule 4-10-1 (Required) NULL shall not be used as an integer value.

 

Rationale

In C++, the literal O is both an integer type and the null-pointer-constant. To meet developer
expectations, NULL should be used as the null-pointer-constant, and 0 for the integer zero.

Note: as a result of this rule, NULL is considered to have pointer type.

Example
#include <cstddef>
void fT ( int32 t );
void f2 ( int32 € * );
void £3 ( )

£T { NULL ): // Not-compliant, NULL used as an integer
f2 ( NULL j): // Compliant

 

Rule 4-10-2 (Required) Literal zero (0) shall not be used as the rull-pointer-
constant.

 

 

 

Rationale

In C++, the literal O is both an integer type and the null-pointer-constant. To meet developer
expectations, NULL should be used as the null-pointer-constant, and 0 for the integer zero.

Example
#include <cstddef>
void fT ( int32 t );
void f2 ( int32 € * );
void £3 ( )
{
f1 ( 0 ); // Compliant
£2 (€ O ): // Non-compliant, 0 used as the null pointer constant

 

50 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.5 Expressions
6.5.0 General

Strong typing
When developing critical systems it is considered best practice to use strong typing. This facility

is not rigidly enforced for the built-in types of the C++ language, so the following guidance has
been produced to strengthen the use of those types.

Arithmetic type conversions
Implicit and explicit type conversions

The C++ language allows the developer considerable freedom and will allow conversions between
different arithmetic types to be performed automatically. An explicit cast may be introduced for
functional reasons, for example:

*_ To change the type in which à subsequent arithmetic operation is performed.
*_ To truncate a value deliberately.
*_ To make a type conversion explicit in the interests of clarity.

The insertion of a cast for purposes of clarification is often helpful, but when taken to excess, the
practice can lead to unreadable code. As demonstrated below, there are some implicit conversions
that can safely be ignored and others that cannot.

Types of implicit conversion

There are three particular categories of implicit type conversion that need to be distinguished.

Integral promotion conversions

Integral promotion describes à process whereby arithmetic operations are always conducted on
integer operands of type int or long (signed or unsigned). Operands of type char, short and bool
are always converted to type inf or unsigned int whilst those of type wchar f and enum may be
converted to inf, unsigned int, long or unsigned long. These are referred to as small integer types.

The rules of integral promotion ([1] $4.5) require that in most arithmetic operations, an operand
of a small integer type be converted to inf, if an inf is able to represent all values of the original
type; otherwise the value is converted to unsigned int, long or unsigned long. À bit-field will be
converted to an inf if an int is able to represent all the values; it will be converted to an unsigned
int if an unsigned int is able to represent all the values, otherwise no promotion takes place.

Integral promotion is frequently confused with “balancing” of operands (described below).
Balancing only occurs for some binary operators, whilst integral promotion can take place for
other expressions when a small integer is used.

Because of integral promotion, the result of adding two objects of type unsigned short is always
a value of type signed int or unsigned inf; in fact, the addition is performed in this promoted type.
It is therefore possible for such an operation to derive a result whose value exceeds the size that
could be accommodated in the original type of the operands. For example, if the size of an inf is
32 bits, it is possible to multiply two objects of type short (16 bits) and derive a 32-bit result with
no danger of overflow. On the other hand if the size of an inf is only 16 bits, the product of two
16-bit objects will only yield a 16-bit result and care must be taken to ensure that an unexpected

 

51 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

overflow does not remain undetected.

Integral promotion also applies to some unary operators. For example, the result of applying a bitwise
negation operator (-) to an wnsigned char operand is typically a negative value of type signed int.

Integral promotion is a fundamental inconsistency in the C++ language (inherited from C) whereby
the small integer types behave differently from long and int types. The use of fypedefs is a practice
that is encouraged in MISRA C++. However, because the behaviour of the various integer types is
not consistent, it can be unsafe to ignore the underlying base types (see description on following
pages) unless some restrictions are placed on the way in which expressions are constructed. It is
the intention of the following rules that the effects of integral promotion should be neutralized in
order to avoid these anomalies.

Assigning conversions
Assigning conversions occur when:

*_ The type of an assignment expression is converted to the type of the assignment object;
*_ The type of an initializer expression is converted to the type of the initialized object;

*_ The type of a function call argument is converted to the type of the formal parameter as
declared in the function prototype;

*_ The type of the expression used in a return statement is converted to the type of the
function as declared in the function prototype;

*_ The type of the constant expression in a switch case label is converted to the promoted
type of the controlling expression. This conversion is performed only for the purposes of
comparison.

In each case, the value of an arithmetic expression is unconditionally converted, where necessary,
to another type.

Balancing conversions

Balancing conversions for arithmetic and enumeration types are described in ISO/IEC 14882:2003
([11 $5(2)) under the term “Usual Arithmetic Conversions”. This is a set of rules that provides
a mechanism to yield a common type when two operands of a binary operator are balanced to a
common type. Also, the second and third arguments of the conditional operator ( ? : ) ([1] $5.16)
are sometimes balanced to a common type.

The balancing rules are preceded by the process of integral promotion (described above). Integral
promotion happens as part of the usual arithmetic conversions even when two operands are of
identical type.

Integral types having special semantics

In C++ there are a number of types that have an integral representation and can be freely used
in any arithmetic expression. The types concerned are bool, char, wchar_t and enum. For the
purpose of this document, bit-field objects are considered to have a special type.

Thus, an expression of type bool can be multiplied by an expression of type char, which is then
added to an expression of enum type.

Terminology will be defined and rules introduced to restrict the use of these types to appropriate
contexts.

 

52 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Bit-fields

Depending on the width of a bit-field, it may undergo integral promotions and so, like the small
integer types, it can lead to operations that have dangerous conversions. Therefore bit-fields should
be considered as integral types of fixed length (that of the number of specified bits) the permissible
range being from length zero to the number of bits of the largest integral type.

Dangerous type conversions
There are a number of potential dangers associated with type conversions that must be avoided:

*_ Loss of value: Conversion to a type where the magnitude of the value cannot be
represented.

*_ Loss of sign: Conversion from a signed type to an unsigned type resulting in loss of sign.

*_ Loss of precision: Conversion from a floating type to an integer type with consequent loss
of precision. Conversion from a floating type to a narrower floating type (which may also
be a loss of value).

The only type conversions that can be guaranteed safe for all data values and all possible conforming
implementations are:

*_ Conversion of an integral value to a wider type of the same signedness;
*_ Conversion of a floating type to a wider floating type.

In practice, if assumptions are made about typical type sizes, it is possible to classify other
type conversions as safe. In general, MISRA C++ adopts the principle that it is wise to identify
potentially dangerous type conversions by requiring that the conversion be made explicit.

Other dangers in the area of type conversion also need to be recognized. These issues arise from
areas of misunderstanding and difficulty in the C++ language rather than because data values are
not preserved.

* Type widening in integral promotion: The type in which integral expressions are
evaluated depends on the type of the operands after any integral promotion. It is always
possible to multiply two 8-bit values and access a 16-bit result if the magnitude requires it.
It is sometimes, though not always, possible to multiply two 16-bit values and retrieve a
32-bit result. It is safer never to rely on the widening type afforded by integral promotion.
Consider the following example:

uint16 Et ui6a = 40000; // unsigned short / unsigned int ?
uint16 Et u16b = 30000; // unsigned short / unsigned int ?
uint32 € u32x = ul6a + u16b; // u32x = 70000 or 4464 ?

The expected result is presumably 70000, but the value assigned to 132x will in practice
depend on the implemented size of an inf. If the implemented size of an inf is 32 bits, the
addition will occur in 32-bit signed arithmetic and the correct value will be stored. If the
implemented size of an inf is only 16 bits, the addition will take place in 16-bit unsigned
arithmetic, wraparound will occur and will yield the value 4464 (70000 % 65536).
Wraparound in unsigned arithmetic is well defined and may even be intended, but is
potentially confusing.

*_ Evaluation type confusion: À similar problem arises from a common misconception
among developers that the type in which a calculation is conducted is influenced in some
way by the type to which the result is assigned or converted. For example, in the following

 

53 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

code the two 16-bit objects are added together in 16-bit arithmetic (on a platform with a
16-bit inf), and the result is converted to type #int32 f on assignment.
u32x = ul6a + ul6b;

It is not unusual for developers to be deceived into thinking that the addition is performed
in 32-bit arithmetic — because of the type of u32x.

Confusion of this nature is netther confined to integer arithmetic nor to implicit conversions.
The following examples demonstrate some statements in which the result is well defined but
the calculation may not be performed in the type that the developer assumes.

u32a = static cast< uint32 € >(u16a * ul6b); // Evaluated in u16

f64a = ul6a / u16b; // Evaluated in u16
£32a = static cast< float32 t >(u16a / u1l6b); // Evaluated in u16
fé6da = £32a + f32b; // Evaluated in f32

féda = static cast< float64 t >(f32a + f32b); // Evaluated in f32

°_ Change of signedness in arithmetic operations: Integral promotion will often result in
two unsigned operands yielding a result of type (signed) int. For example, the addition
of two 16-bit unsigned operands will vield a signed 32-bit result if inf is 32 bits, but an
unsigned 16-bit result if inf is 16 bits.

°_ Change of signedness in bitwise operations: Integral promotion can have some
particularly unfortunate repercussions when bitwise operators are applied to small
unsigned types. For example, a bitwise complement operation on an operand of type
unsigned char will generally yield a result of type (signed) int with a negative value. The
operand is promoted to type if before the operation and the extra high order bits are set
by the complement process. The number of extra bits, if any, is dependent on the size of an
int, Which is hazardous if the complement operation is followed by a right shift.

In order to avoid the pitfalls associated with the issues described above, it is important to establish
some principles to constrain the way in which expressions are constructed. "To start with, definitions
of some concepts are presented below.

Underlying type
In à programming language, a type has a representation that is a mapping onto the hardware

architecture. À type also has an implementation equating to the set of operations which can be
performed on that type via its representation.

MISRA C:2004 introduced the concept of underlving type. Unfortunately the term is already used
in C++ as a euphemism for representation, where the representation of one type is described in
terms of other types. This use, however, is confined to the wchar f and enumeration types (see
Sections 3.9.1(5) and 7.2(6) of ISO/IEC 14882:2003 [1]). In both cases, from the MISRA point of
view, the underlying type of these types will be simple and hence the possibility of confusion will be
minimal. Consequently, it is appropriate to adopt the MISRA C:2004 concept and terminology.

Since C++ has an explicit bool type it is not considered necessary to permit the “Boolean by
construction” concept introduced in MISRA C:2004.

Underlying type is a conceptual departure from the C++ language in which integral promotion
does not exist, and the usual arithmetic conversions are applied consistently to all integer types.

This concept is introduced because the effects of integral promotion and implicit conversions are
subtle and sometimes dangerous. Integral promotion is an unavoidable feature of the C++ language,

 

54 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

but the intention of these rules is that the effect of integral promotion should be neutralized
by taking no advantage of the widening that occurs with small integer operands.

The C++ standard does not explicitly define how small integer types would be balanced to a
common type in the absence of integral promotion, although it does establish the principles of
value-preservation.

When adding operands of type inf, the developer is obliged to ensure that the result of the operation
will not exceed a value that can be represented in type inf. If the developer should fail to do so,
overflow will occur, and the result will be undefined. It is the intention of the approach described
here that the same principle should apply when small integer operands are added; the developer
should ensure, for example, that the result of adding two unsigned chars can be represented in
an unsigned char, even though integral promotion could give rise to evaluation in a larger type.
In other words, the limitations of the wnderlying type of an expression should be observed, rather
than the actual type.

In general, the underlying type of an expression is determined by the type of the operand or sub-
expression that “is widest”. À compliant expression is one in which all operators notionally take
operands of this #nderlying type.

Underlying type of an integer literal

The numeric value “5” can be expressed as a literal constant of type inf unsigned int, long or
unsigned long by the addition (or absence) of a suitable suffix; but no suffix is available to create a
representation of the value of signed char, unsigned char or short types. This presents a difficulty
when attempting to maintain type consistency in expressions. If it is desired to assign a value
to an object of type unsigned char, then either an implicit type conversion from an integer type
must be tolerated, or else a cast must be introduced. Many would argue that to use a cast in such
circumstances serves only to reduce readability.

The same problem exists when literals are required in initializers, function arguments or arithmetic
expressions. However, the problem is largely a philosophical one associated with the aspiration to
observe the principles of strong typing.

One way of addressing this problem is to imagine that an integer literal (or an integer constant
expression made up only of literals) has a type appropriate to its magnitude and context. This type
then becomes the wnderlying type of the literal.

The wnderlyving type of an integer constant expression 1s therefore defined as follows:

1. If the actual type of the expression is signed integral, the vrderlyving type is defined as the
smallest signed integer type that is capable of representing its value.

2. If the actual type of the expression is unsigned integral, the underlying type 1s defined as
the smallest unsigned integer type that is capable of representing its value.

3. In all other circumstances, the underlying type of the expression is defined as being the
same as its actual type.

 

55 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

In a 32-bit architecture, the underlying type of an integer literal will be determined according to
its magnitude and signedness as follows:

Unsigned values

 

 

 

 

 

 

 

 

 

OÙ to 255U| 8 bit unsigned
256U to 65535016 bit unsigned
65536U to 4294967295Ù | 32 bit unsigned
Signed values
2147483648 to -32769|32 bit signed
32768 to -129116 bit signed
—128 to 127] 8 bit signed
128 to 32767116 bit signed
32768 to 2147483647132 bit signed

 

 

 

 

 

 

Notice that underlying type is an artificial concept. It does not in any way influence the type of
evaluation that 1s actually performed. The concept has been developed simply as a way of defining
a safe framework in which to construct arithmetic expressions.

The cvalue expression

As a general principle, all operations in an expression should be performed in a consistent type.
Therefore, an operation evaluated in one wnderlying type should not be subsequently converted to
a different underlying type.

An expression that should not undergo further conversions, either implicitly or explicitly, is called
a cvalue expression. Note that the term complex expression, which was used in MISRA C:2004,
has the same meaning as cvalue in this document.

Determination of the underlying type of an expression

The following describes the mechanism for determining the underlying type of an expression.

Class type operands

If any operand has class type and an implicit conversion was performed to convert the class to a
built-in type, the underlying type shall be the type after the implicit conversion.

Bit-field operands

Bit-field objects have an underlyving type equivalent to an integral type of a size determined by their
width. For example, a bit-field with width #, will have the same wnderlying type as a fundamental
type with the same sign and width (if one exists).

 

56 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6.

Rules (continued)

 

Underlying type balancing

The following are conceptual replacements for the usual arithmetic conversions ([11 $5(0)). These
replacements are called the underlying type conversions.

If an overloaded operator function is called, the underlying type of the expression is the
underlying type of the return of the overloaded operator.

Otherwise, if either operand has char type (not explicitly signed or unsigned), then the
underlying type of the expression is char type.

Otherwise, if either operand has erum type then the underlying type of the expression is
enum type.

Otherwise, if either operand has pointer type, then the underlying type of the expression is
pointer type.

Otherwise, if either operand has bool type, then the underlying type of the expression is
bool type.

Otherwise, if both operands are integral literals (or expressions wholly comprised
thereof) then the underlying type of the expression is the smallest fundamental type of the

appropriate sign required to store the value of the evaluated expression. For example, the
underlying type of 120+5+3 is 516.

Otherwise, if both operands have integral type, the underlyving type of the expression can
be found using the following:

— Ifthe types of the operands are the same size, and either is unsigned, the result is
unsigned.

— Otherwise, the type of the result is that of the larger type.

Otherwise, 1f one of the operands has floating point type, then the wrderlving type of the
expression can be found using the following:

— Ifone of the operands has integral type, then the type of the result is that of the floating
point type.
— Otherwise, the type is the result of the larger type.

The mechanism

Expressions ([1] $5), other than constant integral expressions ([1] $5.19), used in the following
contexts are always cvalues:

Function argument expressions;
Return expressions.

Similarly, unless listed below:

Binary expressions are not cvalues and their underlying type is the result of applying the
underlying type conversions.

The other unlisted expressions are not cvalues and have the wnderlyving type of the
operation.

 

57 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Primary expressions ([1] 85.1)

literal
The underlying type of an integral literal is the smallest fundamental type of the appropriate sign
required to store its value. For example, the underlying type of the literal 128 is 516. The result is
not a cvalue.

( expression )
À parenthesized expression is a cvalue if the expression is a cvalue. The underlying type is the
underlying type of the expression.

Postfix expressions ([1] $5.2)
postfix-expression ++
postfix-expression -
The result is a cvalue expression whose underlying type is that of the postfix-expression.

postfix-expression [ expression ]
The result is not a cvalue. The underlying type of the result is the wnderlying type of the array
element.

postfix-expression ( expression-listopt )
The result is not a cvalue. The underlying type of the result is the #nderlying type of the function
return type. For brevity, this pattern is to apply to all function call syntaxes.

simple-type-specifier { expression-listopt )
The result is not a cyalue. The underlying type of the result is the underlying type of simple-type-
specifier.

dynamic cast < type-id > ( expression )
static cast < type-id > { expression )
reinterpret_ cast < type-id > (expression )
const cast < type-id > { expression )
The result is not a cyvalue. The underlying type of the result is the underlying type of type-id.

Unary expressions ([1] $5.3)

++ cast-expression
-- cast-expression
— cast-expression

- cast-expression

The result is a cvalue expression whose underlying type is that of the cast-expression.

! cast-expression
The result is a cvalue expression whose underlying type is bool.

 

58 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Explicit type conversions ([1] $5.4)
{ type-id ) cast-expression
The result is not a cyalue expression. Its wnderlying type is that of fype-id.

Multiplicative operators ([1] 85.6)

multiplicative-expression * pm-expression

multiplicative-expression / pm-expression

multiplicative-expression % pm-expression
The result is a cvalue expression whose underlying type 1s as defined by the wrderlying type
conversions.

Additive operators ([1] 85.7)

additive-expression + multiplicative-expression

The result is a cvalue expression whose underlying type 1s as defined by the wrderlying type
conversions.

additive-expression - multiplicative-expression

The result is a cvalue expression. Normally, the underlving type of the result 1s as defined by the
underlying type conversions; however, where both operands have pointer type, the underlying
type of the result is pérdiff t.

Shift operators ([1] $5.8)

shift-expression << additive-expression

shift-expression = > additive-expression
The result is à cvalue expression. The underlying type of the result is the underlying type of the
shift-expression.

Relational operators ([1] 85.9)

relational-expression < shift-expression
relational-expression > shift-expression
relational-expression <= shift-expression
relational-expression > = shift-expression

The result is a cvalue expression whose underlying type is bool.

Equality operators ([1] $5.10)

equality-expression == relational-expression
equality-expression !/= relational-expression
The result is a cvalue expression whose underlying type is bool.

Bitwise AND operator ([1] 85.11)

and-expression & equality-expression

The result is a cvalue expression whose underlying type 1s as defined by the wnderlying type
conversions.

 

59 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Bitwise exclusive OR operator ([1] $5.12)

exclusive-or-expression ” and-expression

The result is a cvalue expression whose underlying type 1s as defined by the wrderlying type
conversions.

Bitwise inclusive OR operator ([1] 85.13)

inclusive-or-expression | exclusive-or-expression

The result is a cvalue expression whose underlying type 1s as defined by the wrderlying type
conversions.

Logical AND operator ([1] 85.14)

logical-and-expression && inclusive-or-expression
This is a cvalue expression whose underlying type is bool.

Logical OR operator ([1] $5.15)
logical-or-expression || logical-and-expression
This is a cvalue expression whose underlying type is bool.

Conditional operator ([1] 85.16)

logical-or-expression ? expression : assignment-expression
This is a cvalue expression whose underlying type is defined by the underlying type conversions
applied to the expression and assignment-expression.

Assignment operators ([1] $5.17)

logical-or-expression assignment-operator assignment-expression
assignment-operator: one of
= = /= Ye += = >>= <<= &= "= |-
This is a cyalue expression whose underlying type is the underlying type of the logical-or-
expression.

Comma operator ([1] $5.18)

expression , assignment-expression
This is a cvalue expression whose underlying type is the underlying type of the assignment-
expression.

Constant expressions ([1] $5.19)

The result is not a cvalue expression. The underlying type for a constant expression “e” with a
value “v” will have the same signedness as “e”, and a magnitude given by the underlying type of

ce?

a single integer-literal with the same value as “v”.

 

60 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 5-0-1 (Required) The value of an expression shall be the same under any
order of evaluation that the standard permits.

 

 

 

[Unspecified 5(4), Undefined 5(4)]
Rationale
Apart from a few operators (notably &&, | |, 7: and , (comma)) the order in which sub-expressions
are evaluated is unspecified and can vary. This means that no reliance can be placed on the order
of evaluation of sub-expressions and, in particular, no reliance can be placed on the order in which
side effects occur. Those points in the evaluation of an expression at which all previous side

effects can be guaranteed to have taken place are called “sequence points”. Sequence points and
side effects are described in Section 1.9(7) of ISO/IEC 14882:2003 [1].

Note that the “order of evaluation” problem is not solved by the use of parentheses, as this is not
a precedence issue.

Example

The following notes give some guidance on how dependence on order of evaluation may occur,
and therefore may assist in adopting the rule.

*_increment or decrement operators
As an example of what can go wrong, consider
x = bI[ 1 ] + i++;
This will give different results depending on whether b[ i ] is evaluated before i++ or

vice versa. The problem could be avoided by putting the increment operation in a separate
statement. For example:

x = bl i ] + i;
++;
*_ function arguments
The order of evaluation of function arguments is unspecified.
x = func( i++, i );
This will give different results depending on which of the function’s two parameters is
evaluated first.
*_ function pointers

If a function is called via a function pointer there shall be no dependence on the order in
which function-designator and function arguments are evaluated.

p->task start fn (p++);
*_ function calls

Functions may have additional effects when they are called (e.g. modifying some global
data). Dependence on order of evaluation could be avoided by invoking the function prior
to the expression that uses it, making use of a temporary variable for the value.

 

61 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

For example
x = f(a) + g(a);
could be written as

x = f{a):

x += g(a);

As an example of what can go wrong, consider an expression to take two values off a stack,
subtract the second from the first, and push the result back on the stack:

push( pop() - pop() );

This will give different results depending on which of the bcp () function calls is evaluated
first (because pop () has side effects).

* _nested assignment statements

Assignments nested within expressions cause additional side effects. The best way to avoid
any possibility of this leading to a dependence on order of evaluation is not to embed
assignments within expressions.

For example, the following is not recommended:

y = 4;
x = y = yt+; // It is undefined whether the final value of y
// is 4 or 5.

+ _ accessing a volatile

The vo/atile type qualifier is provided in C++ to denote objects whose value can change
independently of the execution of the program (for example an input register). If an object
of volatile qualified type is accessed this may change its value. C++ compilers will not
optimize out reads of a volatile. In addition, as far as a C++ program is concerned, a read of
a volatile has a side effect (changing the value of the volatile).

It will usually be necessary to access volatile data as part of an expression, which then means
there may be dependence on order of evaluation. Where possible, though, it is recommended
that volatiles only be accessed in simple assignment statements, such as the following:
volatile uint16 E v;
//
X = V;
The rule addresses the order of evaluation problem with side effects. Note that there may also be
an issue with the number of times a sub-expression is evaluated, which is not covered by this rule.
This can be a problem with function invocations where the function is implemented as a macro.
For example, consider the following function-like macro and its invocation:
#define MAX(a, b) ( ((a) > (b)) ? (a) + (b) )
fo.
z = MAX( i++, 5 );
The definition evaluates the first parameter twice 1f à > & but only once if à < b. The macro
invocation may thus increment i either once or twice, depending on the values of i and ;.

It should be noted that magnitude-dependent effects, such as those due to floating-point rounding,
are also not addressed by this rule. Although the order in which side effects occur is undefined, the
result of an operation is otherwise well-defined and is controlled by the structure of the expression.
In the following example, f1 and £2 are floating-point variables; F3, F4 and F5 denote expressions
with floating-point types.

 

62 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

fl = F3 + ( F4 + F5 );
£2 = (F3 + F4 ) + F5;

The addition operations are, or at least appear to be, performed in the order determined by the
position of the parentheses, 1.e. firstly F4 is added to F5 then secondly F3 is added to give the value
of f1. Provided that F3, F4 and F5 contain no side effects, their values are independent of the order
in which they are evaluated. However, the values assigned to f1 and £2 are not guaranteed to be
the same because floating-point rounding following the addition operations are dependent on the
values being added.

 

Rule 5-0-2 (Advisory) Limited dependence should be placed on C++ operator
precedence rules in expressions.

 

 

 

Rationale

In addition to the use of parentheses to override default operator precedence, parentheses should
also be used to emphasize it. It is easy to make a mistake with the rather complicated precedence
rules of C++, and this approach helps to avoid such errors, and helps to make the code easier to
read. However, too many parentheses can clutter the code and make it unreadable.

Example
The following guidelines are suggested for deciding when parentheses are required:

* _ Parentheses are not required for the right-hand operand of an assignment operator unless
the right-hand side itself contains an assignment expression:
x = a + b; // acceptable
x = (a + b); // () not required
* __ Parentheses are not required for the operand of a unary operator:
x = à * -l; // acceptable

x = à * (-1); // Ù not required

*_ Otherwise, the operands of binary and ternary operators shall be cast-expressions (see
Section 5.4(2) of ISO/IEC 14882:2003 [1]) unless all the operators in the expression are

the same.
x=a+b+c:; // acceptable, but care needed
x=f (a +b, © ); // no () required for à + b
x = ( a == ) ? a : (a - b );
11 (a && b && € ) // acceptable
x= (a+b) -(c+d ):
x= (a * 3 ) + c + d;
x = static cast< uint16 t > ( a } + b; // no need for cast

*_ Even if all operators are the same, parentheses may be used to control the order of
operation. Some operators (e.g. addition and multiplication) that are associative in algebra
are not necessarily associative in C++. Similarly, integer operations involving mixed
types (prohibited by several rules) may produce different results because of the integral
promotions. The following example written for a 16-bit implementation demonstrates
that addition is not associative and that it is important to be clear about the structure of an
expression:

 

63 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

uint16 € a = 1OU;
uint16 t b = 6553SU;
uint32 £ c = OU;
uint32 € d;

d = (à + b) + c; // dis 9; a + b wraps modulo 65536
d=a+(b+c);  // dis 65545
// this example also deviates from several other rules
Note that Rule 5—-2-1 is a special case of this rule applicable solely to the logical operators, &&
and ||.

 

Rule 5-0-3 (Required) À cvalue expression shall not be implicitly converted to
a different underlying type.

 

 

 

Rationale

In order to ensure all operations in an expression are performed in the same underlying type, an
expression defined as a cvalue shall not undergo further implicit conversions.

Example

void € ( )

{
int32 t s32;
int8 € s8;

532 = 58 + 58; // Example 1 -

// Non-compliant
532 = static cast < int32 t > ( s8 ) + s8; // Example 2 - Compliant
532 = 532 + s8; // Example 3 - Compliant

}

In Example 1, the addition operation is performed with an wnderlying type of int8_t and the result
is converted to an wnderlying type of int32 £.

In Examples 2 and 3, the addition is performed with an wnderlying type of int32 f and therefore
no underlying type conversion is required.

 

Rule 5-0-4 (Required) An implicit integral conversion shall not change the
signedness of the #rderlying type.

 

 

 

Rationale

Some signed to unsigned conversions may lead to implementation-defined behaviour. This
behaviour may not be consistent with developer expectations.

Example

void £()

{
int8 € s8;
uint8 € u8;

 

64. Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

58 = uë; // Non-compliant
u8 58 + uë8; // Non-compliant
u8 = static cast< uint8 € > ( s8 } + u8; // Compliant

}

 

Rule 5-0-5 (Required) There shall be no implicit ffoating-integral conversions. |

 

[Undefined 4.9(1)]
Rationale

Conversions from floating point to integral types discard information, and may lead to undefined
behaviour if the floating-point value cannot be represented in the integral type.

Conversions from integral types to floating point types may not result in an exact representation,
which may not be consistent with developer expectations.

Example

void € ( )

{
float32 t f32;
int32 € 532;

532 = £32; // Non-compliant
£32 = 532; // Non-compliant
£32 = static cast< float32 t > ( s32 ); // Compliant

 

Rule 5-0-6 (Required) An implicit integral or floating-point conversion shall
not reduce the size of the underlying type.

 

 

 

[Undefined 4.9(1)]
Rationale

An implicit conversion that results in the size of a type being reduced may result in a loss of
information.

Example

void £ ( )

{
int32 t s32;
int16 t s16;

516 = 532; // Non-compliant
516 = static cast< int16 t > ( 532 }); // Compliant

 

65 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 5—-0-7 (Required) There shall be no explicit floating-integral conversions
of a cvalue expression.

 

 

 

Rationale

A cast applied to the result of an expression does not change the type in which the expression is
evaluated, which may be contrary to developer expectations.

Example

// Integral to Float

void £f1 ( )

{
inti6 t s16a;
inti6 t 516b;
inti6 t 5s16c;
float37 t f32a;

// The following performs integer division
£32a = static cast< float32 t > ( s16a / s16b ); // Non-compliant

// The following also performs integer division
s16c = 516a / 516b:;
£32a = static cast< float32 t > ( sl6c ); // Compliant

// The following performs floating-point division
£32a = static cast< float32 t > ( s16a } / s16b; // Compliant
}

In the above example, the expression ( 516a / s16b ) is performed with an wnderlying type of
int16 t rather than float32 €.

// Float to Integral

void £2 € )

{
float37 t f32a;
float32 + £f32b;
float32 t f32c;
inti6 t s16a;

// The following performs floating-point division
s16a = static cast< int16 t > ( f32a / f32b ); // Non-compliant

// The following also performs floating-point division
£32c = £32a / £32b;
s16a = static cast< int16 t > ( f32c }); // Compliant

// The following performs integer division
s16a = static cast< int16 t > ( f32a } / £32b; // Compliant
}

In the above example, the expression ( f32a / £32b ) is performed with an wnderlying type of
float32 t rather than int16 €.

 

66 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

Rule 5-0-8 (Required) An explicit integral or floating-point conversion shall
not increase the size of the wnderlying type of a cvalue
expression.

Rationale

A cast applied to the result of an expression does not change the type in which the expression is
evaluated, which may be contrary to developer expectations.

Example

void £ ( )
{
int16 t s16;
int32 t s32;
532 = static cast< int32 t > ( 516 + 516 ); // Non-compliant
532 = static cast< int32 t > ( 516 } + s16 ; // Compliant
}

In the above example, the expression ( 516 + s<16 ) is performed with an underlying type of
int16 t rather than int32 €.

 

Rule 5-0-9 (Required) An explicit integral conversion shall not change the
signedness of the underlying type of a cvalue expression.

 

 

 

Rationale

À signed to unsigned conversion may lead to an expression having a value inconsistent with
developer expectations.

Example

void £ ( )

{
int8 € s8;
uint8 € u8;

58 = static cast< int8 t >( u8 + u8 }); // Non-compliant
58 = static cast< int8 € >( u8 )
+ static cast< int8 t >( us ); // Compliant

}

In the above example, the expression ( u8 + u8 }) is performed with an wnderlying type of
uint8 t rather than inte +.

 

Rule 5-0-10 (Required) If the bitwise operators - and << are applied to an
operand with an underlying type of unsigned char or
unsigned short, the result shall be immediately cast to
the underlying type of the operand.

 

 

 

Rationale

When the operators - and -< are applied to small integer types (unsigned char or unsigned short),
the operations are preceded by integral promotion, and the result may unexpectedly contain high
order bits.

 

67 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Exception

The immediate assignment of the result obtained by the use of - or << on an operand of type
unsigned char or unsigned short to an object of the same underlying type complies with this rule
(including use as a function argument or function return value), even though the conversion is
implicit.

Example

uint8 € port = OxsSaU;
uint8 € result 8;
uint16 € result 16;
uint16 t mode;

result 8 = ( -port } >> 4; // Non-compliant
-port is OxffaS on a 16-bit machine but OxffffffaS on a 32-bit machine. In either case the value

of result is Oxfa, but Ox0a may have been expected. This danger is avoided by inclusion of the
cast as shown below:

result 8 = ( static cast< uint8 €? > (-port) ) >> 4 ; // Compliant
À similar problem exists when the << operator is used on snall integer types and high order bits
are retained. For example:

result 16 = ( ( port << 4 ) & mode } >> 6; // Non-compliant

The value in result 16 will depend on the implemented size of an inf. Addition of a cast avoids
any ambiguity.

result 16 -
( static cast < uint16 € > ( static cast< uint16 t > ( port ) << 4 )
& mode )} >> 6; // Compliant

Using intermediate steps would make this clearer:

 

uint16 € port 16 = static cast< uint16 t > ( port );

uint16 € port shifted = static cast< uint16 t > ( port 16 << 4 );

result 16 = ( port shifted & mode } >> 6; // Compliant
Rule 5-0-11 (Required) The plain char type shall only be used for the storage

and use of character values.

 

 

 

[Implementation 3.9.1(1), 7.1.5.2(1)]
Rationale

The char type within C++ is defined for use with the implementation character set. It is
implementation-defined if char is signed or unsigned, and it is therefore unsuitable for use with
numeric data.

Character values consist of character literals or strings. A character set maps text characters onto
numeric values; the character value is the text itself.

Note that Rule 3-92 applies, so this rule also covers the char ftype.

 

68 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

char t a = 'a'; // Compliant

char t b = '\r'; // Compliant

char t © = 10; // Non-compliant

char d = ‘'d'; // Compliant with this rule, but breaks Rule 3-9-2
See also

Rule 3-9-2, Rule 5-0-12

 

Rule 5-0-12 (Required) signed char and unsigned char type shall only be used
for the storage and use of numeric values.

 

 

 

[Implementation 3.9.1(1), 7.1.5.2(1)]
Rationale

There are three distinct char types, (plain) char, signed char and unsigned char. signed char
and unsigned char shall only be used for numeric data and plain char shall only be used for
character data. As it is implementation-defined, the signedness of the plain char type should not
be assumed.

Note that Rule 3-92 also applies, so the uint8 f and int8 f types are covered by this rule.

Example
int8 t a = 'a'; // Non-compliant - explicitly signed
uint8 &t b = '\r'; // Non-compliant - explicitly unsigned
int8 t © = 10; // Compliant
uint8 &t d = 12U; // Compliant
signed char e = 11; // Compliant with this rule, but breaks Rule 3-9-2

See also
Rule 3-92, Rule 5-0-11

 

Rule 5-0-13 (Required) The condition of an if-statement and the condition of an
iteration-statement shall have type bool.

 

 

 

Rationale

If an expression with type other than bool is used in the condition of an if-statement or iteration-
statement, then its result will be implicitly converted to bool. The condition expression shall contain
an explicit test (vielding a result of type boof) in order to clarify the intentions of the developer.

Exception
A condition of the form fype-specifier-seq declarator is not required to have type bool.

This exception is introduced because alternative mechanisms for achieving the same effect are
cumbersome and error-prone.

 

69 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
extern int32 t * fn ( );
extern int32 t fn2 À);
extern bool fn3 ( );
while ( int32t # p = fn ( )) //
{
// Code

}

Compliant by exception

// The following is à cumbersome but compliant example

 

 

 

 

do
{
int32 t * p = fn ( });
if ( NULL == p )
{
break;
}
// Code...
}
while ( true ); // Compliant
while ( int32 & length = fn2 ( ) ) // Compliant by exception
{
// Code
}
while ( bool flag = fn3 ( }) ) // Compliant
{
// Code
}
if ( int32 t * p = fn ( ) ) // Compliant by exception
if ( int32 € length = fn2 ( ) ) // Compliant by exception
if ( bool flag = fn3 ( ) ) // Compliant
if { u8 }) // Non-compliant
if ( u8 && ( bool 1? <= bool 2 ) )}) // Non-compliant
for ( int32 t x = 10; x; --x ) // Non-compliant
Rule 5-0-14 (Required) The first operand of a conditional-operator shall have
type bool.
Rationale

If an expression with type other than bool is used as the first operand of a conditional-operator,
then its result will be implicitly converted to bool. The first operand shall contain an explicit test
(vielding a result of type bool) in order to clarify the intentions of the developer.

Example

int32 a =
int32 a =
int32 a =

int16 b ? int32 c : int32 d;
bool b 7? int32 c : int32 d;

( int16 b < 5 ) ? int32 co

// Non-compliant
// Compliant
int32 d; // Compliant

 

70

Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 5-0-15 (Required) Array indexing shall be the only form of pointer

arithmetic.

 

 

 

Rationale

Array indexing is the only acceptable form of pointer arithmetic, because it is clearer and hence
less error prone than pointer manipulation. This rule bans the explicit calculation of pointer values.
Array indexing shall only be applied to objects defined as an array type.

Any explicitly calculated pointer value has the potential to access unintended or invalid memory
addresses. Pointers may go out of bounds of arrays or structures, or may even point to effectively
arbitrary locations.

Exception

The increment/decrement operators may be used on iterators implemented by pointers to an array.

Example

template < typename IterType >
uint8 € sum values ( IterType iter,

{

IterType end )

uint8 € result = 0;

while ({ l= end )

{

iter

result += *iter;
++iter; // Compliant by exception

}

return result:
}
void my fn ( uint8 t * pl, uint8 t p2{[ ] )
{

uint8 € index = 0;
uint8 € * p3;
uint8 €? * pd;
*pl = 0;
++index};
index = index + 5;
pl = pl + 5; // Non-compliant - pointer increment
pll 5 |] = 0; // Non-compliant - pl was not declared as array
p3 = &plil 5 |]; // Non-compliant - pl was not declared as array
p2t 01] = 0;
p2[ index ] = 0; // Compliant
pd &p2[ ]; // Compliant
}
uint8 € al[ 16 |];
uint8 € a2[ 16 ];
my fn ( al, a2 );
my fn ( &al[ 4 ], &a2[ 4 ] );
uint8 € af 10 |];
uint8 € * p;

 

Licensed to: Insigma Raïl Transport. Engineering Co.

71
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

P = à;

*(p +5) = 0; // Non-compliant

pis] = 0; // Compliant

sum values ( &a1[ 0 ], &a1[ 16 ] );
See also

Rule 0-3-1, Rule 5-0-16

 

Rule 5-0-16 (Required) À pointer operand and any pointer resulting from
pointer arithmetic using that operand shall both
address elements of the same array.

 

 

 

[Undefined 5.7(5)]

Rationale
This rule applies to expressions of the form:

* integer expression + pointer expression

* pointer expression + integer expression

* pointer expression - integer expression

* +tpointer expression

* pointer expression++

* —-pointer expression

* pointer expression--

* pointer expression | integer expression ]

where pointer expression is a pointer to an array element.

Itis undefined behaviour if the result obtained from one of the above expressions is not a pointer
to an element of the array pointed to by pointer expression or an element one beyond the end
of that array.

Example

void F1 ( const int32 t * at )

{
int32 t a2{[ 10 ];

const int32 € * pl = &al [ 1]; // Non-compliant - al not an array
int32 t * p2 = &a2 [| 10 ]; // Compliant
int32 t * p3 = &a2 | 11 ]; // Non-compliant
}

void £2 € )

{
int32 t b;
int32 t c | 10 |];

£1 ( &b );
ÊT (c );

 

72 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

See also
Rule 5-0-15
Rule 5-0-17 (Required) Subtraction between pointers shall only be applied to
pointers that address elements of the same array.
[Undefined 5.7(6)]
Rationale

This rule applies to expressions of the form:

pointer expression 1 - pointer expression 2

where po inter expression 1 and pointe r expression 2are pointers to array elements.

Itis undefined behaviour if pointer expression ? and pointe r expression 2 do not point to
elements of the same array or the element one beyond the end of that array.

Example

void £1 ( )

{
int32 t a1[ 10
int32 t a2[ 10

13
13

 

 

 

 

int32 t * pl = &al [ 1 |];

int32 t * p2 = &a2 [ 10 |];

int32 € diff;

diff = pl - al; // Compliant

diff = p2 - a2; // Compliant

diff = pl - p2; // Non-compliant

}
Rule 5-0-18 (Required) >, >=, <, <= shall not be applied to objects of pointer
type, except where they point to the same array.

Rationale

Attempting to make comparisons between pointers will produce undefined behaviour if the two
pointers do not point to the same object.

Note: it is permissible to address the next element beyond the end of an array, but accessing this
element is not allowed.

 

Licensed to: Insigma Raïl Transport. Engineering Co.

7
3 He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

void f1 ( )

{
int32 t all 10 |];
int32 t a2{[ 10 ];

int32 t * pl = al;

 

if ( pl < al ) // Compliant

{

}

if ( pl < a2 ) // Non-compliant
{

}

}
Rule 5-0-19 (Required) The declaration of objects shall contain no more than

 

two levels of pointer indirection.

 

 

Rationale

Use of more than two levels of indirection can seriously impair the ability to understand the
behaviour of the code, and therefore should be avoided.

Example
typedef int8 t * INTETR;

struct 5 {
int8 t * sl;
int8 t ** s2;
int8 t *** 53;

};

struct s * ps1l;
struct s **  ps2;
struct s ***x ps3;

int8 € ** (  *pfuncl1)();
int8 € ** ( **pfunc2) ();
int8 € ** (***pfunc3) ();
int8 € *** ( *kpfuncd)();
void function( int8 € *
int8 + ++
int + +++
INTETR *
INTETR *
int8 t *
int8 + ++

// Compliant
// Compliant
// Non-compliant

// Compliant
// Compliant
// Non-compliant

// Compliant
// Compliant
// Non-compliant
// Non-compliant

const * const pars,
par6!],
par/1[])

Compliant
Compliant
Non-compliant
Compliant
Non-compliant
Compliant
Non-compliant

 

74 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

int8 t * ptrli; // Compliant
int8 t **  ptr2; // Compliant
int8 t *** ptr3; // Non-compliant
INTPTR * ptrd; // Compliant
INTPTR * const * const ptr5; // Non-compliant
int8 t * ptré6[ 10 ]; // Compliant
int8 t ** ptr7[ 10 ]; // Compliant

Explanation of types
°  par1 and ptr1 are of type pointer to int8 t.
*_ par2 and ptr2 are of type pointer to pointer to int8 t.

*_ par3 and ptr3 are of type pointer to a pointer to a pointer to int8 t. This is three levels
and is non-compliant.

*  pard and ptr4 are expanded to a type of pointer to a pointer to int8 t.

* pars and ptr5 are expanded to a type of const pointer to a const pointer to a pointer to
int8 t. This is three levels and is non-compliant.

*_ par6 is of type pointer to pointer to int8 t because arrays are converted to a pointer to
the initial element of the array.

° ptréis of type pointer to array of inte t.

*_ par7 is of type pointer to pointer to pointer to int8_t because arrays are converted to a
pointer to the initial element of the array. This is three levels and is non-compliant.

° ptr7is of type array of pointer to pointer to int8 t. This is compliant.

 

Rule 5-0-20 (Required) Non-constant operands to a binary bitwise operator
shall have the same wrderlying type.

 

 

 

Rationale

Using operands of the same wnderlyving type documents that it is the number of bits in the final
(promoted and balanced) type that are used, and not the number of bits in the original types of the
expression.

Example

uint8 € mask = +(0x10);
uint16 € value;

value ‘= mask; // Non-compliant

The intent may have been to invert all bits except for bit 5, but the top 8 bits will not have been
inverted.

 

75 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 5-0-21 (Required) Bitwise operators shall only be applied to operands of
unsigned underlying type.

 

 

 

[Implementation 5.8(3)]
Rationale

Bitwise operations (+, <<, <<=, >>, >>=, &, &=, ”, "=, | and |=) are not normally meaningful
on signed integers or enumeration constants. Additionally, an implementation-defined result is
obtained if a right shift is applied to a negative value.

Example
if ( ( uint16 a & int16 b ) == 0x1234U ) // Non-compliant
if ( ( uint16 a | uint16 b ) == 0x1234U ) // Compliant
if ( -int16 a == 0x1234U ) // Non-compliant
if ( -uint16 à == 0x1234U ) // Compliant

6.5.2 Postfix expressions

 

Rule 5-2-1 (Required) Each operand of a logical && or | | shall be a
postfix-expression.

 

 

 

Rationale

The effect of this rule is to require that operands are appropriately parenthesized. Parentheses are
important in this situation both for readability of code and for ensuring that the behaviour is as the
developer intended.

Exception

Where an expression consists of either a sequence of only logical && or a sequence of only logical
||, extra parentheses are not required.

Example
if ( x == 0 && ishigh ) // Non-compliant
LE (x == ) && ishigh ) // Compliant
if (x || y || Zz ) // Compliant by exception,
// if x, y and z bool

if (x || y && z ) // Non-compliant
if (x || (y 8& z }) ) // Compliant
if (x && !y ) // Non-compliant
if (x && ( !y ) ) // Compliant
if ( is odd( y } && x ) // Compliant
11 { {x > cl ) && ( y > c2 ) && ( z > c3 ) ) // Compliant -

// exception
11 { {x > cl ) && {y > c2 ) || ( z > ce3 ) ) // Non-compliant
if Ç (x > el ) 688 ( (y > e2 ) || {z > e3 ) ) ) // Compliant as

// extra() used

Note that this rule is a special case of Rule 5-02.

 

76 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 5-22 (Required) A pointer to a virtual base class shall only be cast to a
pointer to a derived class by means of dynamic cast.

 

 

 

[Undefined 5.2.9(5, 8)]
Rationale

Casting from a virtual base to a derived class, using any means other than dynamic cast has
undefined behaviour. The behaviour for dynamic cast is defined.

Example
class B { ... };
class D: public virtual B { ... };
D d;
B *pB = &d;
D *pD = static cast<D*>(pB); // Non-compliant - undefined behaviour
D *pD2 = dynamic cast<D*>(pB); // Compliant, but pD2 may be NULL
D & D3 = dynamic cast<De>(*pB); // Compliant, but may throw an exception

 

Rule 5-2-3 (Advisory) Casts from a base class to a derived class should not be
performed on polymorphic types.

 

 

 

Rationale
À downcast occurs when a class type is converted to another class type that is derived from that
first class.

Polymorphism enables strong abstraction between the interface and implementation of a
hierarchy. Explicit casts bypass this layer of abstraction resulting in higher levels of coupling and
dependency.

 

Example

class Colour { /* ,.., */ };
void setColour ( Colour const & );
class Obj
{
public:

virtual bool hasColour ( ) const = 0;

virtual Colour getColour ( ) const = O0;
};

77 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

class ObjWithColour : public Obj

{
public:
virtual bool hasColour ( ) const

{

return true;

}

virtual Colour getColour ( ) const

{

return m colour;

}
private:
Colour m colour;
};
void badPrintObject ( Obj const & ob )

{
ObjWithColour const * pOb] =

dynamic cast<ObiWithColour const*>( &ob]j }); // Non-compliant
if ( O0 != pOb]j )
{

setColour ( pObj->getColour ( ) );

}

void goodPrintObject ( Obji const & ob) )

{
if ( obj.hasColour ( ) )
{
setColour ( obj.getColour ( ) );
}
}

The function badPrintObject now requires knowledge of how objects in the ©b; hierarchy
are structured. In the future, the hierarchy may be changed so that objects are split into specific

colours, and any clients dependent on the colour will then have to be modified to include this
change. Clients using virtual functions however, will remain unchanged.

 

Rule 5-2-4 (Required) C-style casts (other than void casts) and functional
notation casts (other than explicit constructor calls)
shall not be used.

 

 

 

Rationale

C-style (cast notation), and functional notation casts that do not invoke a converting constructor
are capable of performing casts between unrelated types.

Exception

A C-style cast to void may be used to signify that the return value for a non-void function call is
being ignored (see Rule 0-17).

 

78 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

class À
{
public:
explicit A( int32 € );
};
int32 t g ( )
{

return 7;

}

void € ( )
{
À const ai = A( 10 }); // Compliant
A * a2 = ( AY )j({ &al ); // Non-compliant
A * a3 = const cast<A*>( &al ); // Compliant, but breaks Rule 5-2-5
{(void)g ( ); // Compliant by exception

}

In the above example, the C-style cast from 21 to a non-const pointer is stronger than necessary.
If the type of a1 is changed at some future date, then the cast may continue to compile.

See also
ISO/IEC 14882:2003 [1] $5.2.3, $5.4

 

Rule 5-2-5 (Required) A cast shall not remove any const or volatile
qualification from the type of a pointer or reference.

 

 

 

[Undefined 7.1.5.1(4, 7)]
Rationale

Removal of the const or volatile qualification may not meet developer expectations as it may lead
to undefined behaviour.

Example
void f ( const char t * bp)
{
*const cast< char t * >( p ) = "\0'; // Non-compliant

}

int main ( )
{

f { "Hello World!" );
}

 

79 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 5-2-6 (Required) À cast shall not convert à pointer to a function to any
other pointer type, including à pointer to function type.

 

 

 

[Undefined 5.2.10(6), Unspecified 5.2.10(6)]
Rationale
Conversion of a function pointer to a non-function pointer type causes undefined behaviour.

Undefined behaviour may arise if a function call is made using a pointer that is the result of à
function pointer conversion.

Example

void f ( int32 € )

{
reinterpret cast< void (*)( ) >( &f }; // Non-compliant
reinterpret cast< void * >( &f ); // Non-compliant

 

Rule 5-2-7 (Required) An object with pointer type shall not be converted to an
unrelated pointer type, either directly or indirectly.

 

 

 

[Unspecified 5.2.10(7)]
Rationale
The result of converting from a pointer to an unrelated type is unspecified.

Example

struct $S
{
int32 € i;
int32 t j;
};
class C
{
public:
int32 € i;
public: _
int32 € j;
virtual <C Co);
};
void f (S *s )
C * © = reinterpret cast< C * >( 5 ); // Non-compliant

int32 t i = reinterpret cast< int32 t >( s }; // Compliant, but
// breaks Rule 5-2-9

 

C * d = reinterpret cast< C * >{ i ); // Non-compliant
S * e = reinterpret cast< S * >{ i ); // Compliant, but
// breaks Rule 5-2-8
}
80 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 5-2-8 (Required) An object with integer type or pointer to void type shall
not be converted to an object with pointer type.

 

 

 

[Unspecified 5.2.10(7)]
Rationale

In general, converting from an integral type or a pointer to void type to a pointer to an object leads
to unspecified behaviour.

 

 

 

 

Example
struct $S
{
int32 € i;
int32 € j;
};
void f ( void * v, int32 € i )
{
S * s1 = reinterpret cast< S * >( v }); // Non-compliant
S * 52 = reinterpret cast< S * >( i }; // Non-compliant
}
Rule 5-2-9 (Advisory) À cast should not convert a pointer type to an integral
type.
[Implementation 5.2.10(4, 5)]
Rationale

The size of integer that is required when a pointer is converted to an integer is implementation-
defined. Casting between a pointer and an integer type should be avoided where possible, but may
be unavoidable when addressing memory mapped registers or other hardware specific features.

Note that C++ does not permit a pointer to be converted to any floating type.

Example

struct $S
{
int32 € i;
int32 t j;
};
void f (S *s )
{
int32 t p = reinterpret cast< int32 t >(s ); // Non-compliant
}

 

81 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

Rule 5-2-10 (Advisory) The increment (++) and decrement (--) operators
should not be mixed with other operators in an
expression.

Rationale

The use of increment and decrement operators in combination with other arithmetic operators is
not recommended, because:

*_ It can significantly impair the readability of the code.
* It introduces additional side effects into a statement, with the potential for undefined
behaviour.

It is safer to use these operators in isolation from any other arithmetic operators.

Example
A statement such as the following is non-compliant:
usa = ++u8b + uBc--; // Non-compliant

The following sequence is clearer and therefore safer:

++u8b;
uB8a = u8b + uë8c;
uBsc--};

See also
ISO/IEC 14882:2003 [1] $5.2.6, $5.3.2

 

Rule 5-2-11 (Required) The comma operator, && operator and the | | operator
shall not be overloaded.

 

 

 

Rationale

Overloaded versions of the comma and logical conjunction operators have the semantics of
function calls whose sequence point and ordering semantics are different from those of the built-
in versions. It may not be clear at the point of use that these operators are overloaded, and s0
developers may be unaware which semantics apply.

Example
#include "util.h"
class À
{
public:
UtilType getValue ( );

UtilType setValue ( UtilType const & );
};
void fl (A & al, À & a2 )

{
al.getValue ( ) && a2.setValue ( 0 ); // Short circuiting may occur

}

 

82 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

bool operator && ( UtilType const &,
UtilType const & ); // Non-compliant
void £2 ( A & al, À & a2 )

{
al.getValue ( } && a2.setValue ( O0 ); // Both operands evaluated
}

Ifthe type returned by get Value and set Value has an overloaded operator &£, then both getvalue
and setValue will be evaluated.

See also
ISO/IEC 14882:2003 [1] 85.14, 85.15. $5.18

 

Rule 5-2-12 (Required) An identifier with array type passed as a function
argument shall not decay to a pointer.

 

 

 

Rationale
When a variable with array type decays to a pointer, its bounds are lost.

If a design requires arrays of different lengths, then a class should be used to encapsulate the array
objects and so ensure that the dimensionality is maintained.

Example
void f1( int32 € pl 10 ] );
void f2( int32 t *p );
void £3( int32 t ( &p )[ 10 ] });
void b ()

{
int32 t a[ 10 ];

fit a ); // Non-compliant - Dimension "10" lost due to array to
// pointer conversion.
f2( a ); // Non-compliant - Dimension "10" lost due to array to

// pointer conversion.
£f3{ a ); // Compliant - Dimension preserved.

6.5.3 Unary expressions

 

Rule 5-3-1 (Required) Each operand of the ! operator, the logical && or the
logical | | operators shall have type bool.

 

 

 

Rationale

The use of operands with types other than boo! with these operators is unlikely to be meaningful
(or intended). This rule allows the detection of such uses, which often occur because the logical
operators (&&, | | and !) can be easily confused with the bitwise operators (&, | and -).

 

83 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
if {{a<b}) && (cc < da }) ) // Compliant
11 {188 (c< da) ) // Non-compliant
if {{a<b}) && (cc + da } ) // Non-compliant
if ( u8 a && ( c + d ) ) // Non-compliant
1f € !0O ) // Non-compliant -
// also breaks other rules
if ( lptr ) // Non-compliant
if { !lfalse ) // Compliant with this rule,
// but breaks others
See also

ISO/IEC 14882:2003 [1] $5.14, $5.15

 

Rule 5-3-2 (Required) The unary minus operator shall not be applied to an
expression whose #nderlying type is unsigned.

 

 

 

Rationale

Applying the unary minus operator to an expression of type unsigned int, unsigned long or
unsigned long long generates a result of type unsigned int, unsigned long or unsigned long long
respectively and is not a meaningful operation. Applying unary minus to an operand of smaller
unsigned integer type may generate a meaningful signed result due to integral promotion, but this
is not considered good practice.

Example
On a machine with a 32-bit inf type:

uint8 € a = -1U; // Non-compliant — a is assigned 255

int32 t b= -a; // Non-compliant - b is assigned -255

uint32 € © = 1U;

int6d t d = -c; // Non-compliant - d is assigned MAX UINT
See also

See Section 6.5.0 for a description of underlyving type.

 

Rule 5-3-3 (Required) The unary & operator shall not be overloaded. |
[Undefined 5.3.1(4)]

 

Rationale

Taking the address of an object of incomplete type where the complete type contains a user
declared operator « leads to undefined behaviour.

Example

// Ah
class À
{
public:
A * operator & ( }); // Non-compliant
};

 

84 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

// fl.cc

class A;

void f (A & a )
{

&a; // uses built-in operator &

}

// f2.cc
#include "A.n"

void f2 { A & a )
{
&a; // use user-defined operator &

}

See also
ISO/IEC 14882:2003 [1] $5.3.1(4)

 

Rule 5-3-4 (Required) Evaluation of the operand to the sizeof operator shall
not contain side effects.

 

 

 

Rationale

À possible programming error in C++ is to apply the sizeof operator to an expression and expect
the expression to be evaluated. However, the expression is not evaluated as sizeof only acts on
the type of the expression. To avoid this error, sizeof shall not be used on expressions that would
contain side effects if they were used elsewhere, as the side effects will not occur.

Exception

An operand of the form sizeof ( i ) where i is volatile is permitted.

Example
int32 € i;
int32 € j;
volatile int32 € k;
j = sizeof( i = 1234 ); // Non-compliant - j is set to the sizeof the
// type of i which is an int32 €.

// i is not set to 1234.
j = sizeof ( k }); // Compliant by exception.

See also
ISO/IEC 14882:2003 [1] $3.2(2)

 

85 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.5.8 Shift operators

 

Rule 5-8-1 (Required) The right hand operand of a shift operator shall lie
between zero and one less than the width in bits of the
underlying type of the left hand operand.

 

 

 

[Undefined 5.8(1)|
Rationale

Itis undefined behaviour if the right hand operand is negative, or greater than or equal to the width
of the left hand operand.

If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is
important to ensure that this is shifted only by a number between 0 and 15 inclusive.

There are various ways of ensuring that this rule is followed. The simplest is for the right hand
operand to be a constant (whose value can then be statically checked). Use of an unsigned integer
type will ensure that the operand is non-negative, so then only the upper limit needs to be checked
(dynamically at run time or by review). Otherwise both limits will need to be checked.

Example
u8a = (uint8 t) ( u8a << 7 }; // Compliant
u8a = (uint8 t) ( u8a << 9 }; // Non-compliant
u16a = (uint16 t)( (uint16 t} u8a << 9 ); // Compliant
See also

See Section 6.5.0 for a description of underlyving type.

6.5.4 Logical AND operator

 

Rule 5-14-1 (Required) The right hand operand of a logical && or | | operator
shall not contain side effects.

 

 

 

Rationale

There are some situations in C++ where certain parts of expressions may not be evaluated. If these
sub-expressions contain side effects then those side effects may or may not occur, depending on
the values of other sub expressions.

The operators which can lead to this problem are && and | | where the evaluation of the right-
hand operand is conditional on the value of the left-hand operand. The conditional evaluation of
the right-hand operand of one of the logical operators can easily cause problems if the developer
relies on a side effect occurring.

Example
if ( ishigh &8& ( x == i++ ) ) // Non-compliant
if ( ishigh &8& ( x == f( x } }) ) // Only acceptable if f(x) is

// known to have no side effects

 

86 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

The operations that cause side effects are accessing a volatile object, modifying an object,
modifying a file, or calling a function that does any of those operations, which cause changes in
the state of the execution environment of the calling function.

See also
Rule 5—2-11
ISO/IEC 14882:2003 [1] 83.22), $5.14, 85.15

6.517 Assignment operators

 

Rule 5-17-1 (Required) The semantic equivalence between a binary operator
and its assignment operator form shall be preserved.

 

 

 

Rationale

Where a set of operators is overloaded, it is important that the interactions between the operators
meet developer expectations.

Example
class À
{
public:
A& operator= ( À const & rhs );
};
À & operator += ( À const & lhs, À const & rhs });
À const operator + ( À const & lhs, À const & rhs );

void £ ( A al, À a2 )
{

A x;

x = al + a2; // Example 1
al += a2; // Example 2
1f (x == al ) // Example 3

{
}
}
For a built-in type, the results of Example 1 and Example 2 will be the same, therefore the condition
in Example 3 should always be true. This should also be true for overloaded versions of these
operators.

6.518 Comma operator

 

Rule 5-18-1 (Required) The comma operator shall not be used.

 

Rationale

Use of the comma operator is generally detrimental to the readability of code, and the same effect
can be achieved by other means.

 

87 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

£C(C1, 2), 3 }); // Non-compliant - how many parameters?

6.519 Constant expressions

 

Rule 5-19-1 (Advisory) Evaluation of constant unsigned integer expressions
should not lead to wrap-around.

 

 

 

Rationale

Unsigned integer expressions do not strictly overflow, but instead wrap around in a modular way.
Any constant unsigned integer expressions that in effect “overflow” will not be detected by the
compiler. Although there may be good reasons at run-time to rely on the modular arithmetic
provided by unsigned integer types, the reasons for using it at compile-time to evaluate a constant
expression are less obvious. Any instance of an unsigned integer constant expression wrapping
around is therefore likely to indicate a programming error.

This rule applies equally to all phases of the translation process. Constant expressions that the
compiler chooses to evaluate at compile time are evaluated in such a way that the results are identical
to those that would be obtained by evaluation on the target, with the exception of those appearing in
conditional preprocessing directives. For such directives, the usual rules of arithmetic apply but the
int and unsigned int types behave instead as if they were /ong and unsigned long respectively.

Example

On a machine with a 16-bit inf type and a preprocessor using a 32-bit long type:
#define START 0x8000

#define END OXFFFF

#define LEN 0x8000

#if ( ( START + LEN ) > END )

#error Buffer Overrun // OK as START and LEN are unsigned long
#endif

#if ( ( ( END - START ) - LEN } < O0 )

#error Buffer Overrun
// Not OK: subtraction result wraps around to OxFFFFFFEFF

#endif
// contrast the above START + LEN with the following
void fn { )
{
if ( { START + LEN ) > END )
{
error ( "Buffer overrun" )};

// Not OK: START + LEN wraps around to 0x0000 due to unsigned int
// arithmetic

 

88 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.6 Statements
6.6.2 Expression statement

 

Rule 6-2-1 (Required) Assignment operators shall not be used in sub-
expressions.

 

 

 

Rationale

Assignments used in a sub-expression add an additional side effect to that of the full expression,
potentially resulting in a value inconsistent with developer expectations. In addition, this helps to
avoid getting = and == confused.

 

 

 

 

Example
X = y;
X = Y = Z; // Non-compliant
1f { x != 0 ) // Compliant
{
foo ( );
}
bool b1 = x != y; // Compliant
bool b2;
b2 = x != y; // Compliant
if Ç( (x = y ) != 0 ) // Non-compliant
{
foo ( );
}
1f {x Y ) // Non-compliant
{
foo ( );
}
if ( int16 t i = foo ( )} } // Compliant
{
}
Rule 6-2-2 (Required) Floating-point expressions shall not be directly or
indirectly tested for equality or mequality.
Rationale

The inherent nature of floating-point types is such that comparisons of equality will often not
evaluate to true, even when they are expected to. Also, the behaviour of such a comparison cannot
be predicted before execution, and may well vary from one implementation to another.

The recommended method for achieving deterministic floating-point comparisons is to write
a library that implements the comparison operations. The library should take into account the
floating-point granularity (std::numeric limits<float-::epsilon()) and the magnitude of the
numbers being compared.

 

89 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

The result of the test in the following code is unpredictable:
float32 t x, y;

if (x == y ) // Non-compliant
if ( x == 0.0f )} // Non-compliant
An indirect test is equally problematic and is also prohibited by this rule:
if Ç(x <= y) 88 (x >= y ) ) // Non-compliant
if ÇCx<v) Il Cx > y) ) // Non-compliant

The following is better, but only if the magnitudes are appropriate:

if ( fabs ( x —- y ) <=
std::numeric limits<float>-::epsilon( ) ) // Compliant

 

Rule 6-2-3 (Required) Before preprocessing, à null statement shall only occur
on a line by itself; it may be followed by a comment,
provided that the first character following the null
statement is a white-space character.

 

 

 

Rationale

Null statements should not normally be included deliberately, but where they are used, they shall
appear on a line by themselves. White-space characters may precede the null statement to preserve
indentation. If a comment follows the null statement, then at least one white-space character shall
separate the null statement from the comment. The use of a white-space character to separate the
null statement from any following comment is required on the grounds that it provides an important
visual cue to reviewers. Following this rule enables a static checking tool to warn of null statements
appearing on a line with other text, which would normally indicate à programming error.

Example

while ( ( port & 0x80 ) == )
{
; // wait for pin - Compliant
/* wait for pin */ ; // Non-compliant, comment before ;
;:// wait for pin - Non-compliant, no white-space char after ;

6.6.3 Compound statement

 

 

 

 

Rule 6-3-1 (Required) The statement forming the body of a switch, while,
do … while or for statement shall be a compound
statement.

Rationale

If the bodies of these statements are not compound statements, then errors can occur if a developer
fails to add the required braces when attempting to change a single statement body to a multi-
statement body.

Requiring that the body of a switch statement or a while, do … while or for loop shall be a compound
statement (enclosed within braces) ensures that these errors cannot arise.

 

90 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
for ( i = O0; i N ELEMENTS; ++i )
{ // Compliant
buffer [ 1 ] = 0: // Even a single statement must
// be in braces
}
for ( 1 = 0; 1 N ELEMENTS; ++i ); // Non-compliant
// Accidental single null statement
{
buffer [ i ] = 0;
}
while ( new data available ) // Non-compliant
process data ( ); // Incorrectly not enclosed in braces
service watchdog ( ); // Added later but, despite the appearance

// (from the indent) it is actually not
// part of the body of the while statement,
// and is executed only after the loop has

// terminated

Note that this example assumes a particular style for the layout of compound statements and their
enclosing braces. This style is not mandated, but a style should be defined within the style guide

for the project.

6.6.4 Selection statements

 

 

 

 

Rule 6—4-1 (Required) An if (condition) construct shall be followed by
a compound statement. The e/se keyword shall be
followed by either a compound statement, or another if
statement.
Rationale

If the bodies of these constructs are not compound statements, then errors can occur if a developer
fails to add the required braces when attempting to change a single statement body to a multi-
statement body.

Requiring that the body of these constructs shall be a compound statement (enclosed within braces)
ensures that these errors cannot arise.

 

Example

1f ( testl ); // Non-compliant - accidental single null statement
{

x = 1;
}
if ( testl )
{

x = 1; // Compliant - à single statement must be in braces
}
else 1f ( test2 ) // Compliant - no need for braces between else and if
{

x = 0; // Compliant - à single statement must be in braces
}

91 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

else // Non-compliant
x = 3; // This was (incorrectly) not enclosed in braces
y = 2; // This line was added later but, despite the

// appearance (from the indent) it is actually not
// part of the else, and is executed unconditionally

Note that this example assumes a particular style for the layout of compound statements and their
enclosing braces. This style is not mandated, but a style should be defined within the style guide
for the project.

 

Rule 6-4-2 (Required) AII if … else if constructs shall be terminated with an
else clause.

 

 

 

Rationale

When an jfstatement is followed by one or more else if statements then the final e/se if shall be followed
by an else statement. In the case of a simple ifstatement the e/se statement need not be included.

The final efse statement, which should either take appropriate action or contain a suitable comment
as to why no action is taken, is defensive programming.

Example

For example this code is a simple if statement:

if { x < 0 )

{
log error( 3 );
x = 0;

}

// else not needed

Whereas the following code demonstrates an if, else if construct

if (x < 0 )

{
log error (3 );
x = O0;

}

else if ( y < 0 )

else // this else clause is required, even if the
{ // developer expects this will never be reached
// No change in value of x

}

 

Rule 6—4-3 (Required) À switch statement shall be a well-formed switch
statement.

 

 

 

À well-formed switch statement conforms to the following syntax rules, which are additional
to the C++ standard syntax rules. All syntax rules not defined below are as defined in
ISO/IEC 14882:2003 [1].

 

92 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

switch-statement:

switch (condition) ! case-label-clause-list default-label-clause,, }

É
case-label-clause-list:
case-label case-clause, ,

case-label-clause-list case-label case-clause,, ,

case-label:
case constant-expression :

case-clause :
case-block-seq,, break ;
case-block-seq … throw assignment-expression
opt Op:
{ stalement-seq,,, break ; }
{ statement-seg : throw assignment-expression … ;
opt Opi

s;
default-label-clause:
default-label default-clause

default-label:
default :

#7

}

default-clause:
case-clause

case-block:
expression statement
compound_statement
selection statement
iteration statement
try_block

case-block-seq:
case-block
case-block-seq case-block

The following statements, which are permitted by C++, are explicitly not included within the
MISRA C++ switch syntax rules. Note, however, that they are permitted within the compound
statements forming the body of a switch-clause.

labelled statement
jump_statement
declaration statement

The following terms are also used within the text of the rules:

switch-label  Either a case-label or default-label.

case-clause The code between any two swifch-labels.

default-clause The code between the default-label and the end of the switch statement.
switch-clause  Either a case-clause or a default-clause.

Rationale

The syntax for the switch statement in C++ is weak, allowing complex, unstructured behaviour.
The previous text describes the syntax for switch statements as defined by MISRA C++. This, and
the associated rules, imposes a simple and consistent structure on to the switch statement.

 

93 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

Example
switch ( x )
{
case O0:
break; // break is required here
case 1: // empty clause, break not required
case 2:
break; // break is required here
default: // default clause is required
break; // break is required here, in case a future
// modification turns this into a case clause
}

Rule 6-4-4 (Required) À switch-label shall only be used when the most closely-
enclosing compound statement is the body of a swifch
statement.

Rationale

À switch-label can be placed anywhere within the statements that form the body of a switch
statement, potentially leading to unstructured code. To prevent this from happening, the scope
of a case-label or default-label shall be the compound statement forming the body of a switch
statement. All case-clauses and the default-clause shall be at the same scope.

Example

switch ( x )
{
case 1: // Compliant
if ( ... )
{
case 2: // Non-compliant
DoIt ( );
}
break;
default:
break;

 

Rule 6—4-5 (Required) An unconditional row or break statement shall
terminate every non-empty swifch-clause.

 

 

 

Rationale

If a developer fails to add a break statement to the end of a switch-clause, then control flow “falls”
into any following switch-clause. Whilst this is sometimes intentional, it is often an error.

To ensure that such errors can be detected, the last statement in every switch-clause shall be a
break statement, or if the switch-clause is a compound statement, then the last statement in the
compound statement shall be a break statement.

À special case exists if the swifch-clause is empty, as this allows groups of clauses requiring
identical statements to be created.

 

94 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

switch ( x )
{
case O0:
break;
case 1:
case 2:
break;
case 3:
throw;
case 4:
a = b;

default:

f

}

//

//

Compliant
Compliant - empty drop through

allows à group
Compliant
Compliant
Non-compliant - non empty drop through

Non-compliant - default must also have "break"

 

Rule 6-4-6 (Required)

 

The final clause of a swich statement shall be the
default-clause.

 

 

Rationale

The requirement for a final default-clause is defensive programming. This clause shall either take
appropriate action, or else contain a suitable comment as to why no action is taken.

Exception

If the condition of a switch statement is of type enum, and all the enumerators are listed in case
labels, then the default-clause is not required as the rules associated with erums are intended to
ensure that the erum cannot be assigned values outside of its set of enumerators. Note that it may
still be appropriate to include a default-clause for the purpose of defensive programming.

Example

switch ( int16
{
case O0:
break;
case 1:
case 2:
break;

}

// Non-compliant - default clause is required.

enum Colours { RED, BLUE, GREEN } colour;

 

switch ( colour )
{
case RED:
break;
case GREEN:
break;
// Non-compliant - default clause is required.
}
95 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

switch ( colour )
{
case RED:
break;
case BLUE:
break;
case GREEN:
break;
// Compliant - exception allows no default in this case

 

Rule 6-47 (Required) The condition of a switch statement shall not have bool
type.

 

 

 

Rationale

An jf statement gives a clearer representation for a Boolean choice.

 

 

 

 

Example
switch { x == ) // Non-compliant
{
}
Rule 6-4-8 (Required) Every switch statement shall have at least one case-
clause.
Rationale

À switch statement with no case-clauses is redundant.

Example

switch ( x )
{
// Non-compliant
default:
break;

 

96 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.6.5  lteration statements
The for statement

ISO/IEC 14882:2003 [1] $6.5.3 states:
The for statement

for ( for-init-statement condition expression, ) statement

opt ?
is equivalent to:
{
for-init-statement
while ( condition, )
{
statement

EXpressIO,,, ;

}

So, it can be seen that the /or loop in C++ is in effect an alternative syntax for a while loop.
Because of this, it is possible that an unbounded loop can be created in error. The following rules
are designed to reduce the risk of this occurring.

The rules make use of the following definitions:

*_ A loop-control-variable is any variable occurring in for-init-statement, condition or
expression.

*_ À loop-counter is a loop-control-variable that is:
(a) Initialized in, or prior to, for-init-statement, and
(b) an operand to a relational operator in condition; and
(c) modified in expression.

Note that iterators are also valid /oop-counters. As an iterator may be a class type, any operator
referenced in the following rules may be an overloaded operator.

 

Rule 6-5-1 (Required) A for loop shall contain a single /oop-counter which
shall not have floating type.

 

 

 

Rationale

À for loop without exactly one /oop-counter is simply a while loop. If this is the desired behaviour,
then a while loop is more appropriate.

Example
y = 0;
for (x = 0; x < y; x = y++ ) // Non-compliant

 

97 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 6-5-2 (Required) If /oop-counter is not modified by -- or ++, then, within
condition, the loop-counter shall only be used as an
operand to <=, <, > or >=.

 

 

 

Rationale

When the /oop-counter is modified using an operator other than -- or ++, then == and != shall notbe
used, as loop termination may not occur, which may be inconsistent with developer expectations.

 

 

 

 

Example
for ( 1 ls 1 f= 10; 1 += 2 ) // Non-compliant
for ( 1= 1; 1 <= 10; 1 += 2 ) // Compliant
for (1 = 1; 1 != 10; ++1 ) // Compliant
Rule 6-5-3 (Required) The /00p-counter shall not be modified within condition
or statement.
Rationale

Modification of the /o0p-counter other than in expression leads to a badly-formed for loop.

Example

bool modify ( int32 £ * EX )
{

 

 

 

 

*pX++;
return ( *pX < 10 );
}
for ( x = 0; modify ( &x )}; ) // Non-compliant
{
}
for (x = 0; x < 10; )
{
X = x * 2; // Non-compliant
}

Rule 6-5-4 (Required) The /00p-counter shall be modified by one of: --, ++,
-=n, Or +=n; Where n remains constant for the duration
of the loop.

Rationale

This helps to ensure deterministic loop termination. The other for loop rules mean that the
modification can only take place within expression.

 

98 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

Example
for (x = 0; x < 107 ++x ) // Compliant
for ({ T x = thing.start( );
x != thing.end( );
++x ) // Compliant
for (x = 0; x < 107; x += 1 ) // Compliant
for (x = 0; x < 10; x += n ) // Compliant if n is not modified
// within the body of the loop.
for (x = 0; x < 10; x += fn ( ) ) // Non-compliant
Rule 6-5-5 (Required) A loop-control-variable other than the loop-counter shall
not be modified within condition or expression.
Rationale

loop-control-variables are either the /oop-counter, or flags used for early loop termination. The
code is easier to understand if these are not modified within condition or expression.

Note that it is possible for a loop-control-variable with vo/atile qualification to change value (or
have it changed) outside statement due to the volatile nature of the object. Such modification does

not break this rule.

Example
for (x = 0; ( x < 10 ) && lbool a; ++x
{
if ( )
{
bool a = true;
}
}
bool test a ( bool * pB )
{
*pB = ? true false};

return *pB;

}

for (
&& test a ( &bool a });
++x

volatile bool status;

)

// Compliant

// Non-compliant

 

for (x = 0; ( x < 10 } && status; ++x) // Compliant
for ( x = 0; x < 10; bool à = test( ++x ) ) // Non-compliant
99 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 6-5-6 (Required) A loop-control-variable other than the /oop-counter
which is modified in statement shall have type bool.

 

 

 

Rationale

loop-control-variables are typically used to terminate à for loop early. The code is easier to
understand if this is done with the use of Boolean values (flags).

 

Example
for (x = 0; ( x < 10 )} && ( u8a != 3U ); ++x ) // Non-compliant
{
uint8 a = fn ( );
}
for {x = 0; ( x < 10 ) && flag; ++x ) // Compliant
{
u8a = fn ( )};
flag = u8a != 3U;
}
6.6.6 Jump statements
Rule 6-6-1 (Required) Any label referenced by a gofo statement shall be

declared in the same block, or in a block enclosing the
goto statement.

 

 

 

Rationale

Unconstrained use of gofo can lead to programs that are extremely difficult to comprehend, analyse
and, for C++, can also lead to the program exhibiting unspecified behaviour.

However, in many cases a total ban on gofo requires the introduction of flags to ensure correct
control flow, and it is possible that these flags may themselves be less transparent than the gofo
they replace.

Therefore, the restricted use of gofo is allowed where that use will not lead to semantics contrary
to developer expectations. Jumping in to nested blocks is prohibited as it may lead to complex
flow graphs.

Example

void £1 ( )
{
int32 t j = 0;
goto Li;
for ( ji = 0; j < 10 ; +43 )
{
L1: // Non-compliant

 

100 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

void £2 ( )
{
for ( int32 € j = 0; j < 10 ; ++i )
{
for ( int32 t i = 0; i < 10; ++i )
{

 

goto Li;
}
}
L1: // Compliant
£T ();
}
Rule 6-6-2 (Required) The gofo statement shall jump to a label declared later

 

 

in the same function body.

 

Rationale

Unconstrained use of gofo can lead to programs that are extremely difficult to comprehend, analyse
and, for C++, can also lead to the program exhibiting unspecified behaviour.

However, in many cases a total ban on gofo requires the introduction of flags to ensure correct
control flow, and it is possible that these flags may themselves be less transparent than the gofo
they replace.

Therefore, the restricted use of gofo is allowed where that use will not lead to semantics contrary
to developer expectations. “Back” jumps are prohibited as they can be used to create iterations
without using the well-defined iteration statements supplied by the core language.

Example

void £ ( )

{
int32 t j = 0;

 

 

 

 

L1:
++);
if ( 10 == 5 )
{
goto L2; // Compliant
}
goto Lil; // Non-compliant
L2:
++);
}
Rule 6-6-3 (Required) The continue statement shall only be used within a well
formed for loop.
Rationale

Over-use of the confinue statement can lead to unnecessary complexity within the code. This
complexity may impede effective testing as extra logic must be tested. The required testing may
not be achievable due to control flow dependencies.

À well-formed for loop is one which satisfies Rule 6—-5-1 to Rule 6-56.

 

101 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Example
void fn { )
{
for ( int32 t i = 0 ; i l= 10; ++i)
{
if ( (132) — )
{
continue; // Compliant
}
//
}
int32 t j = -1;
for ( int32t i = 0 ; À f= 10 88 j l= i; ++i )
{
if ( (132) — )
{
continue; // Non-compliant - loop is not well-formed
}
//
++;
}
}
Rule 6-6-4 (Required) For any iteration statement there shall be no more than

 

 

one break or goto statement used for loop termination.

 

Rationale

Restricting the number of exits from a loop is done in the interests of good structured programming.
One break or goto statement is acceptable in a loop since this allows, for example, for dual outcome
loops or optimal coding.

Example
for ( int32 t i = 0; i < 10; i++ )

break; // Compliant

break; // Compliant

 

102 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

for ( int32 t i = 0; i < 10; i++ )

 

 

 

 

if ( )
{
break;
}
else 1£f ( )
{
break; // Non-compliant - second jump from loop
}
else
{
}
}
while ( )
{
if ( )
{
break;
}
if ( )
{
break; // Non-compliant - second jump from loop
}
}
Rule 6-6-5 (Required) A function shall have a single point of exit at the end of
the function.
Rationale

This is required by IEC 61508 [12], as part of the requirements for a modular approach.

Exception

À function implementing a function-try-block is permitted to have multiple points of exit, one for
the try block and one for each catch handler.

Throwing an exception that is not caught within the function is not considered a point of exit for
this rule.

 

Example
void fn { void )
{
if ( )
{
return’; // Non-compliant
}
103 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Cry

throw ( 1 ); // Compliant by exception

catch ( int32 t )
{

throw; // Compliant by exception
}
return’; // Non-compliant
}
void fn2 ( void )
{
Cry
{
return’; // Non-compliant
}
catch ( ... )
{
return’; // Non-compliant

}
}

void fn3 ( void } try
{
return; // Compliant by exception
}
catch ( int32 € )
{

return; // Compliant by exception
}
catch ( ... )
{
return; // Compliant by exception
}
See also

IEC 61508 [12] Part 3 Table B.9

6.7 Declarations
6.71  Specifiers

 

| Rule 7-1-1 (Required) A variable which is not modified shall be const qualified.

 

Rationale

If a variable does not need to be modified, then it shall be declared with const qualification so that
it cannot be modified. À non-parametric variable will then require its initialization at the point of
declaration. Also, future maintenance cannot accidentally modify the value.

 

104 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
void b ( int32 € * );

int32 + £ ( int32 t * pl,

int32 t * const p2,
int32 t * const p3 )

*p1l = 10;
*p2 = 10;
b( p3 );

int32 t i = 0;

return i;

See also
ISO/IEC 14882:2003 [1] $7.1.5

1

// Non-compliant

// Compliant
// Compliant

// Non-compliant

 

Rule 7-1-2 (Required)

 

À pointer or reference parameter in a function shall be
declared as pointer to const or reference to const if the
corresponding object is not modified.

 

Rationale

This rule leads to greater precision in the definition of the function interface. The const qualification
shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being

protected.

Exception

This rule does not apply if the parameter object is modified by any of the functions in a set of

overriding functions.

Example
void myfunc( int16 t * paraml,
const int16 € * param?,
int16 t * param3,
int16 t * const paramd)
// paraml: Addresses an object which is modified — Compliant
// param2: Addresses an object which is not modified - Compliant
// param3: Addresses an object which is not modified - Non-compliant
// paramd: Addresses an object which is not modified - Non-compliant
{
*parami = *param2 + *param3 + *paramd;

// Data at address param3 and paramd have not been changed

 

105

Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 
6. Rules (continued)

 

6.7.2 Enumeration declarations

 

 

 

 

Rule 7-2-1 (Required) An expression with enum underlying type shall only
have values corresponding to the enumerators of the
enumeration.
[Unspecified 7.2(9)]
Rationale

It is unspecified behaviour if the evaluation of an expression with erum underlying type vields a
value which does not correspond to one of the enumerators of the enumeration.

Additionally, other rules in this standard assume that objects of erum type only contain values
corresponding to the enumerators. This rule ensures the validity of these assumptions.

One way of ensuring compliance when converting to an enumeration is to use a swifch statement.

Example
enuml convert ( int16 E v )
{
enuml result = enumi ERROR;
switch ( v )
{
case 0: { result = enuml E1; break; }
case l: { result = enuml E7; break; }

default: { Chrow ( ENUM ERROR }); break; }
}

return result:

6.7.3 Namespaces

 

Rule 7-3-1 (Required) The global namespace shall only contain #ain,
namespace declarations and exfern "C" declarations.

 

 

 

Rationale

Declaring names into appropriate namespaces reduces the names found during lookup, helping to
ensure that the names found meet developer expectations.

Exception
The types defined for compliance with Rule 3-9-2 may also be in the global namespace.

Example
void f1 ( int32 t ); // Non-compliant
int32 t xl; // Non-compliant
namespace
void £f2 ( int32 € ); // Compliant
int32 t x2; // Compliant

 

106 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

namespace MY APT
{

 

void b2 ( int32 t ); // Compliant
int32 t x2; // Compliant
}
int32 t main () // Compliant
Rule 7-3-2 (Required) The identifier r#17ain shall not be used for a function

 

 

other than the global function rain.

 

[Implementation 3.6.1(2, 3)]
Rationale

main (or its equivalent) is usually the entry point to the program and is the only identifier which
must be in the global namespace. The use of main for other functions may not meet developer
expectations.

Example
int32 t main () // Compliant
{
}
namespace
int32 t main ( ) // Non-compliant

{
}
}

namespace NS

{

 

 

int32 & main () // Non-cempliant
}
Rule 7-3-3 (Required) There shall be no unnamed namespaces in Leader files. |
Rationale

An unnamed namespace will be unique within each translation unit. Any declarations appearing
in an unnamed namespace in a header will refer to different entities in each translation unit, which
may not be consistent with developer expectations.

Example

// Header.hpp
namespace // Non-compliant

{

extern int32 € x;

}

 

107 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

// Filel.cpp
#include "Header.hpp"

namespace
{

int32 € x;
}
void fn a ( void )
{

x = 24;

}

// File2.cpp
#include "Header.hpp"

namespace
{
int32 € x;
}
void fn b ( void )
{
fn a ( );
if x == 24 ) // This x will not have been initialized.
{
}

 

Rule 7-3-4 (Required) using-directives shall not be used.

 

Rationale

using-directives add additional scopes to the set of scopes searched during name lookup. All
identifiers in these scopes become visible, increasing the possibility that the identifier found by
the compiler does not meet developer expectations.

using-declarations or fully qualified names restricts the set of names considered to only the name
explicitly specified, and so are safer options.

Example

namespace NS1
{
int32 € il;
int32 € j1;
int32 € k1;
}

using namespace NS1; // Non-compliant

namespace NS2
{
int32 € i2;
int32 € 32;
int32 € k2;
}

using NS2::32; // Compliant

 

108 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

namespace NS3

{

int32 € i3;
int32 € 33;
int32 € Kk3;
}
void £ ()
{
++i1;
++32;
++NS3::kK3;

}

In the above, i1 is found via the using-directive. However, as a result of the using-directive, 51 and
k1 are also visible. The using-declaration allows :2 to be found while i2 and k2 remain hidden.
Finally, the qualified name N53 : : k3 unambiguously refers to k3, and i3, 53 and k3 remain hidden
to normal lookup.

See also
ISO/IEC 14882:2003 [1] $7.3.4

 

 

 

 

Rule 7-3-5 (Required) Multiple declarations for an identifier in the same
namespace shall not straddle a using-declaration for
that identifier.

Rationale

The set of identifiers introduced by a using-declaration does not include any declarations that may
be added by a subsequent declaration in the namespace. Any subsequent declarations will not be
found through the using-declaration, which may not be consistent with developer expectations.

Example

namespace NS1

{

void f( uint16 € ); // Example 1
}
using NS1::f;

namespace NS1

{
void f( uint32 € ); // Example 2 —- Non-compliant
}

void bar()

{
£C OÙ );
}

In the above example, moving the using-declaration below the second namespace would result in
Example 2 being called, as it is a better match than Example 1.

See also
ISO/IEC 14882:2003 [1] $7.3.3

 

109 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

Rule 7-3-6 (Required) using-directives and using-declarations (excluding class
scope or function scope using-declarations) shall not be
used in header files.

Rationale
It is important to ensure that the order of inclusion of header files cannot affect the behaviour of
a program.
Example
// ET.h
void foo ( char t a );

namespace NS1

{

void foo( int32 € a );

}

inline void bar ( )
{

foo ( À );
}

// f2.h
namespace NS1
{

}

using namespace NS1;

// fl.cc
#include "f1.h"
#include "£f2.h"

int32 t ml ( )
{
bar ( ); // bar calls foo ( char t });
}
// f2.cc

#include "£f2.h"
#include "f1.h"

void m2 ( )

{
bar ( );

}

// bar calls foo ( int32 € });

In the above example, changing the order of the header files alters the meaning of the program.

See also

ISO/TEC 14882:2003 [1] $7.3.3, $7.3.4

 

110 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.7.4 The asm declaration

 

| Rule 7-4-1 (Document) AII usage of assembler shall be documented.

 

[Implementation 7.4(1)]
Rationale

Assembly language code is implementation-defined and therefore is not portable.

 

Rule 7-4-2 (Required) Assembler instructions shall only be introduced using
the asm declaration.

 

 

 

Rationale

The asm declaration is available to all C++ implementations, allowing a consistent mechanism to
be used.

However, the parameters to asm are still implementation-defined.

Example

void Delay a ( void )
{

asm ( "NOP" ); // Compliant
}

void Delay b ( void )
{
#pragma asm
"NOP" // Non-compliant
#pragma endasm

}

 

Rule 7-4-3 (Required) Assembly language shall be encapsulated and isolated.

 

Rationale
Ensuring that assembly language code is encapsulated and isolated aids portability.

Where assembly language instructions are needed, they shall be encapsulated and isolated in
either assembler functions or C++ functions.

Example

void Delay ( void )
{

 

asm ( "NOP" ); // Compliant
}
void fn { void )
{
DoSomething ( );
Delay ( ); // Assembler is encapsulated
DoSomething ( );
asm ( "NOP" ); // Non-compliant
DoSomething ( );
}
111 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.7.5 Linkage specifications

 

Rule 7-5-1 (Required) A function shall not return a reference or a pointer to
an automatic variable (including parameters), defined
within the function.

 

 

 

Rationale

Automatic variables are destroyed at the end of the function call. Returning a reference or pointer
to such a variable allows it to be used after its destruction, leading to undefined behaviour.

Example
int32 t * fnl ( void )
{
int32 t x = 99;
return { &x ); // Non-compliant
}
int32 t * fn2 ( int32 € y )

{
return ( &y }); // Non-compliant

}
int32 t & fn3 ( void )
{
int32 t x = 99;
return { x ); // Non-compliant
}
int32 t & fnd4 ( int32 € y )
{

return ( y ); // Non-compliant
}
int32 t * fns ( void )
{

static int32 € x = 0;

return &x; // Compliant

 

Rule 7-5-2 (Required) The address of an object with automatic storage shall
not be assigned to another object that may persist after
the first object has ceased to exist.

 

 

 

Rationale

If the address of an automatic object is assigned to another automatic object of larger scope, or to a
static object, or returned from a function, then the object containing the address may exist beyond
the time when the original object ceases to exist (and its address becomes invalid).

Note that throwing a pointer to an object with automatic storage is also a violation of this rule.

 

112 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

void foobar ( void )

{
int8 t * pl;

{

int8 t local auto;

 

pi = &local auto; // Non-compliant
}
}
Rule 7-5-3 (Required) A function shall not return a reference or a pointer
to a parameter that is passed by reference or const
reference.

 

 

 

Rationale

It is inplementation-defined behaviour whether the reference parameter is a temporary object or
a reference to the parameter. If the implementation uses a local copy (temporary object), this will
be destroyed when the function returns. Any attempt to use such an object after its destruction will
lead to undefined behaviour.

Example

int32 t * fnl ( int32 € & x )
{

return { &x ); // Non-compliant
}
int32 t * fn2 ( )
{

int32 t i = 0;

return fn1i ({ i );

}

const int32 € * fn3 ( const int32 t & x )
{

return { &x ); // Non-compliant

}

int32 t & fnd4 ( int32 € & x )
{

return { x ); // Non-compliant

}

const int32 € & fns ( const int32 t & x )
{

return { x ); // Non-compliant

 

113 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 7-5-4 (Advisory) Functions should not call themselves, either directly or
indirectly.

 

 

 

Rationale

Unbounded recursion is likely to lead to a stack over-flow and may impact system timings. This
is also the case for an iterative algorithm.

Example
int32 t fn ( int32 € x )

if (x > 0 )
x = x * fn (x — 1 ); // Non-compliant

return ( x )};

}

// Filel.cpp
int32 t fn 2 ( int32 € x )
{
if (x > 0 )
{
x=x * fn 3 (x - 1); // Non-compliant
}

return ( x )};

}

// File2.cpp
int32 t fn 3 ( int32 € x )
{

x=x* fn 2 (x - 1 ); // Non-compliant

6.8 Declarators

 

 

 

 

6.8.0 General
Rule 8-0-1 (Required) An énit-declarator-list or a member-declarator-list shall
consist of a single énit-declarator or member-declarator
respectively.
Rationale

Where multiple declarators appear in the same declaration the type of an identifier may not meet
developer expectations.

 

114 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
int32 t il; int32 € j1;
int32 € i2, *)2;
int32 t *i3,

&i3

12;

See also
ISO/IEC 14882:2003 [1] $9.2

// Compliant

// Non-compliant

// Non-compliant

6.8.3 Meaning of declarators

 

 

 

 

Rule 38-3-1 (Required) Parameters in an overriding virtual function shall
either use the same default arguments as the function
they override, or else shall not specify any default
arguments.

Rationale

Default arguments are determined by the static type of the object. If a default argument is different
for a parameter in an overriding function, the value used in the call will be different when calls are
made via the base or derived object, which may be contrary to developer expectations.

Example

class Base

{

public:
virtual void gt ( int32 t a = 0 );
virtual void g2 ( int32 t a = 0 });
virtual void bT ( int32 t a = 0 );

};

class Derived public Base

{

public:
virtual void gt ( int32 t a = 0 );
virtual void g2 ( int32 € a );
virtual void bT ( int32 t a = 10 );

value

};

void f({ Derived& d )

{
Bases b = d:
b.aql ( ); // Will use default
a.g1 ( ); // Will use default
b.g2 ( ); // Will use default
d.g2 ( O ); // No default value
b.b1 €); // Will use default
d.b1 €): // Will use default

// Compliant - same default used
// Compliant -

// no default specified
// Non-compliant - different

of 0

of 0

of 0

available to use
of 0

of 10

 

115

Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

The default argument for 42 can only be used via the base class object and so the value used will
always be the same.

See also
ISO/IEC 14882:2003 [1] $8.3.6(10)

6.8.4 Function definitions

 

Rule 8-4-1 (Required) Functions shall not be defined using the ellipsis
notation.

 

 

 

[Undefined 5.2.2(7), 18.7(3)]
Rationale

Passing arguments via an ellipsis bypasses the type checking performed by the compiler.
Additionally, passing an argument with non-POD class type leads to undefined behaviour.

Note that the rule specifies “defined” (and not “declared”) so as to permit the use of existing
library functions.

 

 

 

 

Example
void MyPrintf ( char t * pFormat, ... ); // Non-compliant
Rule 8-4-2 (Required) The identifiers used for the parameters in à re-
declaration of a function shall be identical to those in
the declaration.
Rationale

The name given to a parameter helps document the purpose of the parameter within the function
body. If a function parameter is renamed in a subsequent re-declaration, then having different
names for the same object will probably lead to developer confusion.

Note that the rule also applies to any overriding set.

Exception

It is not a violation of this rule if the declaration or re-declaration contains an unnamed parameter.

Example

// Filel
void CreateRectangle ( uint32 t Heïight, uint32 t Width );

// File?
// Non-compliant
void CreateRectangle

void fn1 ( int32 € a
void fn2 ( int32 €

void fn1 ( int32 € b
{
}

( uint32 € Width, uint32 t HeighE );
);
);
)

// Non-compliant

 

116 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

void fn2 ( int32 t b ) // Compliant

{

}

Rule 8—4-3 (Required) AII exit paths from a function with non-void return
type shall have an explicit refurn statement with an
expression.
[Undefined 6.6.3(2)]
Rationale

This expression gives the value that the function returns. The absence of a return with an expression
leads to undefined behaviour (and the compiler may not give an error).

Exception

This rule does not apply if a function exit is due to exception handling (1.e. a frow statement).

Example

int32 t fn1 ( void )
{
} // Non-compliant

int32 t fn3 ( int32 t x )
{

if ( x > 100 )

{

 

throw 42; // Compliant by exception
}
return { x ); // Compliant
}
Rule 8-4-4 (Required) À function identifier shall either be used to call the

 

function or it shall be preceded by &.

 

 

Rationale

A function identifier can implicitly convert to a pointer to a function. In certain contexts this may
result in a well-formed program, but which is contrary to developer expectations. For example, if
the developer writes:

if (£)

then it is not clear whether the intent is to test if the address of the function is NULL or if a call to
the function £() should be made and the brackets have been unintentionally omitted. The use of
the & (address-of) operator will resolve this ambiguity.

Exception

Passing the function by reference, or assigning it to a reference object is not a violation of this rule.

Example

extern void £f ( void );

 

117 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

1f { O — ) // Non-compliant
{
//
}
void (*p)( void ) = f; // Non-compliant
11 { O == &E ) // Compliant
{
(D) 0); // Compliant as function is called
}
void (*p)( void )}) = &f; // Compliant

6.8.5 Initializers

 

Rule 8-5-1 (Required) AII variables shall have à defined value before they are
used.

 

 

 

[Indeterminate 8.5(9)]
Rationale

The intent of this rule is that all variables shall have been written to before they are read. This does
not necessarily require initialization at declaration.

Note that according to ISO/IEC 14882:2003 [1], variables with static storage duration are
automatically initialized to zero by default, unless explicitly initialized. In practice, many
embedded environments do not implement this behaviour. Static storage duration is a property
of all variables declared with the sfafic storage class specifier, or with external linkage. Variables
with automatic storage duration are not usually automatically initialized.

Each class constructor shall initialize all non-static members of its class.

Example

class C

{

public:
C ( } : ma( 10 )}, mb( 7) // Compliant

{
}
C (int32 ta) : ma(a) // Non-compliant
{
}

int32 t GetmB ( void )
{

return ( mb );
}
private:
int32 t m a;
int32 t m b;
};
Cet s );

 

118 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

int main ( void })

{
1f ( c.GetmB( )} > O0 ) // mb has not been initialized
{
}

}

Rule 8-5-2 (Required) Braces shall be used to indicate and match the structure
in the non-zero initialization of arrays and structures.
Rationale

ISO/IEC 14882:2003 [1] requires initializer lists for arrays, structures and union types to be
enclosed in a single pair of braces (though the behaviour if this is not done is undefined). The
rule given here goes further in requiring the use of additional braces to indicate nested structures.
This forces the developer to explicitly consider and demonstrate the order in which elements of
complex data types are initialized (e.g. multi-dimensional arrays).

The zero initialization of arrays or structures shall only be applied at the top level.

The non-Zero initialization of arrays or structures requires an explicit initializer for each element.

Example
The following shows two valid ways of initializing the elements of a two dimensional array, but
the first does not adhere to the rule:
int16 t y[3][21 = { 1, 2, 3, 4, 5, 6 }; // Non-compliant
int16 t y[3][21 = { { 1, 2}, { 3, 4}, { 5, 6 } }; // Compliant
A similar principle applies to structures, and nested combinations of structures, arrays and other
types.

Note also that all the elements of arrays or structures can be initialized (to zero or NULL) by giving
an explicit initializer for the first element only. If this method of initialization is chosen then the
first element should be initialized to zero (or NULL), and nested braces need not be used.

// The following are compliant

 

int16 t a1[5] = { 1, 2, 3, 0, O0 }; // Non-zero initialization
int16 t a2[5] = { O0 }; // Zero initialization
int16 t a3[2][2] = { }; // Zero initialization
// The following are non-compliant
int16 t ad[5] = { 1, 2, 3 }; // Partial initialization
int16 t aS[2][2] = { { }, { 1, 2 } }; // Zero initialization
// at sub-level
Rule 8-5-3 (Required) In an enumerator list, the = construct shall not be used

to explicitly initialize members other than the first,
unless all items are explicitly initialized.

 

 

 

Rationale

If an enumerator list is given with no explicit initialization of members, then C++ allocates a
sequence of integers starting at Zero for the first element and increasing by one for each subsequent
element.

 

119 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

An explicit initialization of the first element, as permitted by the above rule, forces the allocation
of integers to start at the given value. When adopting this approach it is essential to ensure that
the initialization value used is small enough that no subsequent value in the list will exceed the inf
storage used by enumeration constants.

Explicit initialization of all items in the list, which is also permissible, prevents the mixing of
automatic and manual allocation, which is error prone. However it is then the responsibility of the
developer to ensure that all values are in the required range, and that values are not unintentionally
duplicated.

Example

The following example assigns the same value to the green and yellow enumeration constants.
It is unclear to a reviewer if this was intentional or an error.

enum colour { red=3, blue, green, vyellow=s5 }; // Non-compliant

However, if all the items are explicitly initialized, then the duplicated values are acceptable as the
duplication is readily detectable by anyone reviewing the code.

enum colour { red=3, blue=4, green=5, vyellow=s5 }; // Compliant

6.9 Classes
6.9.3 Member functions

 

Rule 9-3-1 (Required) const member functions shall not return non-const
pointers or references to class-data.

 

 

 

Rationale

When an object is declared with const class type, only const member functions can be invoked on
that object. The common expectation of const member functions is that the state of the object may
not be modified when invoking the functions. However, returning a non-const pointer or reference
to class-data from a const function allows a modification to the conceptual state of an object.

Example

class C

{

public:
C ( int32 t & b }) : a ( new int32 t [ 10 ] }, b (b  )
{
}
int32 t * getA () const // Non-compliant

// Returns non const pointer to data
{
return a;

}
int32 t * getB () const // Non-compliant

// Returns non const pointer to data

{

return &b;

}

 

120 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

const int32 t * getC () const // Compliant
// Returns const pointer to data
{
return &b;

}

private:
int32 t * a;
int32 t & b;
};

 

 

 

 

void fn ( C const & € )
{
c.getA()[ 0 ] = 0; // Modification to conceptual state of C
*c.getB({) = 0; // Modification to conceptual state of C
fn2 ( c.getC{() }); // Value can be used,
*c.getC() = 0; // but compiler will report an error here
}
Rule 9-3-2 (Required) Member functions shall not return non-const handles to
class-data.
Rationale

By implementing class interfaces with member functions the implementation retains more control
over how the object state can be modified and helps to allow a class to be maintained without
affecting clients. Returning à handle to class-data allows for clients to modify the state of the
object without using any interfaces.

Example

class C

{

public:
int32 t & getA () // Non-compliant
{

return a;

}

private:
int32 t a;
};
void b (C&c)
{
int32 t & a ref = c.getA ();
a ref - 10; // External modification of private C:t:a

}

c.getA() returns a reference to the member, which is then stored and modified by a ref. The
class, therefore, has no control over changes to its state.

Where a resource is used by the class, but is not class-data, non-const handles to this data may
be returned.

 

121 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

class C

{

public:
C { int32 € * shared ) : m shared ( shared )
{
}

int32 t * getA ()
{
return m shared; // Compliant - m shared is not class-data
}
private:
int32 t * m shared;
};

 

Rule 9-3-3 (Required) If a member function can be made static then it shall
be made static, otherwise if it can be made const then it
shall be made const.

 

 

 

Rationale

Declaring a member function static or const limits its access to the non-static data members.
This helps to prevent unintentional modification of the data, and facilitates compliance with
Rule 7-1-1.

Example

class À

{

public:
int16 t £1 ( ) // Non-compliant - can be const
{

return mi;

int16 t £2 ( ) // Non-compliant - can be static
{
return ms;
}
int16 t £3 ( ) // Compliant - cannot be const or static
{
return ++m i;
}
private:
int16 t mi;
static int16 E ms;

};

 

122 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.9.5 Unions

 

| Rule 9-5-1 (Required) Unions shall not be used. |

 

[Implementation 3.9(4, 5)]
Rationale

The use of unions to access an object in different ways may result in the data being misinterpreted.
Therefore, this rule prohibits the use of unions for any purpose.

It is recognized nonetheless that there are situations in which the careful use of unions is desirable
in constructing an efficient implementation. In such situations, deviations to this rule are considered
acceptable provided that all relevant implementation-defined behaviour is documented. This might
be achieved in practice by referencing the implementation section of the compiler manuals from
the design documentation.

Example

namespace NS1

{

// Compliant - no union

}

namespace NS2
{
union Ul // Non-compliant - union
{
int32 € i;
float32 € j;
};
}

6.9.6 Bit-fields

 

Rule 9-6-1 (Document) When the absolute positioning of bits representing a
bit-field is required, then the behaviour and packing of
bit-fields shall be documented.

 

[Implementation 9.6(1)]
Rationale

Certain aspects of bit-fields are implementation-defined. In particular, the developer should be
aware of the following:

*_[tis implementation-defined whether the bit-fields are allocated from the high or low end
of a storage unit (usually a byte).

*_ Itis inplementation-defined whether or not a bit field can overlap a storage unit boundary
(e.g. if a 6-bit bit-field and a 4-bit bit-field are declared in that order, then the 4-bit bit-field
may either start a new byte or it may use 2 bits in one byte and 2 bits in the next).

These issues are generally benign (e.g. when packing together short-length data to save storage
space), but they may lead to errors if the absolute position of the bit-fields is important (e.g. when
accessing hardware registers).

 

123 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Provided the elements of the structure are only accessed by name, the developer need make no
assumptions about the way that the bit fields are stored within the structure.

Note that Rule 3-9-2 need not be followed when defining bit-fields, as their lengths are explicitly
specified.

If the compiler has a switch to force bit fields to follow a particular layout, then this option should
be documented.

Example

struct message // Struct is for bit-fields only

{
signed int little: 4; // Note: use of basic types is required
unsigned int x set: 1;
unsigned int y set: 1;

} message chunk;

 

Rule 9-6-2 (Required) Bit-fields shall be either boo! type or an explicitly
unsigned or signed integral type.

 

 

 

[Implementation 3.9.1(5), 7.1.5.2(1), 9.6(3)]
Rationale

Using int is implementation-defined because bit-fields of type irf can be either signed or
unsigned.

The use of wchar tas a bit-field type is prohibited as ISO/IEC 14882:2003 [1] does not explicitly
define the underlying representation as signed or unsigned.

Example

struct $S

{

signed int a : 2; // Compliant
unsigned int b : 2; // Compliant
char © : 2; // Non-compliant
signed char d: 2; // Compliant
unsigned char &e : 2; // Compliant
short £ : 2; // Non-compliant
signed short g : 2; // Compliant
unsigned short h : 2; // Compliant
int 1 5 2; // Non-compliant
bool 7 : 2; // Compliant
wohar t Kk : 2; // Non-compliant
uint32 &£ Lo: 2; // Compliant
int8 t om: 2; // Compliant

 

124 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

| Rule 9-6-3 (Required) Bit-fields shall not have enum type. |

 

[Undefined DR 58]
Rationale

The use of enum as a bit-field type is prohibited as ISO/TEC 14882:2003 [1] does not explicitly
define the underlying representation as signed or unsigned. It is therefore not possible to determine
the exact number of bits required to represent all values in the enumeration.

Example

struct $S
{

AnEnumType n : 2; // Non-compliant
};

 

Rule 9-6-4 (Required) Named bit-fields with signed integer type shall have a
length of more than one bit.

 

 

 

Rationale

The values which may be represented by a bit-field of length one may not meet developer
expectations. Anonymous signed bit-fields of any length are allowed.

Example

struct $S
{

signed int a : // Non-compliant

l;
signed int : 1; // Compliant
signed int : O; // Compliant
signed int b : 2; // Compliant
signed int : 2; // Compliant

};

6.10 Derived classes
6.10. Multiple base classes

 

| Rule 10-1-1 (Advisory) Classes should not be derived from virtual bases.

 

Rationale

The use of virtual base classes can introduce a number of undefined and potentially confusing
behaviours. The use of virtual bases is not recommended.

 

Example
class B {};
class D: public virtual B {}; // Non-compliant - B is a virtual base
125 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

See also
Rule 5-22, Rule 10-1-2, Rule 12-12

 

Rule 10-1-2 (Required) A base class shall only be declared virtual if it is used in
a diamond hierarchy.

 

 

 

Rationale

The use of virtual base classes can introduce a number of undefined and potentially confusing
behaviours. Therefore, a base class shall only be declared virtual if that base class is to be used as
a common base class in a diamond hierarchy.

Example
class A {};
class B1l: public virtual À {}; // Compliant - À is a common base for C
class B2: public virtual À {}; // Compliant - À is a common base for C

class C: public B1, B2 {};
class D: public virtual A {}; // Non-compliant

 

Rule 10-1-3 (Required) An accessible base class shall not be both virtual and
non-virtual in the same hierarchy.

 

 

 

Rationale

If a base class is both virtual and non-virtual in a multiple inheritance hierarchy then there will be
at least two copies of the base class sub-object in the derived object. This may not be consistent
with developer expectations.

Example
class A {};
class B1l: public virtual À {};
class B2: public virtual À {};

 

class B3: public A {};
class C: public B1, B2, B3 {}; // Non-compliant -—
// C has two À sub-objects
610.2 Member name lookup
Rule 10-2-1 (Advisory) AII accessible entity names within a multiple

 

 

inheritance hierarchy should be unique.

 

Rationale

If the names are ambiguous, the compiler should report the name clash and not generate arbitrary
or unexpectedly resolved code. However, this ambiguity may not be obvious to a developer.

There is also à specific concern that if the member function is virtual, resolving the ambiguity by
explicitly referencing the base class in effect removes the virtual behaviour from the function.

 

126 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Exception

For the purposes of this rule, visible function identifiers that form an overload set shall be
considered as the same entity.

Example

class BI

{
public:
int32 t count; // Non-compliant

void foo ( ): // Non-compliant
};
class R2

{
public:
int32 t count; // Non-compliant

void foo ( ): // Non-compliant
};
class D : public B1, public B2

{
public:
void Bar ( )

{
++count; // Is that Bl::count or B2::count?
foo ( ); // Is that Bl::foo() or B2::foo()7?

};
In the above example, in a member function of D, the use of count or foo is ambiguous and must
be disambiguated by B1::count, B2::foo, etc.

6.10.3 Virtual functions

 

 

 

 

Rule 10-3-1 (Required) There shall be no more than one definition of each
virtual function on each path through the inheritance
hierarchy.

Rationale

The main aim of this rule is clarity for maintainers and reviewers, by ensuring that the version of
a function that can be executed from any point in a class hierarchy is unambiguous.

Additionally, where classes form a diamond hierarchy, call by dominance ([1] $10.3(11)) may
occur resulting in a call to a function that is inconsistent with developer expectations. This rule
also prevents call by dominance.

Exception
Destructors may be declared virtual in multiple members of a class hierarchy.

If a function 1s declared pure and defined in the same class, then that definition 1s ignored for this
rule.

 

127 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

class À

{

public:
virtual void £1 ( )} = 0; // f1 is pure
virtual void £2 ( ) = 0; // f2 is pure
virtual void £3 ( ) { 7} // f3 is not pure
virtual void £4 € ) = 0; // f4 is pure
virtual A0: // destructor

};

// A::fl is both pure and has a definition
void A:t:f1 ( )

{

}

// A::f4 is both pure and has a definition

void A:t:f4 ( )
{
}
class B public A
{
public:
virtual void £2 ( ) {7} // Compliant: f2 pure in À and
// defined in B
virtual void £3 ( ) { 7} // Non-compliant: f3 defined in À and B
virtual void £4 € ) = 0; // Compliant: f4 is pure in À and in B
virtual -B0: // Compliant: destructor

};
// Compliant by Exception - f4 defined in À but also declared pure in A

void B::f4 ( )
{
}
class C public B
{
public:
virtual void f1 ( )} { } // Compliant: f1 defined in A and C
// but was pure in A
virtual void f2 ( ) { } // Non-compliant f2: defined in B and C
// and not declared pure in B
virtual void f4 ( ) { } // Compliant by Exception: f4 defined in A
// and B but also declared pure in À and B
};
class D public C
{
public:
virtual void f1 ( ) { } // Non-compliant f1: defined in C and D
// as well as A
virtual DO: // Compliant: destructor

};

 

Licensed to: Insigma Raïl Transport. Engineering Co.

12
8 He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

// Call by dominance example
class V
{
public:
virtual void foo ( )
{
}
};
class B1 : public virtual V
{
public:
virtual void foo ( ) // Non-compliant
{
}
};

class B2 : public virtual V
{
public:

void £1 ( )

{
foo(); // Vi:foo would appear to be the only
// candidate to be called here

};
class D : public B1, public B2
{

public:

void £2 ( )

{

£T(0);

}
};
B2 b2;
b2.f1(); // calls V::fo0 by normal inheritance rules
D d;

d.f20: // calls B2::f1 which now calls Bl::foo
// “by dominance"
d.f10: // also calls Bl::fo00 "by dominance"

 

Rule 10-3-2 (Required) Each overriding virtual function shall be declared with
the virtual keyword.

 

 

 

Rationale

Declaring overriding virtual functions with the virfual keyword removes the need to check the
base class to determine whether a function is virtual.

 

129 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

class À

{

public:
virtual void g();
virtual void b();

};

class B1l : public A
{

 

 

 

public:
virtual void g(); // Compliant — explicitly declared "virtual"
void bÜ; // Non-compliant - implicitly virtual
};
Rule 10-3-3 (Required) A virtual function shall only be overridden by a pure
virtual function if it is itself declared as pure virtual.
Rationale

Re-declaring a function as pure may not meet developer expectations.

Example

class À

{
public:
virtual void foo { } = 0; // foo declared pure
};
class B : public A
{
public:
virtual void foo { ) // foo defined
{
}
};

class C: public B
{
public:
virtual void foo ( )} = 0; // Non-compliant - foo re-declared pure

};
The function fo is introduced as pure (making class À abstract), defined in class B (making class

B concrete), then re-declared as pure (making class C abstract). As this may not meet developer
expectations, the re-declaration as pure is not allowed.

 

130 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 
6. Rules (continued)

 

6.11 Member access control
611.0 General

 

| Rule 11-0-1 (Required) Member data in non-POD class types shall be private.

 

Rationale

By implementing class interfaces with member functions, the implementation retains more control
over how the object state can be modified, and helps to allow a class to be maintained without
affecting clients.

Example

class C
{
public:

int32 t b; // Non-compliant
protected:

int32 t c; // Non-compliant
private:

int32 t d; // Compliant
};

6.12 Special member functions
6.2.1 Constructors

 

Rule 12-1-1 (Required) An object’s dynamic type shall not be used from the
body of its constructor or destructor.

 

 

 

[Undefined 10.4(6)]
Rationale

During construction and destruction of an object, its final type may be different to that of the
completely constructed object. The result of using an object’s dynamic type in a constructor or
destructor may not be consistent with developer expectations.

The dynamic type of an object is used in the following constructs:
*_ typeid on a class with a virtual function or a virtual function in a base class.
° dynamic cast

° A virtual call to a virtual function.

This rule also prohibits a call being made to a pure virtual function from within a constructor or
destructor. Such calls lead to undefined behaviour.

 

131 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

 

 

Example
class BI
{
public:
B1 ( )
{
typeid ( B1 ); // Compliant, B1 not polymorphic
}
};
class R2
{
public:
virtual -B2 { );
virtual void foo ( );
B2 ( )
{
typeid ( B2 ); // Non-compliant
B2::f00 ( ): // Compliant - not a virtual call
foo ( ); // Non-compliant
dynamic cast< B2* > ( this ); // Non-compliant
}
};

Rule 12-1-2 (Advisory) AII constructors of a class should explicitly call a
constructor for all of its immediate base classes and all
virtual base classes.

Rationale

This rule reduces confusion over which constructor will be used, and with what parameters.

Example

class À
{
public:
A ()
{
}
};

class B : public A

{

public:
B {) // Non-compliant - benign, but should be B ( )} : À ( )
{
}

};

 

132 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

class V

{

public:
VC)
{

}
V (int32 ti)
{
}

};
class C1 : public virtual V
{
public:
C1 ( ) : V ( 21 )
{
}
};
class C2 : public virtual V
{
public:
C2 ( ) : V ( 42 )
{
}
};
class D: public C1, public C2
{
public:
D () // Non-compliant
{
}
};

There would appear to be an ambiguity here, as D only includes one copy of v. Which version
of v’s constructor is executed and with what parameter? In fact, v’s default constructor is always
executed. This would be the case even if C1 and C2 constructed their bases with the same integer
parameter.

This is clarified by making the initialization explicit, as in:

 

 

 

 

D'() : C1 ( ), C2 Co), V ()
{
}

Rule 12-1-3 (Required) AII constructors that are callable with à single
argument of fundamental type shall be declared
explicit.

Rationale

The explicit keyword prevents the constructor from being used to implicitly convert from a
fundamental type to the class type.

 

133 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

class C

{

public:
C ( int32 t a )
{
}

};

class D

{

public:
explicit D ( int32 € a )
{
}

};

6.12.8 Copying class objects

// Non-compliant

// Compliant

 

 

Rule 12-8-1 (Required) À copy constructor shall only initialize its base classes
and the non-static members of the class of which it is a
member.

 

Rationale

[Implementation 12.8(15)]

If a compiler implementation detects that a call to a copy constructor is redundant, then it is
permitted to omit that call, even if the copy constructor has a side effect other than to construct a

copy of the object. This is called copy elision.

It is therefore important to ensure that a copy constructor does not modify the program state as the

number of such modifications may be indeterminate.

Example

class À

{

public:
A ( À const & rhs )
: mi ( rhs.m i )

{

++m static; // Non-compliant

}

private:
int32 t m i;

static int32 € m static;
};
int32 t A:im static = 0;
AT ()
{

return À ( );

}

 

Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 
6. Rules (continued)

 

void b ( )

The value thatn static has after the call to b( ) is implementation-defined.

 

Rule 12-8-2 (Required) The copy assignment operator shall be declared
protected or private in an abstract class.

 

 

 

Rationale

An abstract class represents the interface part of a hierarchy. Invoking the copy constructor from
the top of such a hierarchy bypasses the underlying implementation resulting in only the base sub-

objects being copied.

Example

class BI

{

public:
BI ( );
virtual void £f( } = 0;
B1 & operator= ( B1 const & rhs }); // Non-compliant
int32 t getKind ( ) const { return kind; }

private:

int32 t kind;
};
class D1 : public B1
{

public:

virtual void f ( ) { }

D1 & operator= ( Di const & rhs });
private:

int32 t member;
};
void f1( B1 & b1, B1 & b2 )
{
b1 = b2;
}

As the assignment operator is public, the function £1 can call the operator and so copies the base
sub-objects of b1 and b2. As the type of b1 and 2 is an abstract type, b1 and 52 must be sub-

objects, and so the information contained in the derived objects for both will not be copied.

Making the abstract copy assignment operator protected allows access from the derived classes

but not from outside the hierarchy.

class R2
{
public:
B2 ( );
virtual void £ ( ) = 0;
int32 t getKind ( ) const { return kind; }

 

135 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

protected:
B2 & operator= ( B2 const & rhs }); // Compliant

private:
int32 t kind;
};
class D2 : public B2
{

public:
virtual void f ( ) { }
D2 & operator= ( D2 const & rhs });

};

void £2 ( B2 & b1, B2 & b2 )
{

b1 = b2; // Compiler error will be reported
}

Making the copy assignment operator private is a common idiom used to restrict copying objects
of the class type.

6.14 Templates
6.145 Template declarations

 

Rule 14-5-1 (Required) À non-member generic function shall only be declared
in a namespace that is not an associated namespace.

 

 

 

Rationale

Argument-dependent lookup (ADL) adds additional associated namespaces to the set of scopes
searched when lookup is performed for the names of called functions. À generic function found
in one of these additional namespaces would be added to the overload set and chosen by overload
resolution, which is inconsistent with developer expectation.

Example

template <typename T>
class B

{
public:
B operator+ ( long & rhs });

void £ ( )
{
*this + 10; // calls NS::operator+ and not
// B<NS::A>::operator+ when B is
// instantiated with NS::A

};
namespace NS

{
class À {
public:
};

 

136 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

template <Etypename T>
bool operator+ ( T, int32 € ); // Non-compliant - within associated
// namespace

}
template class B<NS::A>;

ADL considers the namespace NS to be an associated namespace. There are three functions in the
overload set:

+ The built-in operator+
T operator+t ( T, T );

+ _ The member operator+
B<NS::A> B<NS::A>::operator+t ( long );

* The specialized generic function
bool NS::operator+t< B<NS::A> > ( B<NS::A>, int32 € )

The conversion from the literal 10 to int32 t is a better match than that to 1ong, and therefore
NS::operator+ is chosen rather than the member operator+, which may be inconsistent with
developer expectations.

 

 

 

 

Rule 14-52 (Required) À copy constructor shall be declared when there is a
template constructor with a single parameter that is a
generic parameter.

Rationale

Contrary to possible developer expectations, a template constructor will not suppress the compiler
generated copy constructor. This may lead to incorrect copy semantics for members requiring
deep copies.

Example

class À

{
public:
A (Co);
/J À ( À const & rhs ); Example 1 - implicitly generated

template <Etypename T>

A ( T const & rhs }) // Example 2
: i ( new int32 € )
{
ki = *rhs.i;
}
private:
int32 t * ji; // Member requires deep copy

};
void f ( À const & al )

{
À a2 ( al ); // Non-compliant - Unexpectedly uses Example 1
}

The implicitly generated copy constructor, Example 1, will be used to construct a2 from a1.

 

137 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Therefore, a shallow copy on the pointer member i will result in both a1.i and a2.i pointing to
the same object. Was this the intent, or was it expected that a new object would be created and
initialized?

 

Rule 14-5-3 (Required) À copy assignment operator shall be declared when there
is a template assignment operator with à parameter
that is a generic parameter.

 

 

 

Rationale

Contrary to possible developer expectations, a template assignment operator will not suppress
the compiler generated copy assignment operator. This may lead to incorrect copy semantics for
members requiring deep copies.

Example
class À
{
public:
/J À & operator= ( À const & rhs ) Example 1 - implicitly generated
/P OT
// 1 = rhs.i;
// return *this;
1/1}
template <Etypename T>
T & operator= ( T const & rhs ) // Example 2
{
1f ( this != é&rhs ) !{
delete i;
i = new int32 t;
ki = *rhs.i; _
}
return *this;
}
private:

int32 t * i; // Member requires deep copy
};
void £ ( À const & al, À & a2 )

{
a2 = al; // Unexpectedly uses Example 1

}

The implicitly generated copy assignment operator Example 1 will be used to copy a1 to a2.
Therefore, a shallow copy on the pointer member i will result in both a1.i and a2.i pointing to
the same object. Was this the intent, or was it expected that a new object would be created and
initialized?

 

138 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.146 Name resolution

 

Rule 14-6-1 (Required) In a class template with a dependent base, any name
that may be found in that dependent base shall be
referred to using a qualified-id or this->

 

 

 

Rationale

Using a qualified-id or prefixing the identifier with this-> ensures that the entity chosen is
consistent with developer expectations.

Example
typedef int32 t TYPE;
void qg ( );

template <typename T>
class B;

template <typename T>
class À : public B<T>
{

void £1 ( )
{
TYPE t = 0; // Non-compliant Example 1
g { ); // Non-compliant Example 2
}
void £2 ( )
{
:2TYPE t1 = 0; // Compliant - explicit use global TYPE
::g ( ); // Compliant - explicit use global func

typename B<T>::TYPE t2 = 0; // Compliant - explicit use base TYPE
this->g ( ); // Compliant - explicit use base "g"
}
};
template <typename T>

class B

{

public:
typedef T TYPE;
void q ( );

};
template class A<int32 t>;

A conforming compiler will choose : : TYPE in Example 1, and : :4 in Example 2.

 

Rule 14-6-2 (Required) The function chosen by overload resolution shall resolve
to a function declared previously in the translation unit.

 

 

 

Rationale

Argument-dependent lookup (ADL) adds additional associated namespaces to the set of scopes
searched when lookup is performed for the names of called functions. For function templates,
ADL is performed at the point of instantiation of the function template, and so it is possible that a

 

139 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

function declared after the template may be called.

To ensure that ADL does not take place when calling a function with a dependent argument, the
postfix-expression denoting the called function can either be a qualified name or a parenthesized
expression.

Example
void b ( int32 € );

template <typename T>
void £f ( T const & Et )
{

b {Et ); // Non-compliant - Calls NS::b declared after f
sb CE): // Compliant - Calls ::b
{pb ) (t ); // Compliant - Calls ::b

}

namespace NS

{
struct A

{

operator int32 € ( } const:
};
void b ( À const & a );
}

int main ( )
NS::A a;
f (a );
}
Operators with dependent types may also have this problem. In order to avoid ADL in these
examples, operators should not be overloaded, or the calls should be changed to use explicit
function call syntax and a qualified name or parenthesized expression used, as above.

For example:

template <typename T>
void f ( T const & € )
{

t = t; // Non-compliant - Calls NS::operator==
// declared after f
operator ==( t, € ); // Compliant - Calls built-in operator==
({ operator == <T> } ( t, t ); // Compliant - Calls built-in operator==

}

namespace NS

{

struct A
{
operator int32 € ( } const:
};
bool operator== ( À const &, À const & );

 

140 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

int main ( )
{
NS::A a;
f ( a );

6.14.7 Template instantiation and specialization

 

Rule 14—7-1 (Required) AII class templates, function templates, class template
member functions and class template static members
shall be instantiated at least once.

 

 

 

Rationale

Similar to uncalled functions, un-instantiated class and function templates are a potential source
of noise and they may be symptomatic of a more serious problem such as missing paths.

Note: Even though a given class template may be instantiated many times, it is possible that some
of its member functions are never instantiated.

See Section 3.5 for associated library issues.

Example

template < typename T >
class Sample

{
public:
void inst mem ( )

{

}

void uninst mem ( ) // Non-compliant

{

}
};
Sample<int64 t> s;
s.inst mem ( ); // Call to s.inst mem instantiates the member.

// s.uninst mem is not called within the program
// and is not instantiated.

 

Rule 14-7-2 (Required) For any given template specialization, an explicit
instantiation of the template with the femplate-
arguments used in the specialization shall not render the
program ill-formed.

 

 

 

Rationale

An implicit template specialization does not instantiate every member of the template. Where
instantiation of a member would result in an i//-formed program it is not clear that the template
should be used with the supplied femplate-arguments.

 

141 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

See Section 3.5 for associated library issues.

Example
template <typename T>
class A
{
public:
void f1 ()
{
//
}
void £f2 ()
{
T't;
t.x = 0; // Will only work for types that have a .x member
}
};
void b ()
{
A<int32 t> a; // A<int32 t>::£2 is not instantiated.
a.fl ():;

}

template class A<int32 t>; // Non-compliant - instantiation of f2
// results in "ill-formed" program.

 

Rule 14-7-3 (Required) AII partial and explicit specializations for a template
shall be declared in the same file as the declaration of
their primary template.

 

 

 

[NDR 14.5.4(1), 14.6.4.1(7), 14.7.3(6)]
Rationale

It is undefined behaviour if, for a set of femplate-arguments, an implicit instantiation is generated
by the compiler, and a partial or explicit specialization is declared or defined elsewhere in the
program that would match the set of femplate-arguments.

Example
// tmpl.h
template <typename T> void bad tmpl () {}
template <typename T> void good tmpl () {}
template <> void good Empl<int32 £> () {}
// tmpl.cc
#include "Empl.h"
template <> void bad tmpl<int32 t> () {} // Non-compliant
template <> void good Empl<int32 £> () {}
// f.cc

#include <tmpl.h>

 

142 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

void £ ()
{
bad tmpl<int32 t> (); // implicit instantiation of primary.
// explicit instantiation in tmpl.cce would
// have been used if it were visible.
good tmpl<int32 t> (); // specialization of good tmpl<int32 £> is
// visible with the primary declaration.

6.14.8 Function template specialization

 

Rule 14-8-1 (Required) Overloaded function templates shall not be explicitly
specialized.

 

 

 

Rationale

Explicit specializations will be considered only after overload resolution has chosen a best match
from the set of primary function templates. This may be inconsistent with developer expectations.

Example

template <typename T> void f ( T ); // overload Example 1
template <typename T> void f ( T* ); // overload Example 2

template <> void f<int32 t*> ( int32 t* ); // explicit specialization of
// Example 1

void b ( int32 € * i )

£ (Ci); // Non-compliant
// — Calls Example 2, f<int32 t*>

Where a template is not overloaded with other templates, or is overloaded with non-template
functions then it can be explicitly specialized, as it is consistent with developer expectation that
the explicit specializations will only be considered if that primary template is chosen.

template <typename T> void f ( T ); // Example 1

template <> void f<int32 t*> ( int32 t* }); // Example 2

void b ( int32 € * i )

E Ci); // Compliant
// — Calls Example 2, f<int32 E*>

 

Rule 14-8-2 (Advisory) The viable function set for a function call should either
contain no function specializations, or only contain
function specializations.

 

 

 

Rationale

If a function and a specialization of a function template are deemed equivalent after overload
resolution, the non-specialized function will be chosen over the function specialization, which
may be inconsistent with developer expectations.

 

143 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Exception

This rule does not apply to copy constructors or copy assignment operators.

Example
void £ ( short ); // Example 1
template <typename T> void f ( T ); // Example 2
void b ( short 5 )
{
£ { s ); // Non-compliant - Calls Example 1
£ s + 1 ); // Non-compliant - Calls Example 2
F<>( s ); // Compliant - Explicitly calls Example 2
É<>( s + 1 ); // Compliant - Explicitly calls Example 2

6.15 Exception handling
6.5.0 General

 

| Rule 15-0-1 (Document) Exceptions shall only be used for error handling.

 

Rationale

The exception handling mechanism can provide an effective and clear means of handling error
conditions, particularly where a function needs to return both some desired result together with an
indication of success or failure. However, because of its ability to transfer control back up the call
tree, it can also lead to code that is difficult to understand. Hence it is required that the mechanism
is only used to capture behaviour that is in some sense undesirable, and which is not expected to
be seen in normal program execution.

Example

The try...catch mechanism is an acceptable means of catching error conditions thrown locally
or in any called functions.

For example, à file reader may fail in a number of different ways: failure to open the file, unexpected
or disallowed data in the file, insufficient data in the file, etc. The requirement to process data up to
the point where an error is detected, then to perform some tidy up action (or return some success
indicator if no error is found), could be achieved, either using soto (undesirable for the reasons
described in Rule 6—-6-1) or status flags and repeated nested tests to skip further processing once
an error is detected. It is argued that the try...catch mechanism provides a clearer way of
separating the expected and exceptional behaviours.

 

bool ReadFile ( const char *name )
{
Cry
{
if ( /* open name fails */ )
{
throw ( "failed to open file" );
}
144 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

if ( /* unexpected data */ )
{

throw ( "unexpected data found in file" );

}

return true;

}

catch ( const char *message )

{
// tidy up after failure to read
return false;

}
The following:

void fn { )
{

Cry

{

throw ( 10 ):
}
// Action "A"
}

catch ( int32 t y)
{
// Action "B"
}
}

could be used as an expensive and confusing way of implementing

if { x < 10 )
{

// Action "B"
}

else
{

// Action "A"
}

 

Rule 15-0-2 (Advisory) An exception object should not have pointer type.

 

Rationale

If an exception object of pointer type is thrown and that pointer refers to a dynamically created
object, then it may be unclear which function is responsible for destroying it, and when. This
ambiguity does not exist if the object is caught by value or reference.

 

145 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

Example

class À
{
// Implementation
};
void fn ( int16 € i )
{
static A al;
À * a2
if { i > 10
{

new À;

throw ( &al ); // Non-compliant - pointer type thrown
}

else
{
throw ( a2 ); // Non-compliant - pointer type thrown

 

Rule 15-0-3 (Required) Control shall not be transferred into a fry or catch block
using a g2ofo or a switch statement.

 

 

Rationale

À program is ill-formed if control is transferred into a #y or catch block using a goto or switch
statement; however, not all compilers issue a diagnostic message.

Example

void f ( int32 € i )
{
if ( 10 == i )
{
goto Label 10; // Non-compliant

if ( 11 == i )

goto Label 11; // Non-compliant
}

switch ( i )
{
case 1:
Cry
{
Label 10:
case 2: // Non-compliant - also violates switch rules
// Action
break;

 

146 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 
6. Rules (continued)

 

catch ( ... )

{
Label 11:
case 3: // Non-compliant - also violates switch rules
// Action
break;
}
break;
default:

{
// Default Action
break;

6.154 Throwing an exception

 

Rule 15-1-1 (Required) The assignment-expression of a throw statement shall
not itself cause an exception to be thrown.

 

 

 

Rationale

If an exception is thrown when constructing the exception object, or when evaluating the assignment
expression that initializes the exception object, it is that exception that propagates in preference to
the one that was about to be thrown. This may be inconsistent with developer expectations.

Example
class E
{
public:
E (){ 7} // Assume constructor cannot cause an exception
};
Cry
{
if ( )
{
throw E ( ); // Compliant - no exception thrown
} // when constructing the object

// construction of E2 causes an exception to be thrown
class E2
{
public:
E2 ( )
{
throw 10;

 

147 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

 

Cry
{
if ( ... )
{
throw E2 ( ); // Non-compliant - int exception thrown
// when constructing the E2 object
}
}
Rule 15-1-2 (Required) NULL shall not be thrown explicitly.
Rationale

throw(NULL) (equivalent to throw(0)) is never a throw of the null-pointer-constant and so is
only ever caught by an integer handler. This may be inconsistent with developer expectations,
particularly if the program only has handlers for pointer-to-type exceptions.

Example
Cry
{
throw ( NULL ); // Non-compliant
}
catch ( int32 € i ) // NULL exception handled here
{
//
}
catch ( const char &t * } // Developer may expect it to be caught here
{
//

}
char t * p = NULL;

Cry
{
throw ( static cast < const char t * > ( NULL ) }; // Compliant,
// but breaks
// Rule 15-0-2
throw ( p ); // Compliant

}

catch ( int32 € i )
{

//
}

catch ( const char t * ) // Both exceptions handled here
{
//

 

148 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Rule 15-1-3 (Required) An empty fhrow (throw;) shall only be used in the
compound-statement of a catch handler.

 

 

 

[Implementation 15.3(9), 15.5.1(2)]

Rationale
An empty ‘row re-throws the temporary object that represents an exception. Its use is intended to
enable the handling of an exception to be split across two or more handlers.

However, syntactically, there is nothing to prevent throw; being used outside a catch handler,
where there is no exception object to re-throw. This may lead to an implementation-defined
program termination.

Example
void f1 { void )
{
Cry
{
throw ( 42 ):;
}
catch ( int32 t i ) // int will be handled here first

{
if (ii > 0)
{

throw; // and then re-thrown - Compliant

}

}
void gi ( void )
{
Cry
{
ÊT ( );

}
catch ( int32 t i )

{
// Handle re-throw from £1 ( )
// after fl's handler has done what it needs

}

void £f2 { void )
{

throw; // Non-compliant
}
void g2 ( void )
{

Cry

{

throw; // Non-compliant

}

 

149 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

catch ( ... )

{
//
}

6.15.3 Handling an exception

 

Rule 15-3-1 (Required) Exceptions shall be raised only after start-up and
before termination of the program.

 

 

 

[Implementation 15.3(9), 15.5.1(2)]
Rationale

Throwing an exception during start-up or termination results in the program being terminated in
an implementation-defined manner.

Before the program starts executing the body of main, it is in a start-up phase, constructing and
initializing static objects. Similarly, after main has returned, it is in a termination phase where
static objects are being destroyed. If an exception is thrown in either of these phases it leads to the
program being terminated in an inplementation-defined manner. Specifically from Section 15.3(13)
of ISO/TEC 14882:2003 [1], if main is implemented as a function-try-block, exceptions raised
during start-up and close down are not caught by the catch block(s) of main.

This is in effect a special case of Rule 15-34, as there is nowhere a handler can be placed to catch
exceptions thrown during start-up or termination.

Example
class C
{
public:
C ()
{
throw ( O0 ); // Non-compliant - thrown before main starts
}
rC ()
{
throw ( O0 ); // Non-compliant - thrown after main exits
}
};
C c; // An exception thrown in C's constructor or destructor will

// cause the program to terminate, and will not be caught by
// the handler in main

int main( ... )
{
Cry
{
// program code
return 0:

 

150 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

// The following catch-all exception handler can only
// catch exceptions thrown in the above program code
catch ( ... )

{
// Handle exception
return 0:

See also
Rule 15-3-3, Rule 15-34, Rule 15-5-1, Rule 15-5-3

 

Rule 15-3-2 (Advisory) There should be at least one exception handler to catch
all otherwise unhandled exceptions

 

 

 

[Implementation 15.3(9), 15.5.1(2)]
Rationale

If a program throws an unhandled exception it terminates in an implementation-defined manner. In
particular, it is inplementation-defined whether the call stack is unwound, before termination, so the
destructors of any automatic objects may or may not be executed. By enforcing the provision of a
“last-ditch catch-all”, the developer can ensure that the program terminates in a consistent manner.

The objective of Rule 15-34 is that a program should catch all exceptions that it is expected to
throw. This rule’s objective is to ensure that exceptions that were not expected are also caught.

Example
For the majority of programs this will mean main should look like:

int32 t main( )
{

Cry

{

// program code
}
catch ( ... ) // Catch-all handler
{

// Handle unexpected exceptions

}

return 0;

See also
Rule 15-34, Rule 15-5-3

 

151 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 15-3-3 (Required) Handlers of a function-try-block implementation of a
class constructor or destructor shall not reference non-
static members from this class or its bases.

 

 

[Undefined 15.3(10)]
Rationale

The effect of accessing a non-static member of a class or a base class in the handler (1.e. the cafch
part) of a function-try-block of a class constructor/destructor is undefined.

For example, if a memory allocation exception is thrown during creation of the object, the object
will not exist when the handler attempts to access its members. Conversely, in the destructor, the
object may have been successfully destroyed before the exception is handled, so again will not be
available to the handler.

By contrast, the lifetime of a static member is greater than that of the object itself, so the static
member is guaranteed to exist when the handler accesses it.

Example
class C
{
public:
int32 € x;
C ()
Cry
{
// Action that may raise an exception
}
catch ( ... )
{
if ( 0 == ) // Non-compliant - x may not exist at this point
{
// Action dependent on value of x
}
}
CC)
Cry
{
// Action that may raise an exception
}
catch ( ... )
{
if (O0 == x )} // Non-compliant - x may not exist at this point
{
// Action dependent on value of x
}
}
};
See also

Rule 15-3-1, Rule 15-5-1

 

152 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 
6. Rules (continued)

 

 

Rule 15-3-4 (Required) Each exception explicitly thrown in the code shall have
a handler of a compatible type in all call paths that
could lead to that point.

 

 

 

[Implementation 15.3(9), 15.5.1(2)]
Rationale

If a program throws an unhandled exception, it terminates in an implementation-defined manner.
In particular, it is implementation-defined whether the call stack is unwound before termination,
so the destructors of any automatic objects may or may not be invoked.

If an exception is thrown as an object of a derived class, a “compatible type” may be either the
derived class or any of its bases.

The objective of this rule is that a program should catch all exceptions that it is expected to throw.
The objective of Rule 15—3-2 is to ensure that exceptions that were not expected are also caught.

Example

class A {};
class B {};

void f ( int32 € i ) throw ( )
{
Cry
{
if ( i > 10 )
{

throw À ( ); // Compliant
}
else
{
throw B ( ); // Non-compliant

}

}
catch ( À const & )

{
}
}

See also
Rule 15-32, Rule 15-5-3

 

Rule 15-3-5 (Required) À class type exception shall always be caught by
reference.

 

 

 

Rationale

If a class type exception objectis caught by value, slicing occurs. That is, if the exception objectis of
a derived class and is caught as the base, only the base class”’s functions (including virtual functions)
can be called. Also, any additional member data in the derived class cannot be accessed.

If the exception is caught by reference, slicing does not occur.

 

153 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

// base class for exceptions
class ExpBase
{
public:
virtual const char t *who ( )
{
return "base";
};
};
class ExpDl: public ExpBase
{
public:
virtual const char t *who ( )
{
return "type 1 exception";
};
};

class ExpD2: public ExpBase

{

public:
virtual const char t *who ( )
{

return "type 2 exception";

};

};

Cry
{
//
throw ExpDI ( );
//
throw ExpBase ( });
}
catch ( ExpBase &6b ) // Compliant - exceptions caught by reference
{
//

b.who(); // "base", "type 1 exception" or "type 2 exception"
// depending upon the type of the thrown object
}

// Using the definitions above
catch ( ExpBase b ) // Non-compliant - derived type objects will be
// caught as the base type

b.who(; // Will always be "base"
throw b; // The exception re-thrown is of the base class,
// not the original exception type

 

154 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 15-36 (Required) Where multiple handlers are provided in a single
try-catch statement or function-try-block for a derived
class and some or all of its bases, the handlers shall be
ordered most-derived to base class.

 

 

 

Rationale

When testing to see if the type of an exception matches the type of a handler, a derived class
exception will match with a handler for its base class. If the base class handler is found before
the handler for the derived class, the base class handler will be used. The derived class handler is
unreachable code and can never be executed.

Example

// classes used for exception handling
class B { }};
class D: public B { };

Cry
{
//
}
catch ( D &d ) // Compliant - Derived class caught before base class
{
//
}
catch ( B &b ) // Compliant - Base class caught after derived class
{
//

}

// Using the classes from above

Cry
{
//
}
catch ( B &b ) // Non-compliant - will catch derived classes as well
{
//
}
catch ( D &d ) // Non-compliant - Derived class will be caught above

// Any code here will be unreachable,
// breaking Rule 0-1-1

 

155 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 15-3-7 (Required) Where multiple handlers are provided in a single
try-catch statement or function-try-block, any ellipsis
(catch-all) handler shall occur last.

 

 

 

Rationale

If the catch-all handler is found before any other handler, that behaviour will be performed. Any
handlers after the catch-all are unreachable code and can never be executed.

Example
void £1 ( )
{
Cry
{
//
}
catch ( int32 t i ) // int handler
{
// Handle int exceptions
}
catch( ... ) // catch-all handler
{
// Handle all other exception types
}
}
void £2 € )
{
Cry
{
//
}
catch( ... ) // catch-all handler
{
// Handle all exception types
}
catch ( int32 t i ) // Non-compliant - handler will never be called

{
}

 

156 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

6.15.4 Exception specifications

 

Rule 15-4-1 (Required) If a function is declared with an exceptfion-specification,
then all declarations of the same function (in other
translation units) shall be declared with the same set of

type-ids.

 

 

 

[NDR 15.4(2)]
Rationale

Itis undefined behaviour if a function has different exception-specifications in different translation
units.

Example
// Translation unit A
void foo( ) throw ( const char t * )

{
throw "Hello Worlda!":

}

// Translation unit B
// foo declared in this translation unit with a différent exception
// specification
extern void foo ( ) throw ( int32 € ); // Non-compliant -
// different specifier

void b ( ) throw ( int32 € )
{

foo { ); // The behaviour here is undefined.

}

6.5.5 Special functions

 

Rule 15-5-1 (Required) A class destructor shall not exit with an exception. |

 

[Implementation 15.3(9), 15.5.1(2)]
Rationale

When an exception is thrown, the call stack is unwound up to the point where the exception is
to be handled. The destructors for all automatic objects declared between the point where the
exception is thrown and where it is to be handled will be invoked. If one of these destructors exits
with an exception, then the program will terminate in an implementation-defined manner.

Note thatit is acceptable for a destructor to throw an exception that is handled within the destructor,
for example within a #y-cafch block.

 

157 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
class CI
{
public:
C1 ()
{
Cry
{
throw ( 42 ); // Compliant - exception will not leave
// destructor
}
catch ( int32 € i ) // int handler
{
// Handle int exception throw by destructor
}
}
};
class C2
{
public:
C2 ()

{
throw ( 42 ); // Non-compliant - destructor exits with an
// exception

};
void foo ( )

{

C2 c; // program terminates when c is destroyed

throw ( 10 ):

See also
Rule 15-3-1, Rule 15-3-3, Rule 15—5-3

 

Rule 15-5-2 (Required) Where a function’s declaration includes an exception-
specification, the function shall only be capable of
throwing exceptions of the indicated type(s).

 

 

 

[Implementation 15.5.1(2)]
Rationale

If a function declared with an exception-specification throws an exception of a type not included
in the specification, the function unexpected() is called. The behaviour of this function can be
overridden within a project, but by default causes an exception of séd::bad exception to be thrown.
If std::bad exception is not listed in the excepfion-specification, then ferminate() will be called,
leading to implementation-defined termination of the program.

 

158 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example

// foo does not have an exception specification, so can propagate
// exceptions of any type, including int
void foo ( )
{
throw ( 21 );
}

// goo specifies that it will only throw exceptions of type Exception.

/J If foo throws an int the function unexpected() is called, which may
// terminate the program
void goo ( )} throw ( Exception )
{
foo ( ); // Non-compliant - int is not listed in the

// throw specification

}

 

Rule 15-5-3 (Required) The ferminate() function shall not be called implicitly. |

 

[Implementation 15.5.1(2)]
Rationale

Itis inplementation-defined whether the call stack is unwound before ferminate() is called, so the
destructors of any automatic objects may or may not be executed.

See also

Rule 15-3-1, Rule 15-3-2, Rule 15-34, Rule 15-5-1. The situations addressed by these rules
cause the program to call ferminate() and so exhibit inplementation-defined behaviour.

6.16 Preprocessing directives
6.6.0 General

 

Rule 16-0-1 (Required) #include directives in a file shall only be preceded by
other preprocessor directives or comments.

 

 

 

Rationale

To aid code readability, all the #include directives in a particular code file should be grouped
together near the head of the file. The only items which may precede à #include in a file are other
preprocessor directives or comments.

Example
#include <f1.h> // Compliant
int32 € i;
#include <f2.h> // Non-compliant

 

159 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 16-0-2 (Required) Macros shall only be #define’d or #undef d in the global
namespace.

 

 

 

Rationale

Whileitis legal to place #define or #undef directives anywhere in a source file, placing them outside
of the global namespace is misleading as their scope is not restricted. This may be inconsistent
with developer expectations.

Example

#ifndef MY HDR
#define MY HDR // Compliant

namespace NS

{

 

 

#define FOO // Non-compliant
#undef FOO // Non-compliant
}
#endif
See also
Rule 16-0-3
| Rule 16-0-3 (Required) #undef shall not be used.
Rationale

#undef should not normally be needed. Its use can lead to confusion with respect to the existence
or meaning of a macro when it is used in the code.

Example

#ifndef MY HDR
#define MY HDR

 

 

#undef MY HDR // Non-compliant
#endif
Rule 16-04 (Required) Function-like macros shall not be defined. |
[Undefined 16.3(10)]
Rationale

While macros can provide a speed advantage over functions, functions provide a safer and more
robust mechanism. This is particularly true with respect to the type checking of parameters, and
the problem of function-like macros potentially evaluating parameters multiple times.

Inline functions should be used instead.

Example
#define FUNC MACRO(X) ((X)+(X)) // Non-compliant

 

160 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 16—-0-5 (Required) Arguments to a function-like macro shall not contain
tokens that look like preprocessing directives.

 

 

[Undefined 16.3(10)]
Rationale

If any of the arguments act like preprocessor directives, the behaviour when macro substitution is
made can be unpredictable.

Example
#define M(A) printf ( #A )

void main ( )

{

M\

#ifdef SW // Non-compliant
"Message 1"

#else // Non-compliant
"Message 2"

#endif // Non-compliant

)3
}

The above may print
#ifdef SW "Message 1" #else "Message 2" #endif

 

 

 

 

OT
Message 2
Rule 16-06 (Required) In the definition of à function-like macro, each instance
of a parameter shall be enclosed in parentheses, unless
it is used as the operand of # or ##.
Rationale

If parentheses are not used, then the operator precedence may not give the desired results when
the preprocessor substitutes the macro into the code.

Within a definition of a function-like macro, the arguments shall be enclosed in parentheses.

Example
Define an abs function using:

#define abs(x) (({{x) >= 0) ? (x) : -({x)) // Compliant
and not:

#define abs(x) ({x >= 0) ? x : -x) // Non-compliant

Consider what happens if the second, incorrect, definition 1s substituted into the expression:
Z abs( a - b );

giving:

Z {({a - b >= 0) ? a - b : -a —- b):

 

161 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 
6. Rules (continued)

 

The sub-expression -a - Lis equivalent to (-a)-b rather than - (a-b) as intended. Putting all the
parameters in parentheses in the macro definition avoids this problem.

#define subs(x) a ## x // Compliant

 

 

 

 

Rule 16-0-7 (Required) Undefined macro identifiers shall not be used in #f or
#elif preprocessor directives, except as operands to the
defined operator.

Rationale

If an attempt is made to use an identifier in a preprocessor directive, and that identifier has not been
defined, the preprocessor will assume the value zero. #ifdef, #ifndef and defined() are provided to
test the existence of a macro, and are therefore excluded.

Example

#if x < 0 // Non-compliant - x assumed to be zero as it is not defined
Consideration should be given to the use of a #ifdef test before an identifier is used.

Note that preprocessing identifiers may be defined either by use of #define directives or by options
specified at compiler invocation. However, the use of the “define directive is preferred.

 

Rule 16-08 (Required) If the # token appears as the first token on a line, then it
shall be immediately followed by a preprocessing token.

 

 

 

Rationale

When a section of source code is excluded by preprocessor directives, the content of each excluded
statement is ignored until a #else, #elif or #endif directive is encountered (depending on the
context). If one of these excluded directives is badly formed, it may be ignored without warning
by a compiler with unexpected consequences.

The requirement of this rule is that all preprocessor directives shall be syntactically valid even
when they occur within an excluded block of code.

In particular, ensure that “else and #endif directives are not followed by any characters other than
white-space. Compilers are not always consistent in enforcing this requirement.

Example
#define AAA 2

int32 t foo(void)
{
int32 t x = 0;

#ifndef AAA
x = 1;

#elsel // Non-compliant
x = AAA;

#endif

return x;

 

162 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

616.1 Conditional inclusion

 

Rule 16-1-1 (Required) The defined preprocessor operator shall only be used in
one of the two standard forms.

 

 

 

[Undefined 16.1(4)]
Rationale

The only two permissible forms for the defined preprocessor operator are:

defined ( identifier })
defined identifier

Any other form is a constraint violation, but this is not reported by all compliers.

Example

#Iif defined ( X > Y }) // Non-compliant - constraint violation
Generation of the token defined during expansion of a #if or #elif preprocessing directive also
leads to undefined behaviour and shall be avoided, for example:

#define DEFINED defined
#if£ DEFINED(X) // Non-compliant - undefined behaviour

 

Rule 16-1-2 (Required) AII #else, #elif and #endif preprocessor directives shall
reside in the same file as the #if or #ifdef directive to
which they are related.

 

 

 

Rationale

When the inclusion and exclusion of blocks of statements is controlled by a series of preprocessor
directives, confusion can arise if all of the relevant directives do not occur within one file. This
rule requires that all preprocessor directives in a sequence of the form #if/ #ifdef … #elif … #else
… #endif shall reside in the same file. Observance of this rule preserves good code structure and
avoids maintenance problems.

Notice that this does not preclude the possibility that such directives may exist within included
files provided that all directives that relate to the same sequence are located in one file.

Example
// file.cpp
#define A
#ifdef A
#include "file1.hpp"
#
#endif
#if 1
#include "file2.hpp"

 

163 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

// filel.hpp

#if 1

#endif

#endif

// Compliant
// file2.hpp

//. Non-compliant

616.2 Source file inclusion

 

Rule 16-2-1

 

(Required)

The pre-processor shall only be used for file inclusion
and include guards.

 

 

Rationale

C++ provides safer ways of achieving what is often done using the pre-processor, by way of inline
functions and constant declarations.

 

 

 

 

Example
#ifndef HDR // Compliant
#define HDR // Compliant
#define X(Y) (v) // Non-compliant
#endif
See also
Rule 16-2-2
Rule 16-2-2 (Required) C++ macros shall only be used for include guards, type
qualifiers, or storage class specifiers.
Rationale

These are the only permitted uses of macros. C++ offers const variable and function templates,
which provide a type-safe alternative to the preprocessor.

Note that the use of macros for type qualifiers and storage class specifiers will break

Rule 16—2-1.

Example

// The following are compliant

 

#define STOR extern // storage class specifier

// Breaks Rule 16-2-1
// The following are non-compliant
#define CLOCK (xtal/16) // Constant expression
#define PLUS2(X) ({X) + 2) // Macro expanding to expression
#define PI 3.14159F // use const object instead
#define int32 t long // use typedef instead
#define STARTIF if( // language redefinition
#define INIT(value) {(value), 0, 0} // braced initializer
#define HEADER "filename.h" // string literal

164 Licensed to: Insigma Raïl Transport. Engineering Co.

He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

See also
Rule 16—2-1

 

Rule 16-2-3 (Required) Include guards shall be provided.

 

The include guard shall use one of the following two forms:

<start-of-file>
// Comments allowed here
#if !defined ( identifier )
#define identifier

// Contents of file
#endif
<end-of-file>

<start-of-file>
// Comments allowed here
#ifndef identifier
#define identifier

// Contents of file
#endif
<end-of-file>

Rationale

When a translation unit contains a complex hierarchy of nested header files, it is possible for a
particular header file to be included more than once. This can be, at best, a source of confusion. If
this multiple inclusion leads to multiple or conflicting definitions, then this can result in undefined
or erroneous behaviour.

These forms are mandated to facilitate checking.

Example

// file.h
#ifndef FILE H

#endif

// file.cc
#include "file.n"
#define FILE H // Non-compliant

 

Rule 16-24 (Required) The : ,",/* or // characters shall not occur in a zeader
file name.

 

 

 

[Undefined 2.8(2)]
Rationale

Itis undefined behaviour if the ‘, ", /* or // characters are used between < and > delimiters or the
‘, /* or // characters are used between the " delimiters in a header name preprocessing token.

Example
#include "fi'le.h" // Non-compliant

 

165 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

| Rule 16-2-5 (Advisory) The \ character should not occur in a header file name. |
[Undefined 2.8(2)]

 

Rationale

It is undefined behaviour if the \ character is used between < and > delimiters or between the "
delimiters in a header name preprocessing token.

Note that this rule is only advisory, since some environments use \ as a file name delimiter.
Compilers for these environments often support the use of / in #include directives.

 

 

 

 

Example
#include "fi\\le.n" // Non-compliant
Rule 16-26 (Required) The #include directive shall be followed by either a
<filename> or "filename" sequence.
[Undefined 16.2(4)]
Rationale

These are the only forms for the #include directive permitted by ISO/IEC 14882:2003 [1].

Example
#include "filename.h" // Compliant
#include <filename.h> // Compliant
#define HEADER "filename.h" // Non-compliant with Rule 16-2-2
#include HEADER // Compliant
#include another.h // Non-compliant

6.16.3 Macro replacement

 

Rule 16-3-1 (Required) There shall be at most one occurrence of the # or ##
operators in a single macro definition.

 

 

 

[Unspecified 16.3.2(2), 16.3.3(3). Undefined 16.3.2(2). 16.3.3G3)]
Rationale

The order of evaluation associated with both the # and 44 preprocessor operators 1s unspecified.
This problem can be avoided by having only one occurrence of either operator in any single macro
definition (1.e. one #, or one ## or neiïther).

Example
#define A(x) #x // Compliant
#define B(x, y) X HE V // Compliant
#define C(x, y) OX HE V // Non-compliant

In the following, if y is joined to z first then the fourth parameter of D will be substituted and
joined to x. Alternatively, if x is joined with y first, then the fourth parameter of D will not be
substituted.

#define D(x, y, 2, yz) x ## y ##z // Non-compliant

 

166 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

| Rule 16-3-2 (Advisory) The # and ## operators should not be used. |

 

[Unspecified 16.3.2(2), 16.3.3(3). Undefined 16.3.2(2). 16.3.3G3)]
Rationale

The order of evaluation associated with both the # and 44 preprocessor operators 1s unspecified.
Compilers have been known to implement these operators inconsistently, therefore, to avoid these
problems, do not use them.

Example
#define A(Y) #Y // Non-compliant
#define A(X,Y) X#4#Y // Non-compliant

616.6 Pragma directive

 

Rule 16-6-1 (Document) All uses of the #pragma directive shall be documented. |

 

[Implementation 16.6(1)]
Rationale

The #pragma directive is implementation-defined, hence it is important to demonstrate that all
uses are correct.

This rule places à requirement on the user of this document to produce à list of any pragmas
they choose to use in an application. The meaning of each pragma shall be documented. There
shall be sufficient supporting description to demonstrate that the behaviour of the pragma and its
implications for the application, have been fully understood.

Any use of pragmas Should be minimized, localized and encapsulated within dedicated functions
wherever possible.

6.17 Library introduction
6.17.0 General

 

Rule 17-0-1 (Required) Reserved identifiers, macros and functions in the
standard library shall not be defined, redefined or
undefined.

 

 

 

[Undefined 16.8(3)]
Rationale

It is generally bad practice to #undef a macro that is defined in the standard library. It is also bad
practice to #define a macro name that is a C++ reserved identifier, or C++ keyword or the name
of any macro, object or function in the standard library. For example, there are some specific
reserved words and function names that are known to give rise to undefined behaviour if they are
redefined or undefined, including defined, LINE  , FILE , DATE , TIME,
__STDC __, errno and assert.

Refer to ISO/IEC 14882:2003 [1] for a list of the identifiers that are reserved. Generally, all
identifiers that begin with the underscore character are reserved.

 

167 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Note that this rule applies regardless of which header files, if any, are actually included.

 

 

 

 

Example
#define TIME 11111111 // Non-compliant
See also
Rule 16—0-3
Rule 17-0-2 (Required) The names of standard library macros and objects shall
not be reused.
Rationale

Where the developer uses new versions of standard library macros or objects (e.g. to enhance
functionality or add checks of input values), the modified macro or object shall have a new name.
This is to avoid any confusion as to whether à standard macro or object, or a modified version of
them, is being used.

 

 

 

 

Example
#define NULL ( a > b ) // Non-compliant
Rule 17-0-3 (Required) The names of standard library functions shall not be
overridden.
Rationale

Where the developer uses new versions of standard library functions (e.g. to enhance functionality
or add checks of input values), the modified function shall have a new name. However, it 1s
permissible to overload the name to add new parameter types if the functionality is consistent
with those of the original. This ensures that the behaviour associated with the name remains
consistent. So, for example, if a new version of the sgrf function is written to check that the input
is not negative, the new function shall not be named ‘“sqrt”, but shall be given a new name. It is
permissible to add a new sgrf function for a type not present in the library.

Example
int32 t printf ( int32 t a, int32 t b) // Non-compliant
{
return { (a > b) ? a : b );

}

 

| Rule 17-0-4 (Document) AII library code shall conform to MISRA C++. |

 

Rationale

The quality of any libraries (linked or included) must be to at least the same standard (i.e. SIL
level) as the rest of the project.

Library code may exist either as source code or object code. Either type shall include documentation
to demonstrate how that code complies with MISRA C++.

 

168 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

 

Rule 17-0-5 (Required) The sefjmp macro and the /ongimp function shall not be
used.

 

 

 

Rationale

setimp and longjmp allow the normal function call mechanisms to be bypassed, and shall not be
used, since exception handling provides a better defined mechanism for this.

Example
#include <setjmp.h>
void £2 { );
jmp_ buf buf;
void £1 ( )
{
if ( !lsetj]mp ( buf }) ) // Non-compliant
{
£2 ( );
}
else
{
}
}
void £2 € )
{
longimp ( buf, 10 ); // Non-compliant

}

6.18 Language support library
6.8.0 General

 

| Rule 18-0-1 (Required) The C library shall not be used. |

 

Rationale

Some C++ libraries (e.g. <cstdio) also have corresponding € versions (e.8. <stdio.h7). This rule
requires that the C++ version is used.

 

Rule 18-0-2 (Required) The library functions atof, atoi and atol from library
<estdlib> shall not be used.

 

 

 

Rationale

These functions have undefined behaviour associated with them when the string cannot be
converted.

Example
#include <cstdlib>

 

169 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

int32 € £ ( const char t * numstr )
{
return atoi ( numstr ): // Non-compliant
}
See also

ISO/TEC 9899:1990 [16] $7.10.1

 

Rule 18-0-3 (Required) The library functions abort, exit, getenv and system from
library <csfdlib> shall not be used.

 

 

 

Rationale

The use of these functions leads to inplementation-defined behaviour.

 

 

 

 

Example
#include <cstdlib>
void £ ( )
{
exit ( O ): // Non-compliant
}
Rule 18-04 (Required) The time handling functions of library <cfime> shall not
be used.
Rationale

Various aspects are inmplementation-defined or unspecified, such as the formats of times.

 

 

 

 

Example

#include <ctime>

void £ ( )

{

clock ( ): // Non-compliant

}

Rule 18-0-5 (Required) The unbounded functions of library <cstring> shall not
be used.
[Undefined 5.7]

Rationale

The s#rcpy, stremp, strcat, strchr, strspn, strespn, strpbrk, strrchr, strstr, strtok and strlen functions
within the <cstring> library can read or write beyond the end of a buffer, resulting in #ndefined
behaviour.

Ideally, a safe string handling library should be used.

 

170 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
#include <cstring>
void fn ( const char t * pChar )
{
char t array [ 10 ];

strepy ( array, pChar ); // Non-compliant

618.2 Implementation properties

 

Rule 18-2-1 (Required) The macro offsetof shall not be used.

 

Rationale

Use of this macro can lead to undefined behaviour when the types of the operands are incompatible,
or when bit fields are used.

Example
#include <cstddef>

struct A
{
int32 € i;
};
void £1 ( )

{
offsetof ( A, 1 }; // Non-compliant

}

6.18.4 Dynamic memory management

 

Rule 18—-4-1 (Required) Dynamic heap memory allocation shall not be used.

 

Rationale
The use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.

The built-in new and delete operators, other than the placement versions, use dynamic heap
memory. The functions calloc, malloc, realloc and free also use dynamic heap memory.

There is a range of unspecified, undefined and implementation-defined behaviour associated with
dynamic memory allocation, as well as a number of other potential pitfalls. Dynamic heap memory
allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic
behaviour, etc.

Note that some implementations may use dynamic heap memory allocation to implement other
functions (for example, functions in the library csfring). If this is the case, then these functions
shall also be avoided.

 

171 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

Example
void £1 ( )
{
int32 t * i = new int32 t; // Non-compliant
delete i;

}

618.7 Other runtime support

 

Rule 18-7-1 (Required) The signal handling facilities of <csignal> shall not be
used.

 

 

 

Rationale

Signal handling contains implementation-defined and undefined behaviour.

Example
#include <csignal>
void my handler ( int32 € );

void £1 ( )
{

signal ( 1, my handler ); // Non-compliant
}

6.19 Diagnostics library
6.19.3 Error numbers

 

| Rule 19-3-1 (Required) The error indicator errno shall not be used.

 

Rationale

errno is à facility of C++ which should in theory be useful, but which in practice is poorly defined
by ISO/IEC 14882:2003 [1]. A non-zero value may or may not indicate that a problem has occurred;
therefore errno shall not be used.

Even for those functions for which the behaviour of errno is well defined, it is preferable to check
the values of inputs before calling the function rather than relying on using errno to trap errors.

Example

#include <cstdlib>
#include <cerrno>

void FT ( const char t * str )

{
errno = 0; // Non-compliant
int32 € i atoi ( str );

 

172 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
6. Rules (continued)

 

1f ( O != errno }) // Non-compliant

{

// handle error case???
}
}

See also
Rule 0-32

6.27 Input/output library
6.27.0 General

 

Rule 27-0-1 (Required) The stream input/output library <cstdio> shall not be
used.

 

 

 

Rationale
This includes file and 1/0 functions fgefpos, fopen, ftell, gets, perror, remove, rename, etc.

Streams and file 1/0 have a large number of unspecified, undefined and implementation-defined
behaviours associated with them.

Example
#include <cstdio> // Non-compliant
void fn { )
{
char t array [ 10 ];
gets ( array ); // Can lead to buffer over-run

 

173 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
References

 

[10]

[11]

[12]

[13]

[14]
[15]

[16]

[17]

[18]

References

ISO/IEC 14882:2003, The C++ Standard Incorporating Technical Corrigendum 1,
International Organization for Standardization, 2003.

MISRA Development Guidelines for Vehicle Based Software, ISBN 0-9524156-0-7, Motor
Industry Research Association, Nuneaton, November 1994.

MISRA AC INT Jntroduction to the MISRA guidelines for the use of automatic code
generation in automotive systems, ISBN 978-1-906400-00-2, MIRA Limited, November
2007.

CRR&0, The Use of Commercial Off-the-Shelf (COTS) Software in Safety Related
Applications, ISBN 0-7176-0984-7, HSE Books.

ISO 9001:2000, Quality management systems — Requirements, International Organization
for Standardization, 2000.

ISO 90003:2004, Sofiware engineering — Guidelines for the application of ISO
9001:2000 to computer software, ISO, 2004.

The TickIT Guide, Using ISO 9001:2000 for Software Quality Management System
Construction, Certification and Continual Improvement, Issue 5, British Standards
Institution, 2001.

Straker D., C Style: Standards and Guidelines, ISBN 0-13-116898-3, Prentice Hall 1991.

Fenton NE. and Pfleeger S.L., Software Metrics: À Rigorous and Practical Approach, 2nd
Edition, ISBN 0-534-95429-1, PWS, 1998.

MISRA Report 5, Software Metrics, Motor Industry Research Association, Nuneaton,
February 1995.

MISRA Report 6, Verification and Validation, Motor Industry Research Association,
Nuneaton, February 1995.

IEC 61508, Functional safety of electrical/electronic/programmable electronic safety-
related systems, International Electromechanical Commission, in 7 parts published
between 1998 and 2000.

Goldberg D., What Every Computer Scientist Should Know about Floating-Point
Arithmetic, Computing Surveys, March 1991.

ANSVIEEE Std 754, EEE Standard for Binary Floating-Point Arithmetic, 1985.

ISO/IEC 10646:2003, Information technology — Universal Multiple-Octet Coded
Character Sets (UCS), International Organization for Standardization, 2003.

ISO/IEC 9899:1990, Programming Languages — €, International Organization for
Standardization, 1990.

Hill M.G. and Whiting E.V, An Investigation of the Unpredictable Features of the C++
Language, QINETIQ/K1/TIM/TR043014, QinetiQ, May 2004.

High-Integrity C++ Coding Standard Manual Version 2.2, The Programming Research

Group, May 2004.

174 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
7.

References (continued)

 

[19]

[20]

ND
D
==

1
È

= Re mm ee
D ND
Ua Lo
Le ==

LD
GS
ei

Joint Strike Fighter Air Vehicle C++ Coding Standards for the System Development
and Demonstration Program, Document Number 2RDU00001 Rev C, Lockheed Martin,
December 2005.

Henricson M., Nyquist E., Industrial Strength C++, ISBN 0-13-120965-5, Prentice Hall,
1997.

Sutter H., Exceptional C++, ISBN 0-201-61562-2, Addison-Wesley, 1999.

Koenig À., C Traps and Pitfalls, ISBN 0-201-17928-8, Addison-Wesley, 1988.

Hatton L., Safer C, ISBN 0-07-707640-0, McGraw-Hill, 1994.

Dewhurst $S., C++ Gotchas, ISBN 0-321-12518-5, Addison-Wesley, 2003.

Meyers S., More Efjective C++, ISBN 0-201-63371-X, Addison-Wesley, 1996.

Meyers $., Effective C++, ISBN 0-321-33487-6 (Third Edition), Addison-Wesley, 2005.

À

175 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Appendix A

 

Appendix A: Summary of rules

Unnecessary constructs
RuleO-1-1 (Required) A project shall not contain unreachable code.

RuleO-1-2 (Required) A project shall not contain infeasible paths.
RuleO-1-3 (Required) A project shall not contain unused variables.

RuleO-1-4 (Required) A project shall not contain non-volatile POD variables having only
one use.

RuleO-1-5 (Required) A project shall not contain unused type declarations.

Rule 0-16 (Required) A project shall not contain instances of non-volatile variables being
given values that are never subsequently used.

RuleO-1-7 (Required) The value returned by a function having a non-void return type that
is not an overloaded operator shall always be used.

RuleO-1-8 (Required) All functions with void return type shall have external side
effect(s).

Rule Q-1-9 (Required) There shall be no dead code.
Rule 0-1-10 (Required) Every defined function shall be called at least once.

Rule OQ-1-11 (Required) There shall be no #nused parameters (named or unnamed) in non-
virtual functions.

Rule Q-1-12 (Required) There shall be no unused parameters (named or unnamed) in the
set of parameters for a virtual function and all the functions that
override it.

Storage
RuleO0-2-1 (Required) An object shall not be assigned to an overlapping object.

Runtime failures

Rule 0-3-1 (Document) Minimization of run-time failures shall be ensured by the use of at
least one of:

(a) static analysis tools/techniques;
(b) dynamic analysis tools/techniques;
(c) explicit coding of checks to handle run-time faults.

Rule0-3-2 (Required) If a function generates error information, then that error information
shall be tested.

Arithmetic
Rule0-4-1 (Document) Use of scaled-integer or fixed-point arithmetic shall be
documented.

Rule0-4-2 (Document) Use of floating-point arithmetic shall be documented.

 

176 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 0-4-3 (Document)
Language

Rule 1-0-1 (Required)
Rule 1-0-2 (Document)
Rule 1-0-3 (Document)

Character sets

Rule 2-2-1 (Document)

Trigraph sequences

Rule 2-3-1 (Required)

Alternative tokens
Rule 2-5-1 (Advisory)

Comments

Rule 2-7-1 (Required)

Rule 2-7-2 (Required)

Rule 2-7-3 (Advisory)

Identifiers
Rule 2-10-1

Rule 2-10-2

(Required)
(Required)
Rule 2-10-3 (Required)
Rule 2-10-4 (Required)

Rule 2-10-5 (Advisory)

Rule 2-10-6 (Required)

Floating-point implementations shall comply with a defined floating-
point standard.

All code shall conform to ISO/IEC 14882:2003 “The C++ Standard
Incorporating Technical Corrigendum 1”.

Multiple compilers shall only be used if they have a common,
defined interface.

The implementation of integer division in the chosen compiler shall
be determined and documented.

The character set and the corresponding encoding shall be
documented.

Trigraphs shall not be used.

Digraphs should not be used.

The character sequence /* shall not be used within a C-style
comment.

Sections of code shall not be “commented out” using C-style
comments.

Sections of code should not be ‘“commented out” using C++
comments.

Different identifiers shall be typographically unambiguous.

Identifiers declared in an inner scope shall not hide an identifier
declared in an outer scope.

A typedef name (including qualification, 1f any) shall be à unique
identifier.

À class, union or enum name (including qualification, if any) shall
be a unique identifier.

The identifier name of a non-member object or function with static
storage duration should not be reused.

If an identifier refers to a type, it shall not also refer to an object or
a function in the same scope.

 

Licensed to: Insigma Raïl Transport. Engineering Co.

177
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Literals
Rule2-13-1 (Required)

Rule 2-13-2 (Required)
Rule 2-13-3 (Required)

Rule 2-13-4
Rule 2-13-5

(Required)
(Required)

Only those escape sequences that are defined in ISO/TEC 14882:2003
shall be used.

Octal constants (other than zero) and octal escape sequences (other
than “\ 0”) shall not be used.

À “U” suffix shall be applied to all octal or hexadecimal integer
literals of unsigned type.

Literal suffixes shall be upper case.

Narrow and wide string literals shall not be concatenated.

Declarations and definitions

Rule 3-1-1 (Required)
Rule 3-1-2 (Required)
Rule 3-1-3 (Required)

One Definition Rule

Rule 3-2-1 (Required)
Rule 3-2-2 (Required)
Rule 3-2-3 (Required)
Rule 3-2-4 (Required)

It shall be possible to include any header file in multiple translation
units without violating the One Definition Rule.

Functions shall not be declared at block scope.

When an array is declared, its size shall either be stated explicitly or
defined implicitly by initialization.

All declarations of an object or function shall have compatible
Lypes.

The One Definition Rule shall not be violated.

A type, object or function that is used in multiple translation units
shall be declared in one and only one file.

An identifier with external linkage shall have exactly one
definition.

Declarative regions and scope

Rule 3-3-1 (Required)

Rule 3-3-2 (Required)

Name lookup

Rule3-4-1 (Required)
Types
Rule 3-9-1 (Required)

Objects or functions with external linkage shall be declared in a
header file.

If a function has internal linkage then all re-declarations shall include
the sfatic storage class specifier.

An identifier declared to be an object or type shall be defined in a
block that minimizes its visibility.

The types used for an object, a function return type, or a function
parameter shall be token-for-token identical in all declarations and
re-declarations.

 

178 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 3-9-2 (Advisory)

Rule3-9-3 (Required)

Integral promotions

Rule 4-5-1 (Required)
Rule 4-5-2 (Required)
Rule 4-5-3 (Required)

Pointer conversions
Rule 4-10-1 (Required)

Rule 4-10-2 (Required)

Expressions

Rule 5-0-1 (Required)
Rule 5-0-2 (Advisory)
Rule 5-0-3 (Required)
Rule 5-04 (Required)
Rule 5-0-5 (Required)
Rule 5-06 (Required)
Rule 5-0-7 (Required)
Rule 5—0-8 (Required)
Rule 5-0-9 (Required)

typedefs that indicate size and signedness should be used in place of
the basic numerical types.

The underlying bit representations of floating-point values shall not
be used.

Expressions with type bool shall not be used as operands to built-in
operators other than the assignment operator -, the logical operators
&&, ||, !, the equality operators == and !=, the unary & operator, and
the conditional operator.

Expressions with type enum shall not be used as operands to built-
in operators other than the subscript operator [ 1, the assignment
operator -, the equality operators == and !=, the unary & operator,
and the relational operators <, <=, >, >=.

Expressions with type (plain) char and wchar_t shall not be used as
operands to built-in operators other than the assignment operator -,
the equality operators == and !=, and the unary & operator.

NULL shall not be used as an integer value.

Literal zero (0) shall not be used as the nu/l-pointer-constant.

The value of an expression shall be the same under any order of
evaluation that the standard permits.

Limited dependence should be placed on C++ operator precedence
rules in expressions.

A cyalue expression shall not be implicitly converted to a different
underlying type.

An implicit integral conversion shall not change the signedness of
the underlying type.

There shall be no implicit floating-integral conversions.

An implicit integral or floating-point conversion shall not reduce the
size of the underlying type.

There shall be no explicit floating-integral conversions of a cvalue
expression.

An explicit integral or floating-point conversion shall not increase
the size of the underlying type of a cvalue expression.

An explicit integral conversion shall not change the signedness of
the underlying type of a cvalue expression.

 

179 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 50-10

Rule 50-11

Rule 50-12

Rule 50-13

Rule 5-0-14
Rule 50-15
Rule 50-16

Rule 50-17

Rule 50-18

Rule 50-19

Rule 50-20

Rule 50-21

(Required)

(Required)

(Required)

(Required)

(Required)
(Required)
(Required)

(Required)

(Required)

(Required)

(Required)

(Required)

Postfix expressions

Rule 5—2-1
Rule 5-22

Rule 5—2-3

Rule 5-24

Rule 5—2-5

Rule 5-26

Rule 5—2-7

(Required)
(Required)

(Advisory)

(Required)

(Required)

(Required)

(Required)

If the bitwise operators - and << are applied to an operand with an
underlying type of unsigned char or unsigned short, the result shall
be immediately cast to the underlying type of the operand.

The plain char type shall only be used for the storage and use of
character values.

signed char and unsigned char type shall only be used for the storage
and use of numeric values.

The condition of an if-statement and the condition of an iteration-
statement shall have type bool.

The first operand of à conditional-operator shall have type bool.
Array indexing shall be the only form of pointer arithmetic.

A pointer operand and any pointer resulting from pointer arithmetic
using that operand shall both address elements of the same array.

Subtraction between pointers shall only be applied to pointers that
address elements of the same array.

>, >=, <, <= Shall not be applied to objects of pointer type, except
where they point to the same array.

The declaration of objects shall contain no more than two levels of
pointer indirection.

Non-constant operands to a binary bitwise operator shall have the
same underlying type.

Bitwise operators shall only be applied to operands of unsigned
underlying type.

Each operand of a logical 44 or | | shall be à postfix-expression.

À pointer to a virtual base class shall only be cast to a pointer to a
derived class by means of dynamic cast.

Casts from a base class to a derived class should not be performed
on polymorphic types.

C-style casts (other than void casts) and functional notation casts
(other than explicit constructor calls) shall not be used.

A cast shall not remove any const or volatile qualification from the
type of a pointer or reference.

À cast shall not convert a pointer to a function to any other pointer
type, including a pointer to function type.

An object with pointer type shall not be converted to an unrelated
pointer type, either directly or indirectly.

 

180 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 5-2-8 (Required)

Rule 5-2-9 (Advisory)
Rule 5-2-10 (Advisory)

Rule 5-2-11 (Required)

Rule 52-12 (Required)

Unary expressions

Rule 5-3-1 (Required)
Rule 5-3-2 (Required)
Rule 5-3-3 (Required)
Rule 5-34 (Required)

Shift operators

Rule 5-8-1 (Required)

Logical AND operator
Rule 5-14-1 (Required)

Assignment operators
Rule 5-17-1 (Required)

Comma operator
Rule 5-18-1 (Required)

Constant expressions
Rule 5-19-1 (Advisory)

Expression statement

Rule 6-2-1 (Required)

An object with integer type or pointer to void type shall not be
converted to an object with pointer type.

À cast should not convert a pointer type to an integral type.

The increment (++) and decrement (--) operators should not be
mixed with other operators in an expression.

The comma operator, &£& operator and the || operator shall not be
overloaded.

Anidentifier with array type passed as a function argument shall not
decay to a pointer.

Each operand of the ! operator, the logical && or the logical ||
operators shall have type bool.

The unary minus operator shall not be applied to an expression
whose underlying type is unsigned.

The unary & operator shall not be overloaded.

Evaluation of the operand to the sizeof operator shall not contain
side effects.

The right hand operand of a shift operator shall lie between zero and
one less than the width in bits of the underlying type of the left hand
operand.

The right hand operand of a logical && or || operator shall not
contain side effects.

The semantic equivalence between a binary operator and its
assignment operator form shall be preserved.

The comma operator shall not be used.

Evaluation of constant unsigned integer expressions should not lead
to wrap-around.

Assignment operators shall not be used in sub-expressions.

 

Licensed to: Insigma Raïl Transport. Engineering Co.

181
8 He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 6-2-2 (Required)

Rule 6-2-3 (Required)

Compound statement

Rule 6-3-1 (Required)

Selection statements

Rule 6-4-1 (Required)
Rule 6-42 (Required)
Rule 6-4-3 (Required)
Rule 6-44 (Required)
Rule 6-4-5 (Required)
Rule6—-4-6 (Required)
Rule 6-4-7 (Required)
Rule 6-4-8 (Required)

Iteration statements

Rule 6-5-1 (Required)
Rule 6-5-2 (Required)
Rule 6-5-3 (Required)
Rule 6-54 (Required)
Rule 6-5-5 (Required)
Rule 6-5-6 (Required)

Jump statements

Rule 6-6-1 (Required)

Floating-point expressions shall not be directly or indirectly tested
for equality or inequality.

Before preprocessing, a null statement shall only occur on a line
by itself; it may be followed by a comment, provided that the first
character following the null statement is a white-space character.

The statement forming the body of a switch, while, do … while or for
statement shall be a compound statement.

An if ( condition ) construct shall be followed by a compound
statement. The e/se keyword shall be followed by either a compound
statement, or another if statement.

AI if … else if constructs shall be terminated with an e/se clause.
À switch statement shall be a well-formed switch statement.

À switch-label shall only be used when the most closely-enclosing
compound statement is the body of a switch statement.

An unconditional fhrow or break statement shall terminate every
non-empty switch-clause.

The final clause of a switch statement shall be the default-clause.
The condition of a switch statement shall not have bool type.

Every switch statement shall have at least one case-clause.

À for loop shall contain a single loop-counter which shall not have
floating type.

If /oop-counter is not modified by -- or ++, then, within condition,
the /oop-counter shall only be used as an operand to <=, <, > or >=.

The /oop-counter shall not be modified within condition or
statement.

The /oop-counter shall be modified by one of: --, ++, -=n, or +=n;
where n remains constant for the duration of the loop.

À loop-control-variable other than the /oop-counter shall not be
modified within condition or expression.

À loop-control-variable other than the /oop-counter which is
modified in statement shall have type bool.

Any label referenced by à gofo statement shall be declared in the
same block, or in a block enclosing the gofo statement.

 

182 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 6-6-2 (Required)
Rule 6-6-3 (Required)
Rule 6-64 (Required)

Rule 6-6-5 (Required)

Specifiers
Rule 7-1-1 (Required)
Rule 7-1-2 (Required)

The goto statement shall jump to a label declared later in the same
function body.

The continue statement shall only be used within a we/l-formed for
loop.

For any iteration statement there shall be no more than one break or
goto statement used for loop termination.

À function shall have a single point of exit at the end of the
function.

A variable which is not modified shall be const qualified.

A pointer or reference parameter in a function shall be declared as
pointer to const or reference to const if the corresponding object is
not modified.

Enumeration declarations

Rule 7-2-1 (Required)

Namespaces
Rule 7-3-1 (Required)

Rule 7-3-2 (Required)

Rule 7-3-3 (Required)
Rule 7-34 (Required)
Rule 7-3-5 (Required)

Rule 7-3-6 (Required)

The asm declaration
Rule 7—4-1 (Document)

Rule 7-42 (Required)

Rule 7-4-3 (Required)

Linkage specifications
Rule 7-5-1 (Required)

An expression with enum underlying type shall only have values
corresponding to the enumerators of the enumeration.

The global namespace shall only contain main, namespace
declarations and extern "C" declarations.

The identifier main shall not be used for a function other than the
global function main.

There shall be no unnamed namespaces in header files.
using-directives shall not be used.

Multiple declarations for an identifier in the same namespace shall
not straddle a using-declaration for that identifier.

using-directives and using-declarations (excluding class scope
or function scope using-declarations) shall not be used in header

files.

All usage of assembler shall be documented.

Assembler instructions shall only be introduced using the asm
declaration.

Assembly language shall be encapsulated and isolated.

A function shall not return à reference or à pointer to an automatic
variable (including parameters), defined within the function.

 

183 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 7-5-2 (Required)
Rule 7-5-3 (Required)
Rule 7-54 (Advisory)

Declarators — General

Rule 8-0-1 (Required)

Meaning of declarators

Rule 8-3-1 (Required)

Function definitions

Rule 8-14-1 (Required)
Rule 8-12 (Required)
Rule 8-4-3 (Required)
Rule 8-4-4 (Required)

The address of an object with automatic storage shall not be assigned
to another object that may persist after the first object has ceased to
exist.

A function shall not return a reference or a pointer to a parameter
that is passed by reference or const reference.

Functions should not call themselves, either directly or indirectly.

An init-declarator-list or a member-declarator-list shall consist of a
single init-declarator or member-declarator respectively.

Parameters in an overriding virtual function shall either use the
same default arguments as the function they override, or else shall
not specify any default arguments.

Functions shall not be defined using the ellipsis notation.

The identifiers used for the parameters in a re-declaration of a
function shall be identical to those in the declaration.

All exit paths from a function with non-void return type shall have
an explicit refurn Statement with an expression.

À function identifier shall either be used to call the function or it
shall be preceded by &.

Declarators — Initializers

Rule 8-5-1 (Required)
Rule 8-5-2 (Required)
Rule 8-5-3 (Required)

Member functions

Rule9-3-1 (Required)
Rule9-3-2 (Required)
Rule9-3-3 (Required)
Unions

Rule9-5-1 (Required)

All variables shall have a defined value before they are used.

Braces shall be used to indicate and match the structure in the non-
Zero initialization of arrays and structures.

In an enumerator list, the = construct shall not be used to explicitly
initialize members other than the first, unless all items are explicitly
initialized.

const member functions shall not return non-const pointers or
references to class-data.

Member functions shall not return non-const handles to class-dafa.

If a member function can be made static then it shall be made static,
otherwise if it can be made const then it shall be made const.

Unions shall not be used.

 

Licensed to: Insigma Raïl Transport. Engineering Co.

184
8 He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Bit-fields

Rule 9-6-1 (Document)
Rule9—6-2 (Required)
Rule 9—6-3 (Required)
Rule 9-64 (Required)

Multiple base classes
Rule 10-1-1 (Advisory)

Rule 10-1-2 (Required)

Rule 10-1-3 (Required)

Member name lookup
Rule 10-2-1 (Advisory)

Virtual functions
Rule 10-3-1 (Required)

Rule 10-3-2 (Required)

Rule 10-3-3 (Required)

When the absolute positioning of bits representing a bit-field
is required, then the behaviour and packing of bit-fields shall be
documented.

Bit-fields shall be either oo! type or an explicitly unsigned or signed
integral type.

Bit-fields shall not have enum type.

Named bit-fields with signed integer type shall have a length of
more than one bit.

Classes should not be derived from virtual bases.

À base class shall only be declared virtual if it is used in a diamond
hierarchy.

An accessible base class shall not be both virtual and non-virtual in
the same hierarchy.

AII accessible entity names within a multiple inheritance hierarchy
should be unique.

There shall be no more than one definition of each virtual function
on each path through the inheritance hierarchy.

Each overriding virtual function shall be declared with the virtual
keyword.

A virtual function shall only be overridden by a pure virtual function
if it is itself declared as pure virtual.

Member access control — General

Rule 11-0-1 (Required)

Constructors
Rule 12-1-1 (Required)

Rule 12-1-2 (Advisory)

Rule 12-1-3 (Required)

Member data in non-POD class types shall be private.

An object’s dynamic type shall not be used from the body of its
constructor or destructor.

AII constructors of a class should explicitly call a constructor for all
of its immediate base classes and all virtual base classes.

AII constructors that are callable with a single argument of
fundamental type shall be declared explicit.

 

Licensed to: Insigma Raïl Transport. Engineering Co.

1
85 He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Copying class objects
Rule 12-8-1 (Required)

Rule 12-8-2 (Required)

Template declarations
Rule 14-5-1 (Required)

Rule 14-5-2 (Required)

Rule 14-5-3 (Required)

Name resolution
Rule 14-6-1 (Required)

Rule 14-6-2 (Required)

A copy constructor shall only initialize its base classes and the non-
static members of the class of which it is a member.

The copy assignment operator shall be declared protected or private
in an abstract class.

Anon-member generic function shall only be declared in a namespace
that is not an associated namespace.

A copy constructor shall be declared when there is a template
constructor with a single parameter that is a generic parameter.

À copy assignment operator shall be declared when there is a
template assignment operator with a parameter that is a generic
parameter.

In à class template with a dependent base, any name that may be
found in that dependent base shall be referred to using a qualified-id
Or this->

The function chosen by overload resolution shall resolve to a
function declared previously in the translation unit.

Template instantiation and specialization

Rule 14-7-1 (Required)

Rule 14-7-2 (Required)

Rule 14-7-3 (Required)

AII class templates, function templates, class template member
functions and class template static members shall be instantiated at
least once.

For any given template specialization, an explicit instantiation of
the template with the femplate-arguments used in the specialization
shall not render the program ill-formed.

All partial and explicit specializations for a template shall be declared
in the same file as the declaration of their primary template.

Function template specialization

Rule 14-8-1 (Required)
Rule 14-8-2 (Advisory)

Overloaded function templates shall not be explicitly specialized.

The viable function set for a function call should either contain no
function specializations, or only contain function specializations.

Exception handling — General

Rule 15—-0-1 (Document)
Rule 15-0-2 (Advisory)
Rule 15-0-3 (Required)

Exceptions shall only be used for error handling.
An exception object should not have pointer type.

Control shall not be transferred into a #y or catch block using a gofo
or a switch statement.

 

186 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Throwing an exception
Rule 15-1-1 (Required)

Rule 15-1-2 (Required)
Rule 15-1-3 (Required)

Handling an exception
Rule 15-3-1 (Required)

Rule 15-3-2 (Advisory)

Rule 15-3-3 (Required)

Rule 15-3-4 (Required)

Rule 15-3-5 (Required)
Rule 15-3-6 (Required)

Rule 15-3-7 (Required)

Exception specifications

Rule 15—4-1 (Required)

The assignment-expression of a fhrow statement shall not itself
cause an exception to be thrown.

NULL shall not be thrown explicitly.

An empty fhrow (throw;) shall only be used in the compound-
statement of a catch handler.

Exceptions shall be raised only after start-up and before termination
of the program.

There should be at least one exception handler to catch all otherwise
unhandled exceptions

Handlersofa/function-try-blockimplementationofaclass constructor
or destructor shall not reference non-static members from this class
or its bases.

Each exception explicitly thrown in the code shall have a handler of
a compatible type in all call paths that could lead to that point.

A class type exception shall always be caught by reference.

Where multiple handlers are provided in a single #ry-catch statement
or function-try-block for a derived class and some or all of its bases,
the handlers shall be ordered most-derived to base class.

Where multiple handlers are provided in a single #ry-catch statement
or function-try-block, any ellipsis (catch-all) handler shall occur
last.

If a function is declared with an exception-specification, then all
declarations of the same function (in other translation units) shall be
declared with the same set of fype-ids.

Exception handling — Special functions

Rule 15-5-1 (Required)
Rule 15-5-2 (Required)

Rule 15-5-3 (Required)

A class destructor shall not exit with an exception.

Where a function’s declaration includes an exception-specification,
the function shall only be capable of throwing exceptions of the
indicated type(s).

The ferminate() function shall not be called implicitly.

Preprocessing directives — General

Rule 16-0-1 (Required)

#include directives in a file shall only be preceded by other
preprocessor directives or comments.

 

187 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Rule 16-0-2 (Required)

Rule 16—0-3
Rule 16—-0-4
Rule 16—0-5

(Required)

(Required)
(Required)

Rule 16-0-6 (Required)

Rule 16-0-7 (Required)

Rule 16-0-8 (Required)

Conditional inclusion
Rule 16-1-1 (Required)

Rule 16-1-2 (Required)

Source file inclusion
Rule 16-2-1 (Required)

Rule 16-2-2 (Required)

Rule 16-2-3 (Required)
Rule 16-24 (Required)
Rule 16-2-5 (Advisory)
Rule 16-2-6 (Required)

Macro replacement
Rule 16-3-1 (Required)

Rule 16-3-2 (Advisory)

Pragma directive
Rule 16-6-1 (Document)

Macros shall only be #define’d or #undefd in the global
namespace.

#undef shall not be used.
Function-like macros shall not be defined.

Arguments to a function-like macro shall not contain tokens that
look like preprocessing directives.

In the definition of a function-like macro, each instance of a
parameter shall be enclosed in parentheses, unless it is used as the
operand of # or ##.

Undefined macro identifiers shall not be used in #if or #elif
preprocessor directives, except as operands to the defined operator.

If the + token appears as the first token on a line, then it shall be
immediately followed by a preprocessing token.

The defined preprocessor operator shall only be used in one of the
two standard forms.

All #else, #elif and #endif preprocessor directives shall reside in the
same file as the “if or #ifdef directive to which they are related.

The pre-processor shall only be used for file inclusion and include
guards.

C++ macros shall only be used for: include guards, type qualifiers,
or storage class specifiers.

Include guards shall be provided.
The ',",/+ or // characters shall not occur in a header file name.
The \ character should not occur in a header file name.

The “include directive shall be followed by either a <filename” or
“filename" sequence.

There shall be at most one occurrence of the # or ## operators in a
single macro definition.

The # and ## operators should not be used.

All uses of the #pragma directive shall be documented.

 

Licensed to: Insigma Raïl Transport. Engineering Co.

1
88 He Yulin. 12 Oct 2010. Copy 1 of 1
Append IX À (continued)

 

Library introduction — General

Rule 17-0-1 (Required)

Rule 17-0-2 (Required)

Rule 17-0-3 (Required)
Rule 17-04 (Document)
Rule 17-0-5 (Required)

Reserved identifiers, macros and functions in the standard library
shall not be defined, redefined or undefined.

The names of standard library macros and objects shall not be
reused.

The names of standard library functions shall not be overridden.
AI library code shall conform to MISRA C++.

The sefjmp macro and the longjmp function shall not be used.

Language support library — General

Rule 18-0-1 (Required)
Rule 18-0-2 (Required)

Rule 18-0-3 (Required)

Rule 18-04 (Required)
Rule 18-05 (Required)

The C library shall not be used.

The library functions afof, atoi and afol from library <cstdlib= shall
not be used.

The library functions abort, exit, getenv and system from library
<estdlib> shall not be used.

The time handling functions of library <ctime” shall not be used.

The unbounded functions of library <cstring” shall not be used.

Language support library — Implementation properties

Rule 18-2-1 (Required)

The macro offsetof shall not be used.

Language support library — Dynamic memory management

Rule 18-4-1 (Required)

Dynamic heap memory allocation shall not be used.

Language support library — Other runtime support

Rule 18-7-1 (Required)

The signal handling facilities of <csignal= shall not be used.

Diagnostics library — Error numbers

Rule 19-3-1 (Required)

The error indicator errno shall not be used.

Input/output library — General

Rule 27-0-1 (Required)

The stream input/output library <csfdio= shall not be used.

 

189 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Appendix B

 

Appendix B: C++ vulnerabilities

Unlike the € Language Reference Manual [16], the C++ LRM (ISO/IEC 14882:2003 [1]) does
not include a collated list of the features of the language that are “unspecified”, “undefined”, etc.
This annex provides such a list.

The extraction of this information from the LRM was funded by the Analysis, Experimentation
and Simulation Domain of the UK Ministry of Defence Scientific Research Programme, and is
quoted here with permission.

Each entry in the list contains the following information:

MISRA Id: an identifier unique to this document, to allow easy reference to particular
issues.

ISO Reference: a reference into the ZRAZ, in the form X.Y(Z) being paragraph Z of
subsection Y of section X, etc.

Description: a brief summary of the unspecified etc. behaviour described in the referenced
paragraph.

Category: the sort of behaviour described in the referenced paragraph (see below).
MISRA Guidance: which Rule(s) in this document address the described issue.

Source Id: unique identifier used in the document where this table was originally published
[17], to allow cross-referencing.

The categories are as follows:

Unspecified: A situation where the implementation will have to make some “sensible”
choice, but that choice is not predictable by the programmer, e.g. the order in which sub-
expressions are evaluated in an expression.

Undefined: A situation where the ZRM can give no indication of what behaviour to expect
from a program. This behaviour may result in catastrophic failure (a “crash”) or continued
execution with some arbitrary data.

Implementation: A situation where the implementation will have to make some “sensible”
choice and where that choice has to be documented and be available to the programmer,
e.g. the size of integers.

Indeterminate: A sub-category of undefined behaviour, where the LRM says “if condition,
the behaviour is ….” but does not say what happens if the condition is not true.

Behaviour that requires no diagnostics: À situation where the ZRM permits behaviour that
may be unexpected or at odds with previously defined principles, but explicitly the LRM
does not require the programmer to be warned.

 

190 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append ix B (continued)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

MISRA ISO Description Category MISRA Source

Id Reference Guidance Id

1 2.1(1) The mapping of physical source file Implementation 3.01
characters.

2 2.1(2) À character sequence that matches a Undefined 2.01
universal-character-name is produced due
to the splicing of physical source lines in
the translation process.

3 2.1(2) À non-empty source file does not end in Undefined 2.02
a new line character, or ends in a new
line character immediately preceded by a
backslash character.

4 2.1(2) Use of an identifier reserved for C++ Behaviour that 5.02
implementations and standard libraries. requires no

diagnostics

5 2.1(3) Whether each non-empty sequence of Implementation 3.02
white-space characters other than new
line is retained or replaced by one space
character.

6 2.1(4) À character sequence that matches a Undefined 2.03
universal-character-name is produced due
to token concatenation.

7 2.1(8) Whether the source of the translational Implementation 3.03
units containing the definitions of the
templates for the requisite instantiations is
required to be available.

8 2.2(3) The values of the members of the Implementation 3.04
execution character sets.

9 2.4(2) An unmatched " or a " character is Undefined 2.04
encountered on a logical source line during
tokenization.

10 2.7(1) A /} comment contains a form feed or Behaviour that 5.01
vertical-tab character and does not only requires no
have white space characters between it and diagnostics
the new-line that terminates the comment.

11 2.8(1) The mapping of the sequences in both Implementation 3.05
forms of header-names. See 16.2(2)

12 2.8(2) The characters ', \, ", /*, or // are Undefined Rule 16-24 2.05
encountered between the < and > Rule 16-2-5
delimiters or the characters ', \, /*, or // are
encountered between the " delimiters in the
two forms of a header name preprocessing
token.

13 2.13.1(2) | An integer literal cannot be represented by Undefined 2.06
any of the allowed types.

14 2.13.2(1) | The value of a multi-character literal. Implementation 3.06

15 2.13.2(2) | The value of a wide-character literal Implementation 3.07
containing multiple c-chars.

16 2.13.2(3) | The character following a backslash does Undefined Rule 2-13-1 2.07

 

 

 

not give a valid escape sequence.

 

 

 

 

 

191

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

MISRA ISO Description Category MISRA Source
Id Reference Guidance Id
17 2.13.2(4) | The value of a character literal that falls Implementation 3.08
outside of the implementation defined
range for char or w_ char.

18 2.13.2(5) | The encoding of a universal-character- Implementation 3.09
name where the execution character set has
no encoding for the character named.

19 2.13.3(1) | The actual value used for a floating Implementation 3.10
literal whose value is not in the range of
representable values for its type.

20 2.13.4(2) | An attempt is made to modify a string Undefined 2.08
literal.

21 2.13.4(2) | Whether all string literals are distinct Implementation 3.11
(stored in non-overlapping objects).

22 2.13.4(3) | A narrow string literal token is adjacent to Undefined Rule 2-13-5 2.09
a wide string literal token.

23 3.1(15) | A program attempting to access the stored Undefined 2.22
value of an object through an lvalue of
other than one of the types specified.

24 3.2(3) À program that does not contain exactly Behaviour that Rule 3-2-1 5.03
one definition for every non-inline function requires no Rule 3-2-4
or object that is used in that program. diagnostics

25 3.2(5) The behaviour of a program if two Undefined Rule 3-2-1 2.10
definitions in separate translation units do Rule 3-2-4
not satisfy the One Definition Rule.

26 3.3.1(1) | The value used when a variable is used to Indeterminate 4.01
initialize itself, e.g. inf x = x;

27 3.3.6(1) | A name N used in a class S does not refer Behaviour that 5.04

Item 2 to the same declaration in its context and requires no

when re-evaluated in the completed scope diagnostics
ofsS.

28 3.3.6(1) | If reordering member declarations in a Behaviour that 5.05

Item 3 class yields an alternative valid program requires no

under certain conditions. diagnostics

29 3.5(10) | If a given object or function can be referred | Behaviour that 5.06
to by values of different type (after all requires no
types adjustments) diagnostics

30 3.6.1(1) | Whether a program in a freestanding Implementation 3.12
environment is required to define a main
function.

31 3.6.1(1) | Start-up and termination in a freestanding | Implementation 3.13
environment.

32 3.6.1(2) | The type of the main function, though its Implementation | Rule 7-3-2 3.14
return type must be int.

33 3.6.1(3) | The linkage of main. Implementation | Rule 7-3-2 3.15

34 3.6.1(4) | The library function exif is called to end a Undefined 2.11

 

 

 

program during the destruction of an object
with static storage duration.

 

 

 

 

 

192

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

MISRA
Id

ISO
Reference

Description

Category

MISRA
Guidance

Source
Id

 

35

3.6.2(2)

Whether an object is fully, or merely
zero-initialized when an object refers to
another object of namespace scope with
static storage duration potentially requiring
dynamic initialization and defined later in
the same translational unit.

Unspecified

1.01

 

36

3.6.2(3)

Whether the dynamic initialization of an
object of namespace scope is done before
the first statement of main.

Implementation

3.16

 

37

3.630)

A function contains a local object of static
storage duration that has been destroyed
and the function is called during the
destruction of an object with static storage
duration and the flow of control passes
through the definition of the previously
destroyed object.

Undefined

2.12

 

38

3.713.102)

The order, contiguity and initial value
of storage allocated by the allocation
functions.

Unspecified

1.02

 

39

3.713.102)

The results of dereferencing a pointer
returned as a request for zero size space in
a call to an allocation function.

Undefined

2.13

 

40

3.7.3.2(4)

Attempt to use a pointer to a deleted
object.

Undefined

2.14

 

41

3.84)

The side effects of a non-trivial destructor
of an object of class type whose lifetime
has ended, but whose destructor has not
been called explicitly.

Undefined

2.15

 

42

3.8(5)

An object will be or was of a class type
with a non-trivial destructor and the
pointer is used as the operand of a delete-
expression.

Undefined

2.16

 

43

3.8(5)

Series of uses of a pointer to a non-

POD class type between object storage
allocation and the start of object lifetime,
and the end of object lifetime and storage
de-allocation.

Undefined

2.17

 

44

3.8(6)

An lvalue-to-rvalue conversion is applied
to an lvalue that refers to an object whose
lifetime has not yet started but whose
storage has been allocated, or whose
lifetime has ended but whose storage has
not been reused or released.

Undefined

2.18

 

45

 

 

3.8(6)

 

Series of uses of an lvalue that refers to a
non-POD class type between object storage
allocation and the start of object lifetime,
and the end of object lifetime and storage
deallocation.

 

Undefined

 

 

2.19

 

 

193 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1

 
Append ix B (continued)

 

 

MISRA
Id

ISO
Reference

Description

Category

MISRA
Guidance

Source
Id

 

46

3.8(8)

À program ends the lifetime of an object
of type T with static or automatic storage
duration, T has a non-trivial destructor
and an object of a different type occupies
the storage location when the implicit
destructor call takes place.

Undefined

2.20

 

47

3.8(9)

A new object is created at the storage
location that a const object with static or
automatic storage duration occupies or, at
the storage location that such a const object
used to occupy before its lifetime ended.

Undefined

2.21

 

48

3.9(4)

For POD types, the set of values of which
the value representation (a set of bits in
the object representation that determines a
value) is one discrete element.

Implementation

Rule 9-5-1

3.17

 

49

3.9(5)

The packing needed between sub-objects
to meet alignment requirements

Implementation

Rule 9-5-1

3.18

 

50

3.9.1(1)

Whether char is equivalent to unsigned
char or signed char.

Implementation

Rule 3-9-2
Rule 5-0-11
Rule 5-0-12

3.19

 

51

3.9.1(2)

Size of int.

Implementation

3.20

 

52

3.9.1(5)

Type of wchar t.

Implementation

Rule 3-9-2

3.21

 

53

3.9.1(8)

The value representation of floating-point
types.

Implementation

Rule 3-9-3

3.22

 

54

3.9.2(3)

The value representation of pointer types.

Implementation

3.23

 

55

4.1(1)

An lvalue, which does not refer to an
object of type T or is uninitialized, is used
where an rvalue of type T is expected.

Undefined

2.23

 

56

4.76)

The value of a signed integer type due to
the conversion from either an integer or an
enumeration type when the value cannot be
represented in the destination type.

Implementation

3.24

 

57

4.8(1)

A floating-point conversion produces a
result that cannot be represented in the
space provided.

Undefined

2.24

 

58

4.8(1)

The value resulting from converting a
value of a floating point type to another
floating point type that cannot exactly
represent the original value.

Implementation

3.25

 

59

4.9(1)

A floating-intesral conversion produces
a result that cannot be represented in the
space provided.

Undefined

Rule 5-0-5
Rule 5-0-6

2.25

 

60

 

 

4.9(2)

 

The choice of either the next higher or
lower representable value when an rvalue
of an integer or enumeration type is
converted to an rvalue of a floating-point
type but exact conversion is not possible.

 

Implementation

 

 

3.26

 

 

194

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

MISRA
Id

ISO
Reference

Description

Category

MISRA
Guidance

Source
Id

 

61

5(4)

The order of evaluation of operands of
individual operators and sub-expressions
of individual expressions, and the order in
which side effects take place.

Unspecified

Rule 5-0-1

1.03

 

62

5(4)

An object is modified more than once or
is modified and accessed other than to
determine the new value, between two
sequence points.

Undefined

Rule 5-0-1

2.26

 

63

5(5)

An arithmetic operation is invalid (such as
division or modulus by zero) or produces
a result that cannot be represented in

the space provided (such as overflow or
underflow).

Undefined

2.27

 

64

5.1(2)

Pointers are compared using an equality
operator and either is a pointer to a virtual
member function.

Unspecified

 

65

5.2.2(1)

A function is called through an expression
whose function type has a language linkage
that is different from the language linkage
of the function type of the called function’s
definition.

Undefined

2.28

 

66

5.2.2(7)

An argument with no parameter, after
standard conversions, has a non-POD class

type.

Undefined

Rule 8-4-1

2.29

 

67

5.2.2(8)

The order of evaluation of arguments in a
function call and the order of evaluation
of the postfix expression and the argument
expression list.

Unspecified

1.04

 

68

5.2.8(1)

Whether or not the destructor is called
for the fype_info object at the end of the
program.

Unspecified

1.05

 

69

5.2.8(1)

The class (name) derived from sfd':#ype
info of an lvalue of dynamic type
constname, that is the result of a fypeid
expression.

Implementation

3.27

 

70

5.2.9(5)

A static _cast is used to cast an lvalue of
class type to a non-derived class.

Undefined

Rule 5-2-2

2.30

 

71

5.2.9(7)

An integer type is explicitly converted to
an enumeration type but the integral value
is not within the range of the enumeration
values

Unspecified

1.06

 

72

5.2.9(8)

A static cast is used to cast a pointer of
class type to a pointer from a non-derived
class.

Undefined

Rule 5-2-2

2.31

 

73

5.2.9(9)

A static cast is used to cast a pointer to a
class member to a pointer to a member of a
non-derived class

Undefined

2.32

 

74

 

 

5.2.10(3)

 

The mapping performed by reinterpret_
cast.

 

Implementation

 

 

3.28

 

 

195

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

MISRA
Id

ISO
Reference

Description

Category

MISRA
Guidance

Source
Id

 

75

5.2.10(4)

The mapping function used to explicitly
converting à pointer to any integral type
large enough to hold it.

Implementation

Rule 5-2-9

3.29

 

76

5.2.10(5)

Mappings between pointers and integers
other than when a value of integral or
enumeration type is explicitly converted
into a pointer or when a pointer is
converted to an integer of sufficient size
and back to the same pointer type.

Implementation

Rule 5-2-9

3.30

 

77

5.2.10(6)

A pointer to a function is explicitly
converted to a function of a different type
using reinterpret cast.

Unspecified

Rule 5-2-6

1.07

 

78

5.2.10(6)

À pointer to a function is converted by
reinterpret_cast to point to a function of a
different type and used to call a function
of a type not compatible with the original

type.

Undefined

Rule 5-2-6

2.33

 

79

5.2.10(7)

À pointer to an object is explicitly
converted to a pointer to an object of a
different type using reinterpret cast.

Unspecified

Rule 5-2-7
Rule 5-2-8

1.08

 

80

5.2.10(9)

À pointer to member of some type is
explicitly converted to a pointer to another
member of another type using reinterpret_
cast.

Unspecified

1.09

 

81

5.2.11(12)

The use of values produced from
conversions between pointers and
functions, pointers and member functions
and in particular a pointer to a const
member function to a pointer to a non-
const member function.

Undefined

2.35

 

82

5.2.11(7)

Depending on the type of object, a write
operation through the pointer, lvalue or
pointer to data member resulting from a
const _char that casts away a const-qualifier
may produce undefined behaviour.

Undefined

2.34

 

83

5.3.1(4)

The address of an object with incomplete
type, whose complete type declares
operator&() as a member function.

Undefined

Rule 5-3-3

2.36

 

84

5.3.3(1)

The result of sizeof applied to any
fundamental type (other than char, signed
char and unsigned char), in particular
sizeof(bool) and sizeof{wchar 1).

Implementation

3.31

 

85

5.34(15)

The value of a POD object created by a
new-expression when a new-initializer is
omitted.

Indeterminate

4.02

 

86

53401)

The order of evaluation of the allocation
function and its arguments.

Unspecified

 

87

 

 

53401)

 

The evaluation of arguments if the
allocation function returns null or exits
using an exception.

 

Unspecified

 

 

 

 

196

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

MISRA
Id

ISO
Reference

Description

Category

MISRA
Guidance

Source
Id

 

88

5.3.4(6)

The first array dimension applied to a new
operator is negative.

Undefined

2.37

 

89

5.3.50)

The behaviour of the delete operator on a
pointer to a non-array object or a pointer to
a sub-object representing the base class of
such an object that was not obtained from a
new operator.

Undefined

2.38

 

90

5.3.50)

The value of the operand of delete is
not the pointer value that resulted from
a previous array new-expression when
deleting an array.

Undefined

2.39

 

91

5.3.5)

When deleting an object and the static
type of the operand is different from its
dynamic type and either the static type is
not a base class of the operand”’s dynamic
type, or the static type does not have a
virtual destructor.

Undefined

2.40

 

92

5.3.5)

The dynamic type of the object to be
deleted differs from its static type when
deleting an array.

Undefined

2.41

 

93

5.3.5(4)

The value of a pointer that refers to
deallocated storage

Indeterminate

4.03

 

94

53.565)

The object being deleted has incomplete
class type at the point of deletion and the
complete class has a non-trivial destructor
or deallocation function.

Undefined

2.42

 

95

5.4(6)

Whether the sfafic cast or reinterpret cast
interpretation is used if either the operand
or destination type of the cast is a pointer
to incomplete class type.

Unspecified

 

96

5.54)

In a pointer-to-member operation the
dynamic type of an object does not contain
the member to which the pointer refers.

Undefined

2.43

 

97

5.5(6)

The second operand of an ->* expression is
the null pointer to a member value.

Undefined

2.44

 

98

5.6(4)

The second operand of the / or % operators
is Zero.

Undefined

2.45

 

99

5.6(4)

The sign of the remainder using the binary
% operator unless both operands are non-
negative.

Implementation

Rule 1-0-3

3.32

 

100

5.75)

A pointer that does not behave like a
pointer to an element of an array object is
added to or subtracted from.

Undefined

Rule 5-0-16

2.46

 

101

5.75)

The resultant pointer from an addition or
subtraction to a pointer to an element of an
array which does not point within the array
(or one beyond).

Undefined

Rule 5-0-16

2.47

 

102

 

 

5.7(6)

 

Two pointers to elements of the same array
object are subtracted, the result does not
fit in the space provided and there is an
arithmetic overflow.

 

Undefined

 

 

2.48

 

 

197

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

MISRA ISO Description Category MISRA Source
Id Reference Guidance Id
103 5.7(6) Pointers that do not behave like pointers to Undefined Rule 5-0-17 2.49
elements of the same array are subtracted.

104 5.7(6) The signed integral type given as a result Implementation 3.33
of the subtraction of two pointers to
elements of the same array object.

105 5.8(1) An expression is shifted by a negative Undefined Rule 5-8-1 2.50
number or by an amount greater than or
equal to the width in bits of the expression
being shifted.

106 5.8(3) The value given as a result of >> shift Implementation | Rule 5-0-21 3.34
operator where the shift-expression has a
signed type and is negative

107 5.9(2) Pointers are compared using a relational Unspecified 1.13
operator that do not point to members of
the same object, elements of the same array
or to the same functions, etc.

108 5.17(8) | An object is assigned to an overlapping Undefined Rule 0-2-1 2.51
object.

109 6.6.3(2) | The effect of flowing off the end of a Undefined Rule 8-4-3 2.52
function that is expected to return a value

110 6.7(4) Control re-enters a declaration recursively Undefined 2.53
while an object is being initialized.

111 6.8(3) During parsing, a name in a template Behaviour that 5.07
parameter is bound differently than it requires no
would be bound during a trial parse. diagnostics

112 7.1.5.1(4) | An attempt is made to modify a const Undefined Rule 5-2-5 2.54
object, other than any class member
declared mutable.

113 7.1.5.1(7) | An attempt is made to refer an object Undefined Rule 5-2-5 2.55
defined with volatile-qualified type through
the use of an value with non-volatile-
qualified type.

114 7.1.5.2(1) | Whether bit-fields and objects of char Implementation | Rule 5-0-11 3.35
type are represented as signed or unsigned Rule 5-0-12
quantities. Rule 9-6-2

115 7.2(4) The type of an uninitialized first Unspecified 1.15
enumerator.

116 7.2(4) The value of an uninitialized enumerator Unspecified 1.16
is not representable in the type of the
preceding enumerator.

117 7.2(5) The integral type used as the underlyving Implementation 3.36
type for an enumeration.

118 7.2(9) A value is not in the range of the Unspecified Rule 7-2-1 1.17
enumeration type to which it is explicitly
converted.

119 7.3.2(4) | À namespace-name defined at global scope | Behaviour that 5.08
is also declared as the name of another requires no
entity in any global scope of the program. diagnostics

120 7A(1) The meaning of an asm declaration. Implementation | Rule 7-4-1 3.37

 

 

 

 

 

 

 

 

198

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

MISRA ISO Description Category MISRA Source
Id Reference Guidance Id
121 7.5(1) Implementation specific properties Implementation | Rule 1-0-2 3.38
associated with an entity with language
linkage

122 7.502) The meaning of the string-literal in a Implementation | Rule 1-0-2 3.39
linkage-specification

123 7.502) The spelling of the language’s name when | Implementation | Rule 1-0-2 3.40
the sfring-literal in a linkage-specification
names a programming language

124 7.502) The semantics of a language linkage other | Implementation | Rule 1-0-2 3.41
than C++ or C.

125 7.5(9) Linkage from C++ to objects defined in Implementation | Rule 1-0-2 3.42
other languages and to objects defined in
C++ from other languages.

126 8.3.2(3) | Whether a reference requires storage. Unspecified 1.18

127 8.3.2(4) | Dereferencing a null pointer. Undefined 2.56

128 8.3.6(9) | The order of evaluation of function Unspecified 1.19
arguments.

129 8.5(9) The value of an object if no initializer is Indeterminate Rule 8-5-1 4.04
specified.

130 8.5.3(8) | How the reference is bound when a Implementation 3.43
reference to type “cvl TL” is initialized by
an expression ‘“cv2 T2”.

131 92(12) | The order of allocation of non-static data Unspecified 1.20
members separated by an access-specifier

132 9.3.1(1) | À member function of a class X is called Undefined 2.57
for an object that is not of type X or a type
derived from X.

133 9.6(1) The allocation of bit-fields within a class. Implementation | Rule 9-6-1 3.44

134 9.6(3) Whether a plain (neither explicitly signed Implementation | Rule 9-6-2 3.46
nor unsigned) char, short, int or long bit-
field is signed or unsigned.

135 9.6(4) Alignment of bit-fields Implementation 3.45

136 10(3) The order in which the base class Unspecified 1.21
subobjects are allocated in the most
derived object

137 10.3(8) | A virtual function declared in a class is Behaviour that 5.09
both defined and declared pure in that requires no
class. diagnostics

138 10.4(6) | A virtual call is made from a constructor Undefined Rule 12-1-1 2.58
(or destructor) of an abstract class to a pure
virtual function directly or indirectly for
the object being created (or destroyed).

139 11.1(2) | The order of allocation of data members Unspecified 1.22

 

 

 

with separate access-specifier labels

 

 

 

 

 

199

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

 

MISRA ISO Description Category MISRA Source
Id Reference Guidance Id
140 12.1(15) | The value of an object obtained, if during Unspecified 1.23

the construction of a const object, the
object is accessed through an Ivalue
not obtained from the constructor’s fhis

 

 

pointer.
141 12.2(5) | The order of creation of temporary objects. Unspecified 1.24
142 12.4(12) | A destructor is invoked for an object that Undefined 2.59

is not of the destructor’s class or not of a
class derived from the destructor’s class.

 

143 12.4(14) | A destructor is invoked for an object whose Undefined 2.60
lifetime has ended

 

 

144 12.6.2(4) | The value of a member of a class if it is not | Indeterminate 4.05
otherwise initialized by the constructor.
145 12.6.2(8) | A member function (including virtual Undefined 2.61

member functions) is called for an object
under construction, or an object under
construction is used as the operand of

the fypeid operator or of a dynamic cast
performed in a ctor-initializer (or a
function called directly or indirectly from
a ctor-initializer) before all of the mem-
initializers for base classes have been
completed.

 

146 12.741) | Referring to any nonstatic member or base Undefined 2.62
class of an object of non-POD class type,
before the constructor begins execution
and after the destructor finishes execution.

 

147 12.7(2) | Converting a pointer to an object of class Undefined 2.63
X to a direct or indirect base class of X,
where the construction of the object has
not started or the destruction of the object
has completed.

 

148 12.7(2) | Forming a pointer to (or access the value Undefined 2.64
of) a direct nonstatic member of an object,
where the construction of the object has
not started or the destruction of the object
has completed.

 

149 12.7(3) | The result of making a virtual call using Undefined 2.65
an explicit class member access and the
object expression refers to the object under
construction or destruction but its type is
neither the constructor or destructor’s own
class or one of its bases.

 

150 12.7(4) | The operand of fypeid refers to an object Undefined 2.66
under construction or destruction and the
static type of the operand is neither the
constructor or destructor”’s class nor one of
its bases.

 

 

 

 

 

 

 

 

 

200 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append ix B (continued)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

MISRA ISO Description Category MISRA Source
Id Reference Guidance Id
151 12.7(5) | If the operand of the dynamic cast refers to Undefined 2.67
the object under construction or destruction
and the static type of the operand is not a
pointer to or object of the constructor is not
a pointer to or object of the constructor or
destructor’s own class or one of its bases.

152 12.8(13) | Whether sub-objects representing virtual Unspecified 1.25
base classes are assigned more than once
by the implicitly-defined copy assignment
operator.

153 12.8(4) | Any use of a user defined copy constructor | Behaviour that 5.10
that matches the implicitly declared copy requires no
constructor diagnostics

154 14(4) The linkage of a template, a template Implementation 3.47
explicit specialization or a class template
partial specialization, if it is something
other than C or C++.

155 14(8) A template that is exported more than once | Behaviour that 5.11
in a program. requires no

diagnostics

156 14(8) A non-exported template which is neither Behaviour that 5.12
defined in every translation unit in which requires no
it is implicitly instantiated nor explicitly diagnostics
instantiated in some translation unit

157 14.3.3(2) | A specialization is not visible at the point Behaviour that 5.13
of instantiation, and it would have been requires no
selected had it been visible. diagnostics

158 14.5.4(1) | A partial specialization of a template Behaviour that | Rule 14-7-3 5.14
1s not declared before its first use that requires no
would cause implicit instantiation in any diagnostics
translation unit.

159 14.5.5.1(7) | À program contains declarations of Behaviour that 5.15
function templates that are functionally requires no
equivalent but not equivalent. diagnostics

160 14.6(7) | No valid specialization can be generated Behaviour that 5.16
for a template definition, but the template requires no
is not instantiated. diagnostics

161 14.6.4.1(7) | Two different points of instantiation give a | Behaviour that | Rule 14-7-3 5.17
template specialization different meanings requires no
according to the one definition rule. diagnostics

162 14.6.4.2(1) | If a function call that depends on a Undefined 2.68
template parameter would be ill-formed
or would find a better match had the
lookup within the associated namespaces
considered all the function declarations
with external linkage introduced with those
namespaces in all translation units

163 14.7.1(14) | The instantiation of a template produces Undefined 2.69
recursion beyond some defined limit

164 14.7.1(14) | The limit on the total depth of recursive Implementation 3.48

 

 

 

instantiation of templates

 

 

 

 

 

201

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

MISRA
Id

ISO
Reference

Description

Category

MISRA
Guidance

Source
Id

 

165

14.7.1(5)

Whether the instantiation occurs when the
overload resolution process can determine
the correct function to call without
instantiating a class template definition.

Unspecified

1.26

 

166

14.7.1(9)

Whether an implementation implicitly
instantiates a virtual member function
of a class template if the virtual member
function would not otherwise be
instantiated.

Unspecified

1.27

 

167

14.7.3(6)

An explicit specialization of a template
1s not declared before its first use in
any translation unit that causes implicit
instantiation

Behaviour that
requires no
diagnostics

Rule 14-7-3

5.18

 

168

15.1(4)

The way memory is allocated for the
temporary copy of an exception being
thrown

Unspecified

1.28

 

169

15.1(4)

Deallocation of memory for a temporary
object when the last handler exits by
any means other than a throw and the
temporary object is then destroyed.

Unspecified

1.29

 

170

15.3(10)

Referring to any non-static member or
base class of an object in the handler for
a function-try-block of a constructor or
destructor for that object.

Undefined

Rule 15-3-3

2.70

 

171

15.3(16)

Flowing off the end of a function-try-block
in a value returning function.

Undefined

2.71

 

172

15.3(9)

Whether or not the stack is unwound
before the call to ferminate(), in the case
where no matching handler is found in a
program.

Implementation

Rule 15-1-3
Rule 15-3-1
Rule 15-3-2
Rule 15-34
Rule 15-5-1

3.49

 

173

15.4(2)

Sets of fype-ids in exception-specifications
in two translation units differ.

Behaviour that
requires no
diagnostics

Rule 15-4-1

5.19

 

174

15.5.2(2)

The object of type sfd::bad exception that
is used to replace an exception thrown or
re-thrown by the wrexpectedf) function that
the exception-specification does not allow.

Implementation

3.50

 

175

16.1(4)

The token defined is generated during the
expansion of a #if or #elif pre-processing
directive.

Undefined

2.72

 

176

16.1(4)

The #defined pre-processing directive does
not match one of the two specified forms.

Undefined

Rule 16-1-1

2.73

 

177

16.1(4)

Whether the value of an interpreted
character literal matches the value obtained
when an identical character literal occurs
in an expression.

Implementation

3.51

 

178

 

 

16.1(4)

 

Whether a single-character character literal
may have a negative value.

 

Implementation

 

 

3.52

 

 

202

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

MISRA
Id

ISO
Reference

Description

Category

MISRA
Guidance

Source
Id

 

179

16.2(2)

The sequence of places searched for the
header file specified between the < and
> delimiters due to a #include <h-char-
sequence> new-line pre-processing
directive.

Implementation

3.53

 

180

16.2(2)

During execution of a #include pre-
processor directive, how the places
are searched and how the header file is
identified.

Implementation

3.54

 

181

16.2(3)

The sequence of places searched for the
header file specified in quotes in a #include
"g-char-sequence" new-line pre-processing
directive.

Implementation

3.55

 

182

16.2(4)

The #include pre-processing directive that
results after expansion does not match one
of the header name forms.

Undefined

Rule 16-2-6

2.74

 

183

16.2(4)

The method by which a sequence of pre-
processing tokens between < and > or a
pair of" characters is combined into a
single header name pre-processing token.

Implementation

3.56

 

184

16.2(5)

The mapping between the delimited
sequence and the external source file name.

Implementation

3.57

 

185

16.2(6)

The nesting limit to which an #include pre-
processing directive may appear due to the
#include directive of another file.

Implementation

3.58

 

186

16.3(10)

A function-like macro argument consists of
no pre-processing tokens.

Undefined

Rule 16-04

2.75

 

187

16.3(10)

There are sequences of pre-processing
tokens within the list of function-like
macro arguments that would otherwise act
as pre-processing directive lines.

Undefined

Rule 16-0-5

2.76

 

188

16.3.2(2)

The order of evaluation of # and ##
operators.

Unspecified

 

189

16.3.2(2)

The result of the pre-processing operator #
is not a valid character string literal.

Undefined

 

190

16.3.3(3)

The order of evaluation of ## operators.

Unspecified

 

191

16.3.3(3)

The result of the pre-processing
concatenation operator ## is not a valid
pre-processing token.

Undefined

2.78

 

192

16.4(3)

The #line pre-processing directive specifies
zero or a number greater than 32767.

Undefined

2.79

 

193

164(5)

The #line pre-processing directive that
results after expansion does not match one
of the two well-defined forms.

Undefined

2.80

 

194

16.6(1)

The behaviour of the implementation due
to the #pragma pre-processing directive.

Implementation

Rule 16-6-1

3.59

 

195

 

 

16.8(1)

 

The date/time supplied, as a result of the
__ DATE macro, if the date of translation
is not available.

 

Implementation

 

 

3.60

 

 

203

He Yulin. 12 Oct 2010. Copy 1 of 1

Licensed to: Insigma Raïl Transport. Engineering Co.

 
Append ix B (continued)

 

 

 

MISRA ISO Description Category MISRA Source
Id Reference Guidance Id
196 16.8(1) | The date/time supplied, as a result of the Implementation 3.61

__ TIME macro, if the time of translation
is not available.

 

 

197 16.8(1) | Whether S7DC is predefined and its Implementation 3.62
value.
198 16.8(3) | One ofthe following identifiers is Undefined Rule 17-0-1 2.81

the subject of a #define or a #undef
pre-processing directive. LINE,

__ FILE, DATE, TIME,
__STDC_,_ cplusplus, or the identifier
defined.

 

 

 

 

 

 

 

 

 

 

 

 

204 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Appendix C

 

Appendix C: Glossary

ADL

ADL is an abbreviation for argument-dependent lookup.

Aggregate

An array is an aggregale. À class is an aggregafe if all the following apply:
+ _ It has no user declared constructors;
*_Ithas no private or protected non-static data members;
+ Ithas no base classes;

°_ Ithas no virtual functions.

Associated namespace

An associated namespace is an additional namespace that is searched during argument-dependent
lookup. The set of associated namespaces is described in ISO/IEC 14882:2003 [1] $3.42(2).

Callback

A callback is a function that is called indirectly via a function pointer or a handle.

Class-data

The class-data for a class is allnon-static member data and any resources acquired in the constructor
or released in the destructor.

Code

Code consists of everything within a translation unitthat is notexcluded by conditional compilation.
Note that code also includes any declarations and definitions that are introduced by the compiler
(e.g. default constructors, etc).

Compatible types

Compatible types are types that, for the purpose of declaration matching, are treated as the same.
Two identical types are compatible but two compatible types need not be identical. For example,
short int and short are compatible.

Dataflow anomaly
The state of a variable at a point in a program can be described using the following terms:
*_ Undefined (U): The value of the variable is indeterminate;
+ Referenced (R): The variable is used in some way (e.g. in an expression);
*_ Defined (D): The variable is explicitly initialised or assigned a value.
Given the above, the following dataflow anomalies can be defined:
°__UR dataflow anomaly: Variable not assigned a value before the specified use;
°_ DU dataflow anomaly: Variable is assigned a value that is never subsequently used;
*_ DD dataflow anomaly: Variable is assigned a value twice with no intermediate use.
DD dataflow anomaly

See dataflow anomaly.

 

205 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append ix C (continued)

 

Dead code

Dead code (also known as redundant code) consists of evaluated expressions whose removal
would not affect the output of a program.

Declaration

For the purposes of this standard, in headline rule text a declaration is the first introduction of
a name into a translation unit. AÏL subsequent ‘“‘declarations” (as per ISO/IEC 14882:2003 [1]
$3.2(1)) are re-declarations.

À definition is also always either a declaration or re-declaration, but with the characteristics
described in ISO/IEC 14882:2003 [1] $3.2(2).

Definition

See Declaration.

DU dataflow anomaly

See dataflow anomaly.

Function set
À function set is:
+ _ A function;

+ _ A function overload set.
Generic function

A function template or operator template that can be called without explicit template arguments
and whose parameters are of built-in type or which are generic parameters. For example:

template <typename T> void f(T const & t);

Generic parameter
À template type parameter T is a generic parameter if, in the function declaration, it has the
(possibly cv-qualified) form T &.,

El"
For example:

T const & €
T
T volatile

Handle

À handle is a variable that refers to a resource.

Header file

À header file is any file that is the subject of a #include directive. Note that the filename extension
1s not significant.

Include guard

An include guard is a construct used to avoid the problems associated with multiple inclusion
when dealing with the #include directive.

 

206 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append ix C (continued)

 

Infeasible path

Infeasible paths occur where there is a syntactic path to a code fragment, but the semantics ensure
that the control flow path will not be executed. Example:

if ( u32 < 0 )
{

// An unsigned value will never be negative,
// so code in this block will never be executed.

LRM
LRM is an abbreviation for Language Reference Manual.

NDR
NDR ïs an abbreviation for No Diagnostic Required.

ODR
ODR is an abbreviation for the One Definition Rule.

POD
POD is an abbreviation for Plain Old Data.

A struct or union is POD if all the following apply:
+ _Itis an aggregate;
*_ Ithas no non-static members with type non-POD (or array of non-POD);
*_ Ithas no non-static members with type reference;
*__Ithas no user declared copy assignment operator;
*_ Ithas no user declared destructor.

À class is a POD if it is either a sfruct or a union that is a POD.

Project

À project consists of the code from the set of translation units used to build the application.
Primary template

The primary template is the first declaration of a template.

Redundant code

See Dead code.

Re-declaration

See Declaration.

Resource

À resource is an entity whose lifetime is controlled explicitly by the developer. The developer is
therefore responsible for acquiring and relinquishing the resource.

 

207 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Append ix C (continued)

 

Unreachable code

Unreachable code is code to which there is no syntactic (control flow) path, e.g. a function which
is never called, either directly or indirectly.

UR dataflow anomaly

See dataflow anomaly.
Use / used / using

An object is used if it is:
*_ The subject of a cast;
* _ Explicitly initialized at declaration time;
*_ An operand in an expression;
+ _ Referenced.
Unique
Within the rules, unique means that the associated text/rule applies across the whole project.
Unused

À type or object is unused if it is not used.

 

208 Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
ISBN 978-1-906400-03-3 paperback
ISBN 978-1-906400-04-0 PDF

Licensed to: Insigma Raïl Transport. Engineering Co.
He Yulin. 12 Oct 2010. Copy 1 of 1
